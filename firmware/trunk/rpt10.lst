CCS PCH C Compiler, Version 4.141, 64203               21-ат.б.-13 10:25

               Filename:   C:\Users\arnan\Documents\Pi Topping\Firmware\gogo\trunk\rpt10.lst

               ROM used:   21604 bytes (33%)
                           Largest free fragment is 42992
               RAM used:   974 (25%) at main() level
                           2657 (68%) worst case
               Stack:     19 worst case (10 in main + 9 for interrupts)

0000:  GOTO   4E8A
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FF2.5
0056:  GOTO   0060
005A:  BTFSC  FF2.2
005C:  GOTO   130C
0060:  BTFSS  F9D.0
0062:  GOTO   006C
0066:  BTFSC  F9E.0
0068:  GOTO   13EE
006C:  BTFSS  F9D.1
006E:  GOTO   0078
0072:  BTFSC  F9E.1
0074:  GOTO   17AE
0078:  BTFSS  FA0.1
007A:  GOTO   0084
007E:  BTFSC  FA1.1
0080:  GOTO   17BE
0084:  BTFSS  F9D.5
0086:  GOTO   0090
008A:  BTFSC  F9E.5
008C:  GOTO   11FE
0090:  BTFSS  FA0.0
0092:  GOTO   009C
0096:  BTFSC  FA1.0
0098:  GOTO   181A
009C:  BTFSS  FA0.4
009E:  GOTO   00A8
00A2:  BTFSC  FA1.4
00A4:  GOTO   1140
00A8:  MOVFF  0E,00
00AC:  MOVFF  0F,01
00B0:  MOVFF  10,02
00B4:  MOVFF  11,03
00B8:  MOVFF  0C,FE9
00BC:  MOVFF  07,FEA
00C0:  BSF    07.7
00C2:  MOVFF  08,FE1
00C6:  MOVFF  09,FE2
00CA:  MOVFF  0A,FD9
00CE:  MOVFF  0B,FDA
00D2:  MOVFF  12,FF3
00D6:  MOVFF  13,FF4
00DA:  MOVFF  14,FFA
00DE:  MOVFF  15,FF5
00E2:  MOVFF  16,FF6
00E6:  MOVFF  17,FF7
00EA:  MOVF   04,W
00EC:  MOVFF  06,FE0
00F0:  MOVFF  05,FD8
00F4:  RETFIE 0
.................... // 
.................... // gogo40.c - Contains the core functions of the gogo board firmware 
.................... // 
.................... // Copyright (C) 2001-2008 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
.................... #case 
....................  
.................... #include <18F66J50.H> 
.................... //////// Standard Header file for the PIC18F66J50 device //////////////// 
.................... #device PIC18F66J50 
*
*
*
*
*
*
*
*
*
*
.................... #list 
....................  
.................... #device ADC=10 *=16 
....................  
.................... #FUSES NOWDT, WDT128, PLL5, NOXINST, HSPLL, NOIESO, NOPROTECT, NOCPUDIV 
.................... #use delay(clock=48M) 
18F4:  MOVLW  09
18F6:  MOVWF  FEA
18F8:  MOVLW  2B
18FA:  MOVWF  FE9
18FC:  MOVF   FEF,W
18FE:  BZ    191C
1900:  MOVLW  0F
1902:  MOVWF  01
1904:  CLRF   00
1906:  DECFSZ 00,F
1908:  BRA    1906
190A:  DECFSZ 01,F
190C:  BRA    1904
190E:  MOVLW  8F
1910:  MOVWF  00
1912:  DECFSZ 00,F
1914:  BRA    1912
1916:  NOP   
1918:  DECFSZ FEF,F
191A:  BRA    1900
191C:  RETURN 0
2854:  MOVLW  01
2856:  MOVLB  2
2858:  SUBWF  xE4,F
285A:  BNC   2876
285C:  MOVLW  02
285E:  MOVWF  FEA
2860:  MOVLW  E4
2862:  MOVWF  FE9
2864:  MOVF   FEF,W
2866:  BZ    2876
2868:  MOVLW  02
286A:  MOVWF  00
286C:  DECFSZ 00,F
286E:  BRA    286C
2870:  BRA    2872
2872:  DECFSZ FEF,F
2874:  BRA    2868
2876:  MOVLB  0
2878:  RETURN 0
....................  
....................  
.................... #byte OSCTUNE = 0xF9B 
.................... #bit PLLEN=OSCTUNE.6 
....................  
....................  
.................... #byte INTCON2 = 0xFF1 
.................... #bit RBPU=INTCON2.7   // Port B internal pull-up enable bit (0=enable) 
....................  
....................  
....................                           
....................  
....................  
....................  
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_puts(*ptr) - Sends the null terminated string to the    //// 
.................... ////     the transmit buffer.  Unlike usb_cdc_putc() or              //// 
.................... ////     usb_cdc_putc_fast(), this routine will fit the string in    //// 
.................... ////     one packet (whereas the other functions will flush the      //// 
.................... ////     buffer as soon as the endpoint is free).                    //// 
.................... ////     Returns TRUE if the packet was sent, FALSE if the buffer    //// 
.................... ////     was still in use.                                           //// 
.................... ////     Will stop copying characters from ptr to the endpoint       //// 
.................... ////     buffer once it is full (but it will still return TRUE).     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putempty() - Returns TRUE if the transmit buffers are   //// 
.................... ////     empty and fully flushed/transmitted to host (PC).           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_serial_state(state) - Transmit to the host our          //// 
.................... ////       SERIAL_STATE.  This holds information such as DCD, DSR,   //// 
.................... ////       ring, break and more.  See the documentation above        //// 
.................... ////       usb_cdc_serial_state() for more information, including    //// 
.................... ////       format of state structure.                                //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.                                           //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// September 13th, 2012:                                           //// 
.................... ////  Fixed a possible corruption that would occur on 16bit PICs     //// 
.................... ////     (PIC24, dsPIC33).                                           //// 
.................... ////  Added usb_cdc_putempty().                                      //// 
.................... ////                                                                 //// 
.................... //// December 16th, 2011:                                            //// 
.................... ////  Added __USB_CDC_HELPERS_ONLY__.  If defined, this library will //// 
.................... ////     only include the get string helper functions.  This is      //// 
.................... ////     a rarely used option, used only if you already wrote your   //// 
.................... ////     own getc() and putc() routines.                             //// 
.................... ////  usb_cdc_flush_out_buffer() checks len buffer before flushing.  //// 
.................... ////  usb_isr_tok_in_cdc_data_dne() doesn't check len, now that      //// 
.................... ////     usb_cdc_flush_out_buffer() is checking len.                 //// 
.................... ////                                                                 //// 
.................... //// Oct 27th, 2011:                                                 //// 
.................... ////  Added SERIAL_STATE support.  See usb_cdc_serial_state() for    //// 
.................... ////     documentation.  In order for this to work,                  //// 
.................... ////     USB_CDC_COMM_IN_SIZE has to be 11 bytes or bigger.          //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?  //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).   //// 
.................... ////                                                                 //// 
.................... //// Jan 28, 2010:                                                   //// 
.................... ////  Added usb_cdc_puts(str), which will fit the entire str into    //// 
.................... ////     one packet.                                                 //// 
.................... ////                                                                 //// 
.................... //// Jan 25, 2010:                                                   //// 
.................... ////  Ignore incoming 0 length packets.                              //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// April 7th, 2009:                                                //// 
.................... ////   Vista 'code 10' issues resolved.                              //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 26th, 2007:                                                 //// 
.................... ////              usb_cdc_put_buffer_free() should be more stable.   //// 
.................... ////              Fixed a hang-up that would happen if you sent      //// 
.................... ////                 exactly 64 bytes.                               //// 
.................... ////                                                                 //// 
.................... //// Nov 6th, 2007:                                                  //// 
.................... ////              Compatabible with latest pic18_usb.h, which        //// 
.................... ////                 reduces RAM footprint of USB driver.            //// 
.................... ////              This driver now fits on 18F4450/2450 PICs.         //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... /* 
....................    usb_cdc_putc() will not work correctly if interrupts are disabled, this 
....................    also means it will not work if you call usb_cdc_putc() from inside another 
....................    interrupt. 
....................     
....................    Workaround is to call  _usb_cdc_putc_fast_noflush() instead.  This routine 
....................    will erase last character if you put too many characters into the endpoint 
....................    buffer.  Since this routine doesn't flush the endpoint buffer, you will 
....................    also have to add this code in your main loop to check if buffer needs 
....................    to be transmitted: 
....................       if (usb_cdc_put_buffer_nextin && usb_cdc_put_buffer_free())  
....................       { 
....................          usb_cdc_flush_out_buffer(); 
....................       } 
.................... */ 
.................... //#warning usb_cdc_putc() needs to be improved to work if ISR is disabled (or if called inside an ISR).  See above comments for workaround 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, unsigned int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... #if !defined(__USB_CDC_HELPERS_ONLY__) 
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putempty() ((usb_cdc_put_buffer_nextin==0) && usb_cdc_put_buffer_free()) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<sizeof(usb_cdc_put_buffer)) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
.................... void usb_cdc_get_discard(void); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__   1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................    #if defined(__PCH__) 
....................     #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................    #else 
....................     #include <pic24_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
....................    #endif 
.................... #else 
....................    #include <usbn960x.h> 
.................... #endif 
.................... #ifndef __USB_DESCRIPTORS__ 
.................... #include <usb_desc_cdc.h>   //USB Configuration and Device descriptors for this USB device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// Oct 27th, 2011:                                                   //// 
.................... ////   Increased USB_CDC_COMM_IN_SIZE default size to 11 so we can     //// 
.................... ////     send SERIAL_STATE messages in one packet.                     //// 
.................... ////                                                                   //// 
.................... //// April 7th, 2009:                                                  //// 
.................... ////   Vista 'code 10' issues resolved.                                //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #ifndef  USB_CONFIG_PID 
....................    #define  USB_CONFIG_PID       0x0033 
.................... #endif 
.................... #ifndef  USB_CONFIG_VID 
....................    #define  USB_CONFIG_VID       0x0461 
.................... #endif 
.................... #ifndef  USB_CONFIG_BUS_POWER 
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #endif 
.................... #ifndef  USB_CONFIG_VERSION 
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... #endif 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #ifndef USB_CDC_COMM_IN_SIZE 
.................... #define USB_CDC_COMM_IN_SIZE           11 
.................... #endif 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_IN_SIZE 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #endif 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #ifndef USB_CDC_DATA_OUT_SIZE 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #endif 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (interrupt endpoint cant be smaller than 10 for slow speed devices)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==57, 58 
....................          1,  //polling interval, in ms.   ==59 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==66, 67 
....................          1,  //polling interval, in ms.   ==68 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFF,0xFF,0xFF,0xFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1  - manufacturer 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 - product 
....................          24, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'S',0, 
....................          'E',0, 
....................          'R',0, 
....................          'I',0, 
....................          'A',0, 
....................          'L',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'E',0, 
....................          'M',0, 
....................          'O',0 
.................... }; 
.................... #endif   //!defined(USB_STRINGS_OVERWRITTEN) 
....................  
.................... #ENDIF 
....................  
.................... #endif 
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #if defined(__DO_DEBUG_USB) 
....................    #define debug_usb printf 
....................    void debug_putc(char c) {uart_putc(c);} 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) { 
....................       unsigned int8 max=16; 
....................       debug_usb(debug_putc,"[%U - ",len); 
....................       //if (max>len) {max=len;} 
....................       max = len; 
....................       while(max--) { 
....................          debug_usb(debug_putc,"%02X",*ptr); 
....................          len--; 
....................          ptr++; 
....................       } 
....................       if (len) {debug_usb(debug_putc,"...");} 
....................       debug_usb(debug_putc,"] "); 
....................    } 
.................... #else 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................    #define debug_putc(c) 
....................    #define debug_display_ram(x,y) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// Sep 22, 2011:                                                   //// 
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   //// 
.................... ////     primarily developed for users developing code where         //// 
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Added initial 18F47J53 family support.                         //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \ 
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") \ 
....................        ) 
....................  #define __USB_18FJ53__ 
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use 
....................  #define USB_BDT_START  0xD00 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if !defined(USB_BDT_START) 
.................... #define USB_BDT_START   USB_RAM_START 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if defined(USB_RAM_START) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #else 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #if defined(USB_RAM_START) 
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
.................... #else 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if defined(USB_RAM_START) 
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
.................... #define g_USBBDT g_USBRAM.bd 
.................... #else 
.................... struct 
.................... { 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... struct 
.................... { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
.................... } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
.................... #locate g_USBBDT=USB_BDT_START 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #elif defined(__USB_18FJ53__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
0CBE:  CLRF   03
0CC0:  MOVLB  A
0CC2:  MOVF   x5B,W
0CC4:  ADDLW  4C
0CC6:  MOVWF  FE9
0CC8:  MOVLW  0F
0CCA:  ADDWFC 03,W
0CCC:  MOVWF  FEA
0CCE:  MOVF   FEF,F
0CD0:  BZ    0D08
0CD2:  CLRF   x5D
0CD4:  MOVFF  A5B,A5C
0CD8:  CLRF   x5F
0CDA:  MOVLW  08
0CDC:  MOVWF  x5E
0CDE:  MOVLB  0
0CE0:  CALL   030A
0CE4:  MOVFF  02,A5D
0CE8:  MOVFF  01,A5C
0CEC:  MOVLW  04
0CEE:  MOVLB  A
0CF0:  ADDWF  x5C,F
0CF2:  MOVLW  00
0CF4:  ADDWFC x5D,F
0CF6:  MOVFF  A5C,FE9
0CFA:  MOVLW  04
0CFC:  ADDWF  x5D,W
0CFE:  MOVWF  FEA
0D00:  MOVFF  FEF,A5E
0D04:  BTFSS  x5E.7
0D06:  BRA    0D0C
0D08:  MOVLW  00
0D0A:  BRA    0D0E
0D0C:  MOVLW  01
0D0E:  MOVWF  01
.................... } 
0D10:  MOVLB  0
0D12:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
191E:  CLRF   F65
....................    UIE = 0;   //disable USB interrupts 
1920:  MOVLB  F
1922:  CLRF   x5C
....................    UCFG = __UCFG_VAL_DISABLED__; 
1924:  MOVLW  08
1926:  MOVWF  x5F
....................  
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
1928:  MOVF   F97,W
192A:  IORLW  18
192C:  MOVLB  2
192E:  MOVWF  F97
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5 
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
1930:  CLRF   22
1932:  CLRF   19
1934:  BTFSC  FF2.7
1936:  BSF    19.7
1938:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
193A:  MOVLB  0
193C:  CALL   0436
1940:  BTFSC  19.7
1942:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
1944:  GOTO   194A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
194C:  CLRF   19
194E:  BTFSC  FF2.7
1950:  BSF    19.7
1952:  BCF    FF2.7
....................    usb_token_reset(); 
1954:  CALL   0436
1958:  BTFSC  19.7
195A:  BSF    FF2.7
....................    UCON = 0; 
195C:  CLRF   F65
....................    UCFG = __UCFG_VAL_ENABLED__; 
195E:  MOVLW  14
1960:  MOVLB  F
1962:  MOVWF  x5F
....................    UIE = 0;                                // Mask all USB interrupts 
1964:  CLRF   x5C
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
1966:  BSF    F65.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
1968:  MOVLW  01
196A:  MOVWF  22
.................... } 
196C:  MOVLB  0
196E:  GOTO   1978 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
1948:  BRA    191E
.................... } 
194A:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
1972:  BTFSC  F65.3
1974:  BRA    1978
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
1976:  BRA    194C
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
1978:  DECFSZ 22,W
197A:  BRA    1996
197C:  BTFSC  F65.5
197E:  BRA    1996
....................    { 
....................       UIR=0; 
1980:  CLRF   F62
....................       UIE=0; 
1982:  MOVLB  F
1984:  CLRF   x5C
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
1986:  BSF    FA0.4
....................       enable_interrupts(GLOBAL); 
1988:  MOVLW  C0
198A:  IORWF  FF2,F
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
198C:  MOVLW  11
198E:  MOVWF  x5C
....................       usb_state=USB_STATE_POWERED; 
1990:  MOVLW  02
1992:  MOVWF  22
1994:  MOVLB  0
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
1996:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
1998:  RCALL  1948
....................  
....................    do  
....................    { 
....................       usb_task(); 
199A:  RCALL  1972
....................    } while (usb_state != USB_STATE_POWERED); 
199C:  MOVF   22,W
199E:  SUBLW  02
19A0:  BNZ   199A
.................... } 
19A2:  GOTO   1D38 (RETURN)
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
0D14:  MOVFF  A56,A5B
0D18:  RCALL  0CBE
0D1A:  MOVF   01,F
0D1C:  BTFSC  FD8.2
0D1E:  BRA    0E2A
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0D20:  MOVLB  A
0D22:  CLRF   x5D
0D24:  MOVFF  A56,A5C
0D28:  CLRF   x5F
0D2A:  MOVLW  08
0D2C:  MOVWF  x5E
0D2E:  MOVLB  0
0D30:  CALL   030A
0D34:  MOVFF  02,A5C
0D38:  MOVFF  01,A5B
0D3C:  MOVLW  04
0D3E:  MOVLB  A
0D40:  ADDWF  x5B,F
0D42:  MOVLW  00
0D44:  ADDWFC x5C,F
0D46:  MOVLW  01
0D48:  ADDWF  x5B,W
0D4A:  MOVWF  01
0D4C:  MOVLW  00
0D4E:  ADDWFC x5C,W
0D50:  MOVWF  03
0D52:  MOVFF  01,FE9
0D56:  MOVLW  04
0D58:  ADDWF  03,W
0D5A:  MOVWF  FEA
0D5C:  MOVFF  A57,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0D60:  MOVF   x59,W
0D62:  SUBLW  02
0D64:  BNZ   0DA6
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0D66:  CLRF   x5D
0D68:  MOVFF  A56,A5C
0D6C:  CLRF   x5F
0D6E:  MOVLW  08
0D70:  MOVWF  x5E
0D72:  MOVLB  0
0D74:  CALL   030A
0D78:  MOVFF  02,A5C
0D7C:  MOVFF  01,A5B
0D80:  MOVLW  04
0D82:  MOVLB  A
0D84:  ADDWF  x5B,F
0D86:  MOVLW  00
0D88:  ADDWFC x5C,F
0D8A:  MOVFF  A5B,FE9
0D8E:  MOVLW  04
0D90:  ADDWF  x5C,W
0D92:  MOVWF  FEA
0D94:  MOVFF  FEF,A5A
....................          if (bit_test(i,6)) 
0D98:  BTFSS  x5A.6
0D9A:  BRA    0DA0
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0D9C:  CLRF   x59
....................          else 
0D9E:  BRA    0DA4
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0DA0:  MOVLW  01
0DA2:  MOVWF  x59
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
0DA4:  BRA    0DDA
0DA6:  MOVF   x59,W
0DA8:  SUBLW  04
0DAA:  BNZ   0DDA
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0DAC:  CLRF   x5D
0DAE:  MOVFF  A56,A5C
0DB2:  CLRF   x5F
0DB4:  MOVLW  08
0DB6:  MOVWF  x5E
0DB8:  MOVLB  0
0DBA:  CALL   030A
0DBE:  MOVLB  A
0DC0:  MOVFF  01,FE9
0DC4:  MOVLW  04
0DC6:  ADDWF  02,W
0DC8:  MOVWF  FEA
0DCA:  MOVFF  FEF,A5A
....................          if (bit_test(i,6)) 
0DCE:  BTFSS  x5A.6
0DD0:  BRA    0DD8
....................             tgl = USB_DTS_DATA1; 
0DD2:  MOVLW  01
0DD4:  MOVWF  x59
....................          else 
0DD6:  BRA    0DDA
....................             tgl = USB_DTS_DATA0; 
0DD8:  CLRF   x59
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0DDA:  DECFSZ x59,W
0DDC:  BRA    0DE4
....................          i=0xC8;  //DATA1, UOWN 
0DDE:  MOVLW  C8
0DE0:  MOVWF  x5A
....................       else //if (tgl == USB_DTS_DATA0)  
0DE2:  BRA    0DE8
....................          i=0x88; //DATA0, UOWN 
0DE4:  MOVLW  88
0DE6:  MOVWF  x5A
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0DE8:  BTFSC  x58.0
0DEA:  BSF    x5A.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0DEC:  BTFSC  x58.1
0DEE:  BSF    x5A.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0DF0:  CLRF   x5D
0DF2:  MOVFF  A56,A5C
0DF6:  CLRF   x5F
0DF8:  MOVLW  08
0DFA:  MOVWF  x5E
0DFC:  MOVLB  0
0DFE:  CALL   030A
0E02:  MOVFF  02,A5C
0E06:  MOVFF  01,A5B
0E0A:  MOVLW  04
0E0C:  MOVLB  A
0E0E:  ADDWF  x5B,F
0E10:  MOVLW  00
0E12:  ADDWFC x5C,F
0E14:  MOVFF  A5B,FE9
0E18:  MOVLW  04
0E1A:  ADDWF  x5C,W
0E1C:  MOVWF  FEA
0E1E:  MOVFF  A5A,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0E22:  MOVLW  01
0E24:  MOVWF  01
0E26:  BRA    0E30
....................    } 
....................    else  
0E28:  MOVLB  0
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0E2A:  MOVLW  00
0E2C:  MOVWF  01
0E2E:  MOVLB  A
.................... } 
0E30:  MOVLB  0
0E32:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
0F4C:  MOVFF  A4E,A5B
0F50:  RCALL  0CBE
0F52:  MOVF   01,F
0F54:  BZ    0FE4
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
0F56:  MOVLB  A
0F58:  CLRF   x5D
0F5A:  MOVFF  A4E,A5C
0F5E:  CLRF   x5F
0F60:  MOVLW  08
0F62:  MOVWF  x5E
0F64:  MOVLB  0
0F66:  CALL   030A
0F6A:  MOVFF  02,A57
0F6E:  MOVFF  01,A56
0F72:  MOVLW  04
0F74:  MOVLB  A
0F76:  ADDWF  x56,F
0F78:  MOVLW  00
0F7A:  ADDWFC x57,F
0F7C:  MOVLW  02
0F7E:  ADDWF  x56,W
0F80:  MOVWF  01
0F82:  MOVLW  00
0F84:  ADDWFC x57,W
0F86:  MOVWF  03
0F88:  MOVFF  01,FE9
0F8C:  MOVLW  04
0F8E:  ADDWF  03,W
0F90:  MOVWF  FEA
0F92:  MOVFF  FEC,A55
0F96:  MOVF   FED,F
0F98:  MOVFF  FEF,A54
....................       memcpy(buff_add, ptr, len);      
0F9C:  MOVFF  A55,FEA
0FA0:  MOVFF  A54,FE9
0FA4:  MOVFF  A50,FE2
0FA8:  MOVFF  A4F,FE1
0FAC:  MOVFF  A52,02
0FB0:  MOVFF  A51,01
0FB4:  MOVF   01,F
0FB6:  BZ    0FBC
0FB8:  INCF   02,F
0FBA:  BRA    0FC0
0FBC:  MOVF   02,F
0FBE:  BZ    0FCC
0FC0:  MOVFF  FE6,FEE
0FC4:  DECFSZ 01,F
0FC6:  BRA    0FC0
0FC8:  DECFSZ 02,F
0FCA:  BRA    0FC0
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
0FCC:  MOVFF  A4E,A56
0FD0:  MOVFF  A52,A58
0FD4:  MOVFF  A51,A57
0FD8:  MOVFF  A53,A59
0FDC:  MOVLB  0
0FDE:  RCALL  0D14
0FE0:  MOVF   01,W
0FE2:  BRA    0FE8
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
0FE4:  MOVLW  00
0FE6:  MOVWF  01
.................... } 
0FE8:  RETURN 0
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
0BC2:  MOVLB  A
0BC4:  CLRF   x5D
0BC6:  MOVFF  A4E,A5C
0BCA:  CLRF   x5F
0BCC:  MOVLW  08
0BCE:  MOVWF  x5E
0BD0:  MOVLB  0
0BD2:  CALL   030A
0BD6:  MOVLB  A
0BD8:  MOVFF  01,FE9
0BDC:  MOVLW  04
0BDE:  ADDWF  02,W
0BE0:  MOVWF  FEA
0BE2:  MOVFF  FEF,A50
....................    if (tgl == USB_DTS_TOGGLE)  
0BE6:  MOVF   x4F,W
0BE8:  SUBLW  02
0BEA:  BNZ   0BF8
....................    { 
....................       if (bit_test(i,6)) 
0BEC:  BTFSS  x50.6
0BEE:  BRA    0BF4
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0BF0:  CLRF   x4F
....................       else 
0BF2:  BRA    0BF8
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0BF4:  MOVLW  01
0BF6:  MOVWF  x4F
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0BF8:  MOVF   x4F,W
0BFA:  SUBLW  03
0BFC:  BNZ   0C36
....................    { 
....................       i = 0x84; 
0BFE:  MOVLW  84
0C00:  MOVWF  x50
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0C02:  CLRF   x5D
0C04:  MOVFF  A4E,A5C
0C08:  CLRF   x5F
0C0A:  MOVLW  08
0C0C:  MOVWF  x5E
0C0E:  MOVLB  0
0C10:  CALL   030A
0C14:  MOVFF  02,A54
0C18:  MOVFF  01,A53
0C1C:  MOVLW  04
0C1E:  MOVLB  A
0C20:  ADDWF  x53,F
0C22:  MOVLW  00
0C24:  ADDWFC x54,F
0C26:  MOVFF  A53,FE9
0C2A:  MOVLW  04
0C2C:  ADDWF  x54,W
0C2E:  MOVWF  FEA
0C30:  MOVLW  84
0C32:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
0C34:  BRA    0C44
0C36:  DECFSZ x4F,W
0C38:  BRA    0C40
....................       i = 0xC8;  //DATA1, UOWN 
0C3A:  MOVLW  C8
0C3C:  MOVWF  x50
....................    else //if (tgl == USB_DTS_DATA0)  
0C3E:  BRA    0C44
....................       i = 0x88; //DATA0, UOWN 
0C40:  MOVLW  88
0C42:  MOVWF  x50
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0C44:  BCF    FD8.0
0C46:  RLCF   x4E,W
0C48:  CLRF   03
0C4A:  MOVLB  0
0C4C:  CALL   0166
0C50:  TBLRD*+
0C52:  MOVFF  FF5,03
0C56:  MOVLB  A
0C58:  MOVWF  x51
0C5A:  MOVFF  03,A52
....................    EP_BDxCNT_O(endpoint) = len; 
0C5E:  CLRF   x5D
0C60:  MOVFF  A4E,A5C
0C64:  CLRF   x5F
0C66:  MOVLW  08
0C68:  MOVWF  x5E
0C6A:  MOVLB  0
0C6C:  CALL   030A
0C70:  MOVFF  01,A53
0C74:  MOVLW  01
0C76:  MOVLB  A
0C78:  ADDWF  01,W
0C7A:  MOVWF  01
0C7C:  MOVLW  00
0C7E:  ADDWFC 02,W
0C80:  MOVWF  03
0C82:  MOVFF  01,FE9
0C86:  MOVLW  04
0C88:  ADDWF  03,W
0C8A:  MOVWF  FEA
0C8C:  MOVFF  A51,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0C90:  BTFSC  x52.0
0C92:  BSF    x50.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0C94:  BTFSC  x52.1
0C96:  BSF    x50.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0C98:  CLRF   x5D
0C9A:  MOVFF  A4E,A5C
0C9E:  CLRF   x5F
0CA0:  MOVLW  08
0CA2:  MOVWF  x5E
0CA4:  MOVLB  0
0CA6:  CALL   030A
0CAA:  MOVLB  A
0CAC:  MOVFF  01,FE9
0CB0:  MOVLW  04
0CB2:  ADDWF  02,W
0CB4:  MOVWF  FEA
0CB6:  MOVFF  A50,FEF
.................... } 
0CBA:  MOVLB  0
0CBC:  RETURN 0
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
0E96:  MOVLB  A
0E98:  CLRF   x5D
0E9A:  MOVFF  A4E,A5C
0E9E:  CLRF   x5F
0EA0:  MOVLW  08
0EA2:  MOVWF  x5E
0EA4:  MOVLB  0
0EA6:  CALL   030A
0EAA:  MOVFF  02,A50
0EAE:  MOVFF  01,A4F
0EB2:  MOVLW  01
0EB4:  MOVLB  A
0EB6:  ADDWF  01,W
0EB8:  MOVWF  01
0EBA:  MOVLW  00
0EBC:  ADDWFC 02,W
0EBE:  MOVWF  03
0EC0:  MOVFF  01,FE9
0EC4:  MOVLW  04
0EC6:  ADDWF  03,W
0EC8:  MOVWF  FEA
0ECA:  CLRF   03
0ECC:  MOVFF  FEF,01
0ED0:  MOVFF  03,02
.................... } 
0ED4:  MOVLB  0
0ED6:  GOTO   0EF8 (RETURN)
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
0998:  MOVLB  A
099A:  BCF    x4E.0
099C:  BTFSC  x4D.7
099E:  BSF    x4E.0
....................    endpoint &= 0x7F; 
09A0:  BCF    x4D.7
....................     
....................    if (direction)  
09A2:  BTFSS  x4E.0
09A4:  BRA    09D8
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
09A6:  CLRF   x5D
09A8:  MOVFF  A4D,A5C
09AC:  CLRF   x5F
09AE:  MOVLW  08
09B0:  MOVWF  x5E
09B2:  MOVLB  0
09B4:  RCALL  030A
09B6:  MOVFF  02,A50
09BA:  MOVFF  01,A4F
09BE:  MOVLW  04
09C0:  MOVLB  A
09C2:  ADDWF  x4F,F
09C4:  MOVLW  00
09C6:  ADDWFC x50,F
09C8:  MOVFF  A4F,FE9
09CC:  MOVLW  04
09CE:  ADDWF  x50,W
09D0:  MOVWF  FEA
09D2:  MOVLW  84
09D4:  MOVWF  FEF
....................    } 
....................    else  
09D6:  BRA    09F8
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
09D8:  CLRF   x5D
09DA:  MOVFF  A4D,A5C
09DE:  CLRF   x5F
09E0:  MOVLW  08
09E2:  MOVWF  x5E
09E4:  MOVLB  0
09E6:  RCALL  030A
09E8:  MOVLB  A
09EA:  MOVFF  01,FE9
09EE:  MOVLW  04
09F0:  ADDWF  02,W
09F2:  MOVWF  FEA
09F4:  MOVLW  84
09F6:  MOVWF  FEF
....................    } 
.................... } 
09F8:  MOVLB  0
09FA:  GOTO   0AA8 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
0934:  MOVLB  A
0936:  BCF    x4E.0
0938:  BTFSC  x4D.7
093A:  BSF    x4E.0
....................    endpoint &= 0x7F; 
093C:  BCF    x4D.7
....................     
....................    if (direction)  
093E:  BTFSS  x4E.0
0940:  BRA    0974
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
0942:  CLRF   x5D
0944:  MOVFF  A4D,A5C
0948:  CLRF   x5F
094A:  MOVLW  08
094C:  MOVWF  x5E
094E:  MOVLB  0
0950:  RCALL  030A
0952:  MOVFF  02,A50
0956:  MOVFF  01,A4F
095A:  MOVLW  04
095C:  MOVLB  A
095E:  ADDWF  x4F,F
0960:  MOVLW  00
0962:  ADDWFC x50,F
0964:  MOVFF  A4F,FE9
0968:  MOVLW  04
096A:  ADDWF  x50,W
096C:  MOVWF  FEA
096E:  MOVLW  88
0970:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
0972:  BRA    0992
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
0974:  CLRF   x5D
0976:  MOVFF  A4D,A5C
097A:  CLRF   x5F
097C:  MOVLW  08
097E:  MOVWF  x5E
0980:  MOVLB  0
0982:  RCALL  030A
0984:  MOVLB  A
0986:  MOVFF  01,FE9
098A:  MOVLW  04
098C:  ADDWF  02,W
098E:  MOVWF  FEA
0990:  CLRF   FEF
....................    } 
.................... } 
0992:  MOVLB  0
0994:  GOTO   0A98 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
09FE:  MOVLB  A
0A00:  BCF    x4E.0
0A02:  BTFSC  x4D.7
0A04:  BSF    x4E.0
....................    endpoint &= 0x7F; 
0A06:  BCF    x4D.7
....................     
....................    if (direction)  
0A08:  BTFSS  x4E.0
0A0A:  BRA    0A3E
....................    { 
....................       st=EP_BDxST_I(endpoint); 
0A0C:  CLRF   x5D
0A0E:  MOVFF  A4D,A5C
0A12:  CLRF   x5F
0A14:  MOVLW  08
0A16:  MOVWF  x5E
0A18:  MOVLB  0
0A1A:  RCALL  030A
0A1C:  MOVFF  02,A51
0A20:  MOVFF  01,A50
0A24:  MOVLW  04
0A26:  MOVLB  A
0A28:  ADDWF  x50,F
0A2A:  MOVLW  00
0A2C:  ADDWFC x51,F
0A2E:  MOVFF  A50,FE9
0A32:  MOVLW  04
0A34:  ADDWF  x51,W
0A36:  MOVWF  FEA
0A38:  MOVFF  FEF,A4F
....................    } 
....................    else  
0A3C:  BRA    0A5E
....................    { 
....................       st=EP_BDxST_O(endpoint); 
0A3E:  CLRF   x5D
0A40:  MOVFF  A4D,A5C
0A44:  CLRF   x5F
0A46:  MOVLW  08
0A48:  MOVWF  x5E
0A4A:  MOVLB  0
0A4C:  RCALL  030A
0A4E:  MOVLB  A
0A50:  MOVFF  01,FE9
0A54:  MOVLW  04
0A56:  ADDWF  02,W
0A58:  MOVWF  FEA
0A5A:  MOVFF  FEF,A4F
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
0A5E:  BTFSS  x4F.7
0A60:  BRA    0A66
0A62:  BTFSC  x4F.2
0A64:  BRA    0A6A
0A66:  MOVLW  00
0A68:  BRA    0A6C
0A6A:  MOVLW  01
0A6C:  MOVWF  01
.................... } 
0A6E:  MOVLB  0
0A70:  GOTO   0AC0 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address)  
.................... { 
....................    UADDR = address; 
0F24:  MOVFF  A4E,F5E
....................     
....................    if (address)  
0F28:  MOVLB  A
0F2A:  MOVF   x4E,F
0F2C:  BZ    0F34
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0F2E:  MOVLW  04
0F30:  MOVWF  22
....................    } 
....................    else  
0F32:  BRA    0F38
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0F34:  MOVLW  02
0F36:  MOVWF  22
....................    } 
.................... } 
0F38:  MOVLB  0
0F3A:  GOTO   0F48 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config)  
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................     
....................    if (config == 0) 
05FE:  MOVLB  A
0600:  MOVF   x4D,F
0602:  BNZ   0610
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
0604:  MOVLW  04
0606:  MOVWF  22
....................       usb_disable_endpoints(); 
0608:  MOVLB  0
060A:  RCALL  039C
....................    } 
....................    else  
060C:  BRA    07DC
060E:  MOVLB  A
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
0610:  MOVLW  05
0612:  MOVWF  22
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
0614:  MOVLW  04
0616:  MOVWF  x50
0618:  MOVLW  98
061A:  MOVWF  x4F
....................       for (en=1; en<USB_NUM_UEP; en++)  
061C:  MOVLW  01
061E:  MOVWF  x4E
0620:  MOVF   x4E,W
0622:  SUBLW  0F
0624:  BTFSS  FD8.0
0626:  BRA    07DC
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
0628:  MOVFF  A4E,A56
062C:  MOVLB  0
062E:  RCALL  032C
....................          new_uep = 0; 
0630:  MOVLB  A
0632:  CLRF   x51
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
0634:  CLRF   03
0636:  MOVF   x4E,W
0638:  MOVLB  0
063A:  RCALL  0116
063C:  SUBLW  FF
063E:  BZ    070A
....................          { 
....................             new_uep = 0x04; 
0640:  MOVLW  04
0642:  MOVLB  A
0644:  MOVWF  x51
....................             len = usb_ep_rx_size[en]; 
0646:  BCF    FD8.0
0648:  RLCF   x4E,W
064A:  CLRF   03
064C:  MOVLB  0
064E:  RCALL  0166
0650:  TBLRD*+
0652:  MOVFF  FF5,03
0656:  MOVLB  A
0658:  MOVWF  x52
065A:  MOVFF  03,A53
....................             EP_BDxCNT_O(en) = len; 
065E:  CLRF   x5D
0660:  MOVFF  A4E,A5C
0664:  CLRF   x5F
0666:  MOVLW  08
0668:  MOVWF  x5E
066A:  MOVLB  0
066C:  RCALL  030A
066E:  MOVFF  01,A55
0672:  MOVLW  01
0674:  MOVLB  A
0676:  ADDWF  01,W
0678:  MOVWF  01
067A:  MOVLW  00
067C:  ADDWFC 02,W
067E:  MOVWF  03
0680:  MOVFF  01,FE9
0684:  MOVLW  04
0686:  ADDWF  03,W
0688:  MOVWF  FEA
068A:  MOVFF  A52,FEF
....................             EP_BDxADR_O(en) = addy; 
068E:  CLRF   x5D
0690:  MOVFF  A4E,A5C
0694:  CLRF   x5F
0696:  MOVLW  08
0698:  MOVWF  x5E
069A:  MOVLB  0
069C:  RCALL  030A
069E:  MOVFF  01,A55
06A2:  MOVLW  02
06A4:  MOVLB  A
06A6:  ADDWF  01,W
06A8:  MOVWF  01
06AA:  MOVLW  00
06AC:  ADDWFC 02,W
06AE:  MOVWF  03
06B0:  MOVFF  01,FE9
06B4:  MOVLW  04
06B6:  ADDWF  03,W
06B8:  MOVWF  FEA
06BA:  MOVFF  A50,FEC
06BE:  MOVF   FED,F
06C0:  MOVFF  A4F,FEF
....................             addy += usb_ep_rx_size[en]; 
06C4:  BCF    FD8.0
06C6:  RLCF   x4E,W
06C8:  CLRF   03
06CA:  MOVLB  0
06CC:  RCALL  0166
06CE:  TBLRD*+
06D0:  MOVFF  FF5,03
06D4:  MOVLB  A
06D6:  ADDWF  x4F,F
06D8:  MOVF   03,W
06DA:  ADDWFC x50,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
06DC:  MOVLW  88
06DE:  MOVWF  x54
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
06E0:  BTFSC  x53.0
06E2:  BSF    x54.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
06E4:  BTFSC  x53.1
06E6:  BSF    x54.1
....................             EP_BDxST_O(en) = i; 
06E8:  CLRF   x5D
06EA:  MOVFF  A4E,A5C
06EE:  CLRF   x5F
06F0:  MOVLW  08
06F2:  MOVWF  x5E
06F4:  MOVLB  0
06F6:  RCALL  030A
06F8:  MOVLB  A
06FA:  MOVFF  01,FE9
06FE:  MOVLW  04
0700:  ADDWF  02,W
0702:  MOVWF  FEA
0704:  MOVFF  A54,FEF
0708:  MOVLB  0
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
070A:  CLRF   03
070C:  MOVLB  A
070E:  MOVF   x4E,W
0710:  MOVLB  0
0712:  RCALL  00F6
0714:  SUBLW  FF
0716:  BZ    07A6
....................          { 
....................             new_uep |= 0x02; 
0718:  MOVLB  A
071A:  BSF    x51.1
....................             EP_BDxADR_I(en) = addy; 
071C:  CLRF   x5D
071E:  MOVFF  A4E,A5C
0722:  CLRF   x5F
0724:  MOVLW  08
0726:  MOVWF  x5E
0728:  MOVLB  0
072A:  RCALL  030A
072C:  MOVFF  02,A56
0730:  MOVFF  01,A55
0734:  MOVLW  04
0736:  MOVLB  A
0738:  ADDWF  x55,F
073A:  MOVLW  00
073C:  ADDWFC x56,F
073E:  MOVLW  02
0740:  ADDWF  x55,W
0742:  MOVWF  01
0744:  MOVLW  00
0746:  ADDWFC x56,W
0748:  MOVWF  03
074A:  MOVFF  01,FE9
074E:  MOVLW  04
0750:  ADDWF  03,W
0752:  MOVWF  FEA
0754:  MOVFF  A50,FEC
0758:  MOVF   FED,F
075A:  MOVFF  A4F,FEF
....................             addy += usb_ep_tx_size[en]; 
075E:  BCF    FD8.0
0760:  RLCF   x4E,W
0762:  CLRF   03
0764:  MOVLB  0
0766:  RCALL  0136
0768:  TBLRD*+
076A:  MOVFF  FF5,03
076E:  MOVLB  A
0770:  ADDWF  x4F,F
0772:  MOVF   03,W
0774:  ADDWFC x50,F
....................             EP_BDxST_I(en) = 0x40; 
0776:  CLRF   x5D
0778:  MOVFF  A4E,A5C
077C:  CLRF   x5F
077E:  MOVLW  08
0780:  MOVWF  x5E
0782:  MOVLB  0
0784:  RCALL  030A
0786:  MOVFF  02,A56
078A:  MOVFF  01,A55
078E:  MOVLW  04
0790:  MOVLB  A
0792:  ADDWF  x55,F
0794:  MOVLW  00
0796:  ADDWFC x56,F
0798:  MOVFF  A55,FE9
079C:  MOVLW  04
079E:  ADDWF  x56,W
07A0:  MOVWF  FEA
07A2:  MOVLW  40
07A4:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
07A6:  MOVLB  A
07A8:  MOVF   x51,W
07AA:  SUBLW  06
07AC:  BNZ   07B2
07AE:  MOVLW  0E
07B0:  MOVWF  x51
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
07B2:  CLRF   03
07B4:  MOVF   x4E,W
07B6:  MOVLB  0
07B8:  RCALL  00F6
07BA:  SUBLW  01
07BC:  BZ    07C4
07BE:  MOVLB  A
07C0:  BSF    x51.4
07C2:  MOVLB  0
....................           
....................          UEP(en) = new_uep; 
07C4:  CLRF   03
07C6:  MOVLB  A
07C8:  MOVF   x4E,W
07CA:  ADDLW  4C
07CC:  MOVWF  FE9
07CE:  MOVLW  0F
07D0:  ADDWFC 03,W
07D2:  MOVWF  FEA
07D4:  MOVFF  A51,FEF
....................       } 
07D8:  INCF   x4E,F
07DA:  BRA    0620
07DC:  MOVLB  0
....................    } 
.................... } 
07DE:  GOTO   0886 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
032C:  CLRF   03
032E:  MOVLB  A
0330:  MOVF   x56,W
0332:  ADDLW  4C
0334:  MOVWF  FE9
0336:  MOVLW  0F
0338:  ADDWFC 03,W
033A:  MOVWF  FEA
033C:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
033E:  MOVFF  A56,A57
0342:  MOVLB  0
0344:  RCALL  02BC
0346:  MOVF   01,F
0348:  BZ    039A
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
034A:  MOVLB  A
034C:  CLRF   x5D
034E:  MOVFF  A56,A5C
0352:  CLRF   x5F
0354:  MOVLW  08
0356:  MOVWF  x5E
0358:  MOVLB  0
035A:  RCALL  030A
035C:  MOVLB  A
035E:  MOVFF  01,FE9
0362:  MOVLW  04
0364:  ADDWF  02,W
0366:  MOVWF  FEA
0368:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
036A:  CLRF   x5D
036C:  MOVFF  A56,A5C
0370:  CLRF   x5F
0372:  MOVLW  08
0374:  MOVWF  x5E
0376:  MOVLB  0
0378:  RCALL  030A
037A:  MOVFF  02,A58
037E:  MOVFF  01,A57
0382:  MOVLW  04
0384:  MOVLB  A
0386:  ADDWF  x57,F
0388:  MOVLW  00
038A:  ADDWFC x58,F
038C:  MOVFF  A57,FE9
0390:  MOVLW  04
0392:  ADDWF  x58,W
0394:  MOVWF  FEA
0396:  CLRF   FEF
0398:  MOVLB  0
....................    } 
.................... } 
039A:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    unsigned int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
039C:  MOVLW  01
039E:  MOVLB  A
03A0:  MOVWF  x55
03A2:  MOVF   x55,W
03A4:  SUBLW  0F
03A6:  BNC   03B6
....................       usb_disable_endpoint(i); 
03A8:  MOVFF  A55,A56
03AC:  MOVLB  0
03AE:  RCALL  032C
03B0:  MOVLB  A
03B2:  INCF   x55,F
03B4:  BRA    03A2
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
03B6:  MOVLB  0
03B8:  RETURN 0
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
0466:  BCF    F62.3
.................... } 
0468:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    unsigned int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
1140:  BCF    FA1.4
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
1142:  MOVF   22,F
1144:  BNZ   1148
1146:  BRA    11FA
....................    if (UIR)  
1148:  MOVF   F62,F
114A:  BZ    11FA
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
114C:  BTFSS  F62.2
114E:  BRA    1160
1150:  MOVLB  F
1152:  BTFSC  x5C.2
1154:  BRA    115A
1156:  MOVLB  0
1158:  BRA    1160
115A:  MOVLB  0
115C:  GOTO   026A
....................  
....................       if (UCON_SUSPND) return; 
1160:  BTFSS  F65.1
1162:  BRA    1166
1164:  BRA    11FA
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
1166:  BTFSS  F62.5
1168:  BRA    117A
116A:  MOVLB  F
116C:  BTFSC  x5C.5
116E:  BRA    1174
1170:  MOVLB  0
1172:  BRA    117A
1174:  MOVLB  0
1176:  GOTO   029E
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
117A:  BTFSS  F62.1
117C:  BRA    118E
117E:  MOVLB  F
1180:  BTFSC  x5C.1
1182:  BRA    1188
1184:  MOVLB  0
1186:  BRA    118E
1188:  MOVLB  0
118A:  GOTO   02B4
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
118E:  BTFSS  F62.0
1190:  BRA    11A2
1192:  MOVLB  F
1194:  BTFSC  x5C.0
1196:  BRA    119C
1198:  MOVLB  0
119A:  BRA    11A2
119C:  MOVLB  0
119E:  GOTO   046A
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
11A2:  BTFSS  F62.4
11A4:  BRA    11B6
11A6:  MOVLB  F
11A8:  BTFSC  x5C.4
11AA:  BRA    11B0
11AC:  MOVLB  0
11AE:  BRA    11B6
11B0:  MOVLB  0
11B2:  GOTO   04A0
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
11B6:  BTFSS  F62.6
11B8:  BRA    11CA
11BA:  MOVLB  F
11BC:  BTFSC  x5C.6
11BE:  BRA    11C4
11C0:  MOVLB  0
11C2:  BRA    11CA
11C4:  MOVLB  0
11C6:  GOTO   04AE
....................  
....................       TRNAttempts = 0; 
11CA:  MOVLB  A
11CC:  CLRF   x4A
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
11CE:  BTFSS  F62.3
11D0:  BRA    11EC
11D2:  MOVLB  F
11D4:  BTFSC  x5C.3
11D6:  BRA    11DC
11D8:  MOVLB  A
11DA:  BRA    11EC
....................          { 
....................             USTATCopy = U1STAT; 
11DC:  MOVFF  F64,21
....................             usb_clear_trn(); 
11E0:  MOVLB  0
11E2:  CALL   0466
....................             usb_isr_tok_dne(); 
11E6:  BRA    1048
....................          } 
....................          else 
11E8:  BRA    11EE
11EA:  MOVLB  A
....................             break; 
11EC:  BRA    11F8
....................       } while (TRNAttempts++ < 4); 
11EE:  MOVLB  A
11F0:  MOVF   x4A,W
11F2:  INCF   x4A,F
11F4:  SUBLW  03
11F6:  BC    11CE
11F8:  MOVLB  0
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
11FA:  GOTO   00A8
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
04AE:  BCF    F62.6
.................... } 
04B0:  GOTO   11CA (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
046A:  CLRF   F63
....................    UIR = 0; 
046C:  CLRF   F62
....................    UEIE = 0x9F; 
046E:  MOVLW  9F
0470:  MOVLB  F
0472:  MOVWF  x5D
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
0474:  MOVLW  3D
0476:  MOVWF  x5C
....................  
....................    UADDR = 0; 
0478:  CLRF   x5E
....................  
....................    usb_disable_endpoints(); 
047A:  MOVLB  0
047C:  RCALL  039C
....................     
....................    usb_token_reset(); 
047E:  RCALL  0436
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
0480:  MOVLW  16
0482:  MOVLB  F
0484:  MOVWF  x4C
....................  
....................    while (UIR_TRN)  
....................    { 
0486:  BTFSS  F62.3
0488:  BRA    0492
....................       usb_clear_trn(); 
048A:  MOVLB  0
048C:  RCALL  0466
....................    } 
048E:  MOVLB  F
0490:  BRA    0486
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
0492:  BCF    F65.4
....................  
....................    usb_init_ep0_setup(); 
0494:  MOVLB  0
0496:  RCALL  027E
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
0498:  MOVLW  03
049A:  MOVWF  22
.................... } 
049C:  GOTO   11A2 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
027E:  MOVLW  40
0280:  MOVLB  4
0282:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
0284:  MOVLW  04
0286:  MOVWF  x03
0288:  MOVLW  18
028A:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
028C:  MOVLW  88
028E:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
0290:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
0292:  MOVLW  04
0294:  MOVWF  x07
0296:  MOVLW  58
0298:  MOVWF  x06
.................... } 
029A:  MOVLB  0
029C:  RETURN 0
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
02B4:  CLRF   F63
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
02B6:  BCF    F62.1
.................... } 
02B8:  GOTO   118E (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
04A0:  MOVLB  F
04A2:  BSF    x5C.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
04A4:  BCF    F62.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
04A6:  BSF    F65.1
.................... } 
04A8:  MOVLB  0
04AA:  GOTO   11B6 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
026A:  BCF    F65.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
026C:  MOVLB  F
026E:  BCF    x5C.2
....................     
....................    while(UIR_ACTV) 
....................    { 
0270:  BTFSS  F62.2
0272:  BRA    0278
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
0274:  BCF    F62.2
....................    } 
0276:  BRA    0270
.................... } 
0278:  MOVLB  0
027A:  GOTO   1160 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
029E:  MOVLB  F
02A0:  BTFSS  x4C.0
02A2:  BRA    02AC
....................    { 
....................       usb_init_ep0_setup(); 
02A4:  MOVLB  0
02A6:  RCALL  027E
....................       bit_clear(UEP(0), 0); 
02A8:  MOVLB  F
02AA:  BCF    x4C.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
02AC:  BCF    F62.5
.................... } 
02AE:  MOVLB  0
02B0:  GOTO   117A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
04B4:  MOVFF  A50,23
04B8:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
0ADC:  MOVLW  FE
0ADE:  MOVWF  23
0AE0:  RETURN 0
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
04BA:  SETF   23
04BC:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
1048:  RRCF   21,W
104A:  MOVLB  A
104C:  MOVWF  x4B
104E:  RRCF   x4B,F
1050:  RRCF   x4B,F
1052:  MOVLW  1F
1054:  ANDWF  x4B,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
1056:  MOVF   21,F
1058:  BNZ   10F6
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
105A:  MOVLB  4
105C:  MOVF   x00,W
105E:  ANDLW  3C
1060:  MOVLB  A
1062:  MOVWF  x4C
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
1064:  MOVLW  43
1066:  MOVLB  4
1068:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
106A:  MOVLB  A
106C:  MOVF   x4C,W
106E:  SUBLW  34
1070:  BNZ   10BC
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
1072:  MOVLB  4
1074:  MOVF   x04,W
1076:  ANDLW  80
1078:  BZ    107C
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
107A:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
107C:  MOVLB  0
107E:  BRA    0B90
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
1080:  BCF    F65.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
1082:  INCFSZ 23,W
1084:  BRA    1094
....................             usb_flush_out(0, USB_DTS_STALL); 
1086:  MOVLB  A
1088:  CLRF   x4E
108A:  MOVLW  03
108C:  MOVWF  x4F
108E:  MOVLB  0
1090:  RCALL  0BC2
....................          else  
1092:  BRA    10B8
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
1094:  MOVLB  A
1096:  CLRF   x4E
1098:  MOVLW  02
109A:  MOVWF  x4F
109C:  MOVLB  0
109E:  RCALL  0BC2
....................             if (__setup_0_tx_size != 0xFE) 
10A0:  MOVF   23,W
10A2:  SUBLW  FE
10A4:  BZ    10B8
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
10A6:  MOVLB  A
10A8:  CLRF   x56
10AA:  CLRF   x58
10AC:  MOVFF  23,A57
10B0:  MOVLW  04
10B2:  MOVWF  x59
10B4:  MOVLB  0
10B6:  RCALL  0D14
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
10B8:  BRA    10F2
10BA:  MOVLB  A
10BC:  MOVF   x4C,W
10BE:  SUBLW  04
10C0:  BNZ   10F4
....................       { 
....................          usb_isr_tok_out_dne(0); 
10C2:  CLRF   x4D
10C4:  MOVLB  0
10C6:  RCALL  0F06
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
10C8:  MOVLB  A
10CA:  CLRF   x4E
10CC:  MOVLW  02
10CE:  MOVWF  x4F
10D0:  MOVLB  0
10D2:  RCALL  0BC2
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
10D4:  MOVF   23,W
10D6:  SUBLW  FE
10D8:  BZ    10F2
10DA:  INCFSZ 23,W
10DC:  BRA    10E0
10DE:  BRA    10F2
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
10E0:  MOVLB  A
10E2:  CLRF   x56
10E4:  CLRF   x58
10E6:  MOVFF  23,A57
10EA:  MOVLW  01
10EC:  MOVWF  x59
10EE:  MOVLB  0
10F0:  RCALL  0D14
....................          } 
....................       } 
....................       else 
10F2:  MOVLB  A
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
10F4:  BRA    113A
10F6:  MOVF   21,W
10F8:  SUBLW  04
10FA:  BNZ   1120
....................    {    
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
10FC:  SETF   23
....................       usb_isr_tok_in_dne(0); 
10FE:  CLRF   x4D
1100:  MOVLB  0
1102:  RCALL  1016
....................       if (__setup_0_tx_size!=0xFF) 
1104:  INCFSZ 23,W
1106:  BRA    110A
1108:  BRA    111C
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
110A:  MOVLB  A
110C:  CLRF   x56
110E:  CLRF   x58
1110:  MOVFF  23,A57
1114:  MOVLW  02
1116:  MOVWF  x59
1118:  MOVLB  0
111A:  RCALL  0D14
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
111C:  BRA    1138
111E:  MOVLB  A
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
1120:  BTFSC  21.2
1122:  BRA    1130
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
1124:  MOVFF  A4B,A4D
1128:  MOVLB  0
112A:  RCALL  0F06
....................       } 
....................       else  
112C:  BRA    1138
112E:  MOVLB  A
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
1130:  MOVFF  A4B,A4D
1134:  MOVLB  0
1136:  RCALL  1016
1138:  MOVLB  A
....................       } 
....................    } 
.................... } 
113A:  MOVLB  0
113C:  GOTO   11E8 (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
0436:  CLRF   28
0438:  CLRF   27
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
043A:  MOVLB  A
043C:  CLRF   x4B
043E:  MOVF   x4B,W
0440:  SUBLW  01
0442:  BNC   0458
....................       USB_Interface[i] = 0;   //reset each interface to default 
0444:  CLRF   03
0446:  MOVF   x4B,W
0448:  ADDLW  29
044A:  MOVWF  FE9
044C:  MOVLW  00
044E:  ADDWFC 03,W
0450:  MOVWF  FEA
0452:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
0454:  INCF   x4B,F
0456:  BRA    043E
....................    usb_cdc_init(); 
0458:  MOVLB  0
045A:  RCALL  03BA
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
045C:  CLRF   1B
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
045E:  MOVLW  01
0460:  MOVWF  1C
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
0462:  CLRF   1A
.................... } 
0464:  RETURN 0
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
02BC:  MOVLB  A
02BE:  BCF    x58.0
02C0:  BTFSC  x57.7
02C2:  BSF    x58.0
....................     
....................    endpoint &= 0x7F; 
02C4:  BCF    x57.7
....................     
....................    if (endpoint > 16) 
02C6:  MOVF   x57,W
02C8:  SUBLW  10
02CA:  BC    02D2
....................       return(FALSE); 
02CC:  MOVLW  00
02CE:  MOVWF  01
02D0:  BRA    0306
....................     
....................    if (direction) { //IN 
02D2:  BTFSS  x58.0
02D4:  BRA    02F0
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
02D6:  CLRF   03
02D8:  MOVF   x57,W
02DA:  MOVLB  0
02DC:  RCALL  00F6
02DE:  SUBLW  FF
02E0:  BNZ   02E6
02E2:  MOVLW  00
02E4:  BRA    02E8
02E6:  MOVLW  01
02E8:  MOVWF  01
02EA:  MOVLB  A
02EC:  BRA    0306
....................    } 
....................    else {   //OUT 
02EE:  BRA    0306
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
02F0:  CLRF   03
02F2:  MOVF   x57,W
02F4:  MOVLB  0
02F6:  RCALL  0116
02F8:  SUBLW  FF
02FA:  BNZ   0300
02FC:  MOVLW  00
02FE:  BRA    0302
0300:  MOVLW  01
0302:  MOVWF  01
0304:  MOVLB  A
....................    } 
.................... } 
0306:  MOVLB  0
0308:  RETURN 0
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
1016:  MOVLB  A
1018:  MOVF   x4D,F
101A:  BNZ   1038
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
101C:  DECFSZ 1A,W
101E:  BRA    102A
1020:  MOVLB  0
1022:  CALL   04BE
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
1026:  BRA    1034
1028:  MOVLB  A
102A:  MOVF   1A,W
102C:  SUBLW  02
102E:  BNZ   1036
1030:  MOVLB  0
1032:  BRA    0F3E
1034:  MOVLB  A
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
1036:  BRA    1044
1038:  MOVF   x4D,W
103A:  SUBLW  02
103C:  BNZ   1044
....................       usb_isr_tok_in_cdc_data_dne(); 
103E:  MOVLB  0
1040:  BRA    1010
1042:  MOVLB  A
....................   } 
....................   #endif 
.................... } 
1044:  MOVLB  0
1046:  RETURN 0
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
0F06:  MOVLB  A
0F08:  MOVF   x4D,F
0F0A:  BNZ   0F14
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
0F0C:  MOVLB  0
0F0E:  BRA    0E34
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
0F10:  BRA    0F1E
0F12:  MOVLB  A
0F14:  MOVF   x4D,W
0F16:  SUBLW  02
0F18:  BNZ   0F20
....................       usb_isr_tok_out_cdc_data_dne(); 
0F1A:  MOVLB  0
0F1C:  BRA    0EEA
0F1E:  MOVLB  A
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
0F20:  MOVLB  0
0F22:  RETURN 0
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
0B90:  CLRF   1A
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0B92:  MOVLB  4
0B94:  MOVF   x18,W
0B96:  ANDLW  7F
0B98:  XORLW  00
0B9A:  MOVLB  0
0B9C:  BZ    0BAC
0B9E:  XORLW  01
0BA0:  BZ    0BB0
0BA2:  XORLW  03
0BA4:  BZ    0BB4
0BA6:  XORLW  23
0BA8:  BZ    0BB8
0BAA:  BRA    0BBC
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
0BAC:  BRA    07E2
....................          break; 
0BAE:  BRA    0BBE
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0BB0:  BRA    0898
....................          break; 
0BB2:  BRA    0BBE
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0BB4:  BRA    0A74
....................          break; 
0BB6:  BRA    0BBE
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................         #else 
....................          usb_isr_tkn_cdc(); 
0BB8:  BRA    0AE2
....................         #endif 
....................          break; 
0BBA:  BRA    0BBE
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0BBC:  RCALL  04BA
....................          break; 
....................    } 
.................... } 
0BBE:  GOTO   1080 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
07E2:  MOVLB  4
07E4:  MOVF   x19,W
07E6:  XORLW  00
07E8:  MOVLB  0
07EA:  BZ    0806
07EC:  XORLW  01
07EE:  BZ    081A
07F0:  XORLW  02
07F2:  BZ    0834
07F4:  XORLW  06
07F6:  BZ    084C
07F8:  XORLW  03
07FA:  BZ    085E
07FC:  XORLW  0E
07FE:  BZ    0862
0800:  XORLW  01
0802:  BZ    0872
0804:  BRA    0892
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0806:  MOVFF  1C,458
....................             usb_ep0_tx_buffer[1]=0; 
080A:  MOVLB  4
080C:  CLRF   x59
....................             usb_request_send_response(2); 
080E:  MOVLW  02
0810:  MOVLB  A
0812:  MOVWF  x50
0814:  MOVLB  0
0816:  RCALL  04B4
....................             break; 
0818:  BRA    0894
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
081A:  MOVLB  4
081C:  DECFSZ x1A,W
081E:  BRA    082E
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
0820:  MOVLW  01
0822:  ANDWF  1C,F
....................                usb_put_0len_0(); 
0824:  MOVLB  A
0826:  CLRF   x50
0828:  MOVLB  0
082A:  RCALL  04B4
....................             } 
....................             else 
082C:  BRA    0832
....................                usb_request_stall(); 
082E:  MOVLB  0
0830:  RCALL  04BA
....................             break; 
0832:  BRA    0894
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0834:  MOVLB  4
0836:  DECFSZ x1A,W
0838:  BRA    0846
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
083A:  BSF    1C.1
....................                usb_put_0len_0(); 
083C:  MOVLB  A
083E:  CLRF   x50
0840:  MOVLB  0
0842:  RCALL  04B4
....................             } 
....................             else 
0844:  BRA    084A
....................                usb_request_stall(); 
0846:  MOVLB  0
0848:  RCALL  04BA
....................             break; 
084A:  BRA    0894
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
084C:  MOVLW  02
084E:  MOVWF  1A
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
0850:  MOVFF  41A,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
0854:  MOVLB  A
0856:  CLRF   x50
0858:  MOVLB  0
085A:  RCALL  04B4
....................             break; 
085C:  BRA    0894
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
085E:  BRA    0546
....................             break; 
0860:  BRA    0894
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
0862:  MOVFF  1B,458
....................             usb_request_send_response(1); 
0866:  MOVLW  01
0868:  MOVLB  A
086A:  MOVWF  x50
086C:  MOVLB  0
086E:  RCALL  04B4
....................             break; 
0870:  BRA    0894
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
0872:  MOVLB  4
0874:  MOVF   x1A,W
0876:  SUBLW  01
0878:  BNC   088E
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
087A:  MOVFF  41A,1B
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
087E:  MOVFF  41A,A4D
0882:  MOVLB  0
0884:  BRA    05FE
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
0886:  MOVLB  A
0888:  CLRF   x50
088A:  MOVLB  0
088C:  RCALL  04B4
....................             } 
....................             break; 
088E:  MOVLB  0
0890:  BRA    0894
....................  
....................       default: 
....................             usb_request_stall(); 
0892:  RCALL  04BA
....................             break; 
....................    } 
.................... } 
0894:  GOTO   0BBE (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
0898:  MOVFF  1B,A4D
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
089C:  MOVLB  4
089E:  MOVF   x19,W
08A0:  XORLW  00
08A2:  MOVLB  0
08A4:  BZ    08B0
08A6:  XORLW  0A
08A8:  BZ    08C2
08AA:  XORLW  01
08AC:  BZ    0904
08AE:  BRA    092E
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
08B0:  MOVLB  4
08B2:  CLRF   x58
....................             usb_ep0_tx_buffer[1]=0; 
08B4:  CLRF   x59
....................             usb_request_send_response(2); 
08B6:  MOVLW  02
08B8:  MOVLB  A
08BA:  MOVWF  x50
08BC:  MOVLB  0
08BE:  RCALL  04B4
....................             break; 
08C0:  BRA    0930
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
08C2:  MOVLB  A
08C4:  MOVF   x4D,F
08C6:  BZ    08FE
08C8:  MOVLW  01
08CA:  SUBWF  x4D,W
08CC:  CLRF   03
08CE:  MOVLB  0
08D0:  RCALL  01EA
08D2:  MOVWF  01
08D4:  MOVLB  4
08D6:  SUBWF  x1C,W
08D8:  BTFSS  FD8.0
08DA:  BRA    08E0
08DC:  MOVLB  A
08DE:  BRA    08FE
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
08E0:  CLRF   03
08E2:  MOVF   x1C,W
08E4:  ADDLW  29
08E6:  MOVWF  FE9
08E8:  MOVLW  00
08EA:  ADDWFC 03,W
08EC:  MOVWF  FEA
08EE:  MOVFF  FEF,458
....................                usb_request_send_response(1);; //send byte back 
08F2:  MOVLW  01
08F4:  MOVLB  A
08F6:  MOVWF  x50
08F8:  MOVLB  0
08FA:  RCALL  04B4
....................             } 
....................             else 
08FC:  BRA    0902
....................                usb_request_stall(); 
08FE:  MOVLB  0
0900:  RCALL  04BA
....................             break; 
0902:  BRA    0930
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
0904:  MOVLB  A
0906:  MOVF   x4D,F
0908:  BZ    0928
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
090A:  CLRF   03
090C:  MOVLB  4
090E:  MOVF   x1C,W
0910:  ADDLW  29
0912:  MOVWF  FE9
0914:  MOVLW  00
0916:  ADDWFC 03,W
0918:  MOVWF  FEA
091A:  MOVFF  41A,FEF
....................                usb_put_0len_0(); 
091E:  MOVLB  A
0920:  CLRF   x50
0922:  MOVLB  0
0924:  RCALL  04B4
....................             } 
....................             else 
0926:  BRA    092C
....................                usb_request_stall(); 
0928:  MOVLB  0
092A:  RCALL  04BA
....................             break; 
092C:  BRA    0930
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
092E:  RCALL  04BA
....................             break; 
....................    } 
.................... } 
0930:  GOTO   0BBE (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
0A74:  MOVFF  41C,A57
0A78:  RCALL  02BC
0A7A:  MOVF   01,F
0A7C:  BZ    0AD8
....................       switch(usb_ep0_rx_buffer[1]) { 
0A7E:  MOVLB  4
0A80:  MOVF   x19,W
0A82:  XORLW  01
0A84:  MOVLB  0
0A86:  BZ    0A92
0A88:  XORLW  02
0A8A:  BZ    0AA2
0A8C:  XORLW  03
0A8E:  BZ    0AB2
0A90:  BRA    0AD6
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
0A92:  MOVFF  41C,A4D
0A96:  BRA    0934
....................                usb_put_0len_0(); 
0A98:  MOVLB  A
0A9A:  CLRF   x50
0A9C:  MOVLB  0
0A9E:  RCALL  04B4
....................                break; 
0AA0:  BRA    0AD8
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
0AA2:  MOVFF  41C,A4D
0AA6:  BRA    0998
....................                      usb_put_0len_0(); 
0AA8:  MOVLB  A
0AAA:  CLRF   x50
0AAC:  MOVLB  0
0AAE:  RCALL  04B4
....................                      break; 
0AB0:  BRA    0AD8
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
0AB2:  MOVLB  4
0AB4:  CLRF   x58
....................                usb_ep0_tx_buffer[1]=0; 
0AB6:  CLRF   x59
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0AB8:  MOVFF  41C,A4D
0ABC:  MOVLB  0
0ABE:  BRA    09FE
0AC0:  MOVF   01,F
0AC2:  BZ    0ACA
....................                   usb_ep0_tx_buffer[0]=1; 
0AC4:  MOVLW  01
0AC6:  MOVLB  4
0AC8:  MOVWF  x58
....................                } 
....................                usb_request_send_response(2); 
0ACA:  MOVLW  02
0ACC:  MOVLB  A
0ACE:  MOVWF  x50
0AD0:  MOVLB  0
0AD2:  RCALL  04B4
....................                break; 
0AD4:  BRA    0AD8
....................  
....................          default: 
....................             usb_request_stall(); 
0AD6:  RCALL  04BA
....................             break; 
....................       } 
....................    } 
.................... } 
0AD8:  GOTO   0BBE (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
0546:  CLRF   26
0548:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
054A:  CLRF   1D
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
054C:  MOVLB  4
054E:  MOVF   x1B,W
0550:  XORLW  01
0552:  MOVLB  0
0554:  BZ    0564
0556:  XORLW  03
0558:  BZ    0570
055A:  XORLW  01
055C:  BZ    0578
055E:  XORLW  22
0560:  BZ    05A6
0562:  BRA    05D8
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
0564:  CLRF   28
0566:  MOVLW  12
0568:  MOVWF  27
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
056A:  MOVLW  03
056C:  MOVWF  1D
....................             break; 
056E:  BRA    05DC
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
0570:  CLRF   28
0572:  MOVLW  43
0574:  MOVWF  27
....................             break; 
0576:  BRA    05DC
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0578:  MOVLW  02
057A:  MOVWF  1D
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
057C:  CLRF   03
057E:  MOVLB  4
0580:  MOVF   x1A,W
0582:  ADDLW  1E
0584:  MOVWF  FE9
0586:  MOVLW  00
0588:  ADDWFC 03,W
058A:  MOVWF  FEA
058C:  CLRF   26
058E:  MOVFF  FEF,25
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
0592:  MOVFF  26,03
0596:  MOVF   25,W
0598:  MOVLB  0
059A:  RCALL  0236
059C:  CLRF   03
059E:  MOVWF  27
05A0:  MOVFF  03,28
....................             break; 
05A4:  BRA    05DC
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
05A6:  CLRF   03
05A8:  MOVLB  4
05AA:  MOVF   x1A,W
05AC:  MOVLB  0
05AE:  RCALL  01FC
05B0:  CLRF   03
05B2:  MOVWF  25
05B4:  MOVFF  03,26
....................             if (usb_getdesc_ptr!=0xFF) { 
05B8:  INCFSZ 25,W
05BA:  BRA    05C0
05BC:  MOVF   26,F
05BE:  BZ    05D4
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
05C0:  MOVFF  26,03
05C4:  MOVF   25,W
05C6:  RCALL  0196
05C8:  CLRF   03
05CA:  MOVWF  27
05CC:  MOVFF  03,28
....................                break; 
05D0:  BRA    05DC
....................             } 
....................             else { 
05D2:  BRA    05D8
....................                usb_request_stall(); 
05D4:  RCALL  04BA
....................                return; 
05D6:  BRA    05FA
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
05D8:  RCALL  04BA
....................             return; 
05DA:  BRA    05FA
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
05DC:  MOVLB  4
05DE:  MOVF   x1F,F
05E0:  BNZ   05F2
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
05E2:  MOVF   28,F
05E4:  BNZ   05EC
05E6:  MOVF   27,W
05E8:  SUBWF  x1E,W
05EA:  BC    05F2
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
05EC:  CLRF   28
05EE:  MOVFF  41E,27
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
05F2:  MOVLW  01
05F4:  MOVWF  1A
....................    usb_copy_desc_seg_to_ep(); 
05F6:  MOVLB  0
05F8:  RCALL  04BE
.................... } 
05FA:  GOTO   0894 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
0F3E:  CLRF   1B
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0F40:  CLRF   1A
....................    usb_set_address(USB_address_pending); 
0F42:  MOVFF  24,A4E
0F46:  BRA    0F24
....................    #endif 
.................... } 
0F48:  GOTO   1034 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
04BE:  MOVLB  A
04C0:  CLRF   x4E
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
04C2:  MOVF   27,W
04C4:  IORWF  28,W
04C6:  BZ    052E
04C8:  MOVF   x4E,W
04CA:  SUBLW  3F
04CC:  BNC   052E
....................       switch(USB_stack_status.getdesc_type) { 
04CE:  MOVF   1D,W
04D0:  XORLW  00
04D2:  MOVLB  0
04D4:  BZ    04E0
04D6:  XORLW  02
04D8:  BZ    04EE
04DA:  XORLW  01
04DC:  BZ    04FC
04DE:  BRA    0508
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
04E0:  MOVFF  26,03
04E4:  MOVF   25,W
04E6:  RCALL  0196
04E8:  MOVFF  FE8,A4F
....................             break; 
04EC:  BRA    0508
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
04EE:  MOVFF  26,03
04F2:  MOVF   25,W
04F4:  RCALL  0236
04F6:  MOVFF  FE8,A4F
....................             break; 
04FA:  BRA    0508
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
04FC:  MOVFF  26,03
0500:  MOVF   25,W
0502:  RCALL  0214
0504:  MOVFF  FE8,A4F
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
....................       } 
....................       usb_getdesc_ptr++; 
0508:  INCF   25,F
050A:  BTFSC  FD8.2
050C:  INCF   26,F
....................       usb_getdesc_len--; 
050E:  MOVF   27,W
0510:  BTFSC  FD8.2
0512:  DECF   28,F
0514:  DECF   27,F
....................       usb_ep0_tx_buffer[i++]=c; 
0516:  MOVLB  A
0518:  MOVF   x4E,W
051A:  INCF   x4E,F
051C:  ADDLW  58
051E:  MOVWF  FE9
0520:  MOVLW  04
0522:  MOVWF  FEA
0524:  BTFSC  FD8.0
0526:  INCF   FEA,F
0528:  MOVFF  A4F,FEF
....................    } 
052C:  BRA    04C2
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
052E:  MOVF   27,W
0530:  IORWF  28,W
0532:  BNZ   053C
0534:  MOVF   x4E,W
0536:  SUBLW  40
0538:  BZ    053C
....................          USB_stack_status.dev_req = NONE; 
053A:  CLRF   1A
....................    } 
....................  
....................    usb_request_send_response(i); 
053C:  MOVFF  A4E,A50
0540:  MOVLB  0
0542:  RCALL  04B4
.................... } 
0544:  RETURN 0
....................  
.................... #ENDIF 
....................  
....................  
.................... /* 
....................    Generally, you cannot use CDC on a slow speed USB device.  The primary 
....................    reason for this is that CDC uses bulk transfer endpoints, and bulk 
....................    transfer endpoints is not supported on slow speed devices per the USB 
....................    specification.  You may be able to find unofficial drivers for your 
....................    operating system that allows CDD to operate on a slow speed device, 
....................    but CCS doesn't have any that they can recommend to you. 
.................... */ 
.................... #if (USB_USE_FULL_SPEED==0) 
....................    #error CDC and slow speed is not supported.  See comments above. 
.................... #endif 
....................  
.................... struct { 
....................         unsigned int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         unsigned int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         unsigned int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         unsigned int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } __attribute__((__packed__)) usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... unsigned int16 usb_cdc_break; 
....................  
.................... unsigned int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... unsigned int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE-1]; 
.................... #define usb_cdc_put_buffer_free()  usb_tbe(USB_CDC_DATA_IN_ENDPOINT) 
.................... #if sizeof(usb_cdc_put_buffer)>=0x100 
....................  #error This is not supported.  That is because ISR may change this 16bit value while your non-ISR code is reading this. 
....................  unsigned int16 usb_cdc_put_buffer_nextin; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  unsigned int8 usb_cdc_put_buffer_nextin; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    unsigned int16 len; 
....................    unsigned int16 index; 
....................   #else 
....................    unsigned int8 len; 
....................    unsigned int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... #if defined(__PIC__) 
....................  #define usb_cdc_get_buffer_status_buffer usb_ep2_rx_buffer 
.................... #else 
....................  unsigned int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    unsigned int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state; 
....................  
.................... #if defined(__PCH__) 
....................  #byte INTCON=0xFF2 
....................  #bit INT_GIE=INTCON.7 
.................... #else 
....................  #word SR=0x42 
.................... #endif 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
0E34:  MOVF   x81,W
0E36:  XORLW  01
0E38:  BZ    0E40
0E3A:  XORLW  03
0E3C:  BZ    0E68
0E3E:  BRA    0E90
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
0E40:  CLRF   FEA
0E42:  MOVLW  34
0E44:  MOVWF  FE9
0E46:  MOVLW  04
0E48:  MOVWF  FE2
0E4A:  MOVLW  18
0E4C:  MOVWF  FE1
0E4E:  MOVLW  08
0E50:  MOVWF  01
0E52:  MOVFF  FE6,FEE
0E56:  DECFSZ 01,F
0E58:  BRA    0E52
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
....................          usb_request_get_data(); 
....................         #else 
....................          usb_put_0len_0(); 
0E5A:  MOVLB  A
0E5C:  CLRF   x50
0E5E:  MOVLB  0
0E60:  CALL   04B4
....................          __usb_cdc_state=0; 
0E64:  CLRF   x81
....................         #endif 
....................          break; 
0E66:  BRA    0E92
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................          break; 
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
0E68:  CLRF   FEA
0E6A:  MOVLW  2B
0E6C:  MOVWF  FE9
0E6E:  MOVLW  04
0E70:  MOVWF  FE2
0E72:  MOVLW  18
0E74:  MOVWF  FE1
0E76:  MOVLW  07
0E78:  MOVWF  01
0E7A:  MOVFF  FE6,FEE
0E7E:  DECFSZ 01,F
0E80:  BRA    0E7A
....................          __usb_cdc_state=0; 
0E82:  CLRF   x81
....................          usb_put_0len_0(); 
0E84:  MOVLB  A
0E86:  CLRF   x50
0E88:  MOVLB  0
0E8A:  CALL   04B4
....................          break; 
0E8E:  BRA    0E92
....................  
....................       default: 
....................          __usb_cdc_state=0; 
0E90:  CLRF   x81
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................          break; 
....................    } 
.................... } 
0E92:  GOTO   0F10 (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
0AE2:  MOVLB  4
0AE4:  DECFSZ x1C,W
0AE6:  BRA    0AEA
0AE8:  BRA    0AEE
0AEA:  MOVF   x1C,F
0AEC:  BNZ   0B8A
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
0AEE:  MOVF   x19,W
0AF0:  XORLW  00
0AF2:  MOVLB  0
0AF4:  BZ    0B0C
0AF6:  XORLW  01
0AF8:  BZ    0B14
0AFA:  XORLW  21
0AFC:  BZ    0B36
0AFE:  XORLW  01
0B00:  BZ    0B40
0B02:  XORLW  03
0B04:  BZ    0B66
0B06:  XORLW  01
0B08:  BZ    0B74
0B0A:  BRA    0B86
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
0B0C:  MOVLW  01
0B0E:  MOVWF  x81
....................             usb_request_get_data(); 
0B10:  RCALL  0ADC
....................             break; 
0B12:  BRA    0B88
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
0B14:  MOVLW  04
0B16:  MOVWF  FEA
0B18:  MOVLW  58
0B1A:  MOVWF  FE9
0B1C:  CLRF   FE2
0B1E:  MOVLW  34
0B20:  MOVWF  FE1
0B22:  MOVLW  08
0B24:  MOVWF  01
0B26:  MOVFF  FE6,FEE
0B2A:  DECFSZ 01,F
0B2C:  BRA    0B26
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
0B2E:  MOVFF  41E,A50
0B32:  RCALL  04B4
....................             break; 
0B34:  BRA    0B88
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
0B36:  MOVLW  02
0B38:  MOVWF  x81
....................             usb_cdc_got_set_line_coding=TRUE; 
0B3A:  BSF    x7F.0
....................             usb_request_get_data(); 
0B3C:  RCALL  0ADC
....................             break; 
0B3E:  BRA    0B88
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
0B40:  MOVLW  04
0B42:  MOVWF  FEA
0B44:  MOVLW  58
0B46:  MOVWF  FE9
0B48:  CLRF   FE2
0B4A:  MOVLW  2B
0B4C:  MOVWF  FE1
0B4E:  MOVLW  07
0B50:  MOVWF  01
0B52:  MOVFF  FE6,FEE
0B56:  DECFSZ 01,F
0B58:  BRA    0B52
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
0B5A:  MOVLW  07
0B5C:  MOVLB  A
0B5E:  MOVWF  x50
0B60:  MOVLB  0
0B62:  RCALL  04B4
....................             break; 
0B64:  BRA    0B88
....................  
....................          case 0x22:  //set_control_line_state 
....................             (unsigned int8)usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
0B66:  MOVFF  41A,80
....................             usb_put_0len_0(); 
0B6A:  MOVLB  A
0B6C:  CLRF   x50
0B6E:  MOVLB  0
0B70:  RCALL  04B4
....................             break; 
0B72:  BRA    0B88
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
0B74:  MOVFF  41A,33
0B78:  MOVFF  41B,32
....................             usb_put_0len_0(); 
0B7C:  MOVLB  A
0B7E:  CLRF   x50
0B80:  MOVLB  0
0B82:  RCALL  04B4
....................             break; 
0B84:  BRA    0B88
....................  
....................          default: 
....................             usb_request_stall(); 
0B86:  RCALL  04BA
....................             break; 
0B88:  MOVLB  4
....................       } 
....................    } 
.................... } 
0B8A:  MOVLB  0
0B8C:  GOTO   0BBE (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 2 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
0EEA:  BSF    x7C.0
....................    usb_cdc_get_buffer_status.index=0; 
0EEC:  CLRF   x7E
.................... #if (defined(__PIC__) && __PIC__) 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
0EEE:  MOVLW  02
0EF0:  MOVLB  A
0EF2:  MOVWF  x4E
0EF4:  MOVLB  0
0EF6:  BRA    0E96
0EF8:  MOVFF  01,7D
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
....................    if (!usb_cdc_get_buffer_status.len) 
0EFC:  MOVF   x7D,F
0EFE:  BNZ   0F02
....................    { 
....................       usb_cdc_get_discard(); 
0F00:  RCALL  0EDA
....................    } 
.................... } 
0F02:  GOTO   0F1E (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void)  
.................... { 
....................    usb_cdc_flush_out_buffer(); 
1010:  RCALL  0FEA
.................... } 
1012:  GOTO   1042 (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void)  
.................... { 
....................    if (usb_cdc_put_buffer_nextin != 0) 
0FEA:  MOVF   x7B,F
0FEC:  BZ    100E
....................    { 
....................       if (usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE)) 
0FEE:  MOVLW  02
0FF0:  MOVLB  A
0FF2:  MOVWF  x4E
0FF4:  CLRF   x50
0FF6:  MOVLW  3C
0FF8:  MOVWF  x4F
0FFA:  CLRF   x52
0FFC:  MOVFF  7B,A51
1000:  MOVLW  02
1002:  MOVWF  x53
1004:  MOVLB  0
1006:  RCALL  0F4C
1008:  MOVF   01,F
100A:  BZ    100E
....................       { 
....................          usb_cdc_put_buffer_nextin = 0; 
100C:  CLRF   x7B
....................       } 
....................    } 
.................... } 
100E:  RETURN 0
....................  
.................... void usb_cdc_init(void)  
.................... { 
....................    usb_cdc_line_coding.dwDTERrate = 9600; 
03BA:  MOVLB  A
03BC:  CLRF   x4F
03BE:  CLRF   x4E
03C0:  MOVLW  25
03C2:  MOVWF  x4D
03C4:  MOVLW  80
03C6:  MOVWF  x4C
03C8:  CLRF   FEA
03CA:  MOVLW  2B
03CC:  MOVWF  FE9
03CE:  MOVLW  0A
03D0:  MOVWF  FE2
03D2:  MOVLW  4C
03D4:  MOVWF  FE1
03D6:  MOVLW  02
03D8:  MOVWF  01
03DA:  MOVFF  FE6,FEE
03DE:  DECFSZ 01,F
03E0:  BRA    03DA
03E2:  CLRF   2D
03E4:  CLRF   2E
....................    usb_cdc_line_coding.bCharFormat = 0; 
03E6:  CLRF   x4C
03E8:  CLRF   FEA
03EA:  MOVLW  2F
03EC:  MOVWF  FE9
03EE:  MOVLW  0A
03F0:  MOVWF  FE2
03F2:  MOVLW  4C
03F4:  MOVWF  FE1
03F6:  MOVFF  FE6,FEE
....................    usb_cdc_line_coding.bParityType = 0; 
03FA:  CLRF   x4C
03FC:  CLRF   FEA
03FE:  MOVLW  30
0400:  MOVWF  FE9
0402:  MOVLW  0A
0404:  MOVWF  FE2
0406:  MOVLW  4C
0408:  MOVWF  FE1
040A:  MOVFF  FE6,FEE
....................    usb_cdc_line_coding.bDataBits = 8; 
040E:  MOVLW  08
0410:  MOVWF  x4C
0412:  CLRF   FEA
0414:  MOVLW  31
0416:  MOVWF  FE9
0418:  MOVLW  0A
041A:  MOVWF  FE2
041C:  MOVLW  4C
041E:  MOVWF  FE1
0420:  MOVFF  FE6,FEE
....................    (int8)usb_cdc_carrier = 0; 
0424:  MOVLB  0
0426:  CLRF   x80
....................    usb_cdc_got_set_line_coding = FALSE; 
0428:  BCF    x7F.0
....................    usb_cdc_break = 0; 
042A:  CLRF   33
042C:  CLRF   32
....................    usb_cdc_put_buffer_nextin = 0; 
042E:  CLRF   x7B
....................    usb_cdc_get_buffer_status.got = 0; 
0430:  BCF    x7C.0
....................    __usb_cdc_state = 0; 
0432:  CLRF   x81
.................... } 
0434:  RETURN 0
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int bRxCarrier:1; //State of receiver carrier detection mechanism of device. This signal corresponds to V.24 signal 109 and RS-232 signal DCD. 
....................    unsigned int bTxCarrier:1; //State of transmission carrier. This signal corresponds to V.24 signal 106 and RS-232 signal DSR 
....................    unsigned int bBreak:1;  //State of break detection mechanism of the device. 
....................    unsigned int bRingSignal:1;   //State of ring signal detection of the device.  
....................    unsigned int bFraming:1;   //A framing error has occurred. 
....................    unsigned int bParity:1;    //A parity error has occurred. 
....................    unsigned int bOverRun:1;   //Received data has been discarded due to overrun in the device. 
....................    unsigned int reserved0:1;   //future use 
....................    unsigned int reserved1:8;   //future use 
.................... } cdc_serial_state_t; 
....................  
.................... /* 
....................    Send SERIAL_STATE notification to the host.  This contains DSR, DCD, Ring,  
....................    break signal and more (see cdc_serial_state_t). 
....................    Some of these values are held by the host (meaning it's value only needs 
....................    to be sent on change), but some values are one shot (meaning you continously 
....................    need to send value to host while being held). 
.................... */ 
.................... int1 usb_cdc_serial_state(cdc_serial_state_t state) 
.................... { 
....................   #if __USB_PIC_PERIF__ 
....................    #define CDC_EP1_NOTIFY_BUFFER usb_ep1_tx_buffer 
....................   #else 
....................    unsigned int8 payload[10]; 
....................    #define CDC_EP1_NOTIFY_BUFFER payload 
....................   #endif 
....................  
....................    if (!usb_tbe(USB_CDC_COMM_IN_ENDPOINT)) 
....................       return(FALSE); 
....................  
....................    //bmRequestType 
....................    CDC_EP1_NOTIFY_BUFFER[0] = 0xA1;  //0b10100001 
....................    //bNotification 
....................    CDC_EP1_NOTIFY_BUFFER[1] = 0x20;  //SERIAL_STATE 
....................    //wValue 
....................    CDC_EP1_NOTIFY_BUFFER[2] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[3] = 0; 
....................    //wIndex 
....................    CDC_EP1_NOTIFY_BUFFER[4] = 0; 
....................    CDC_EP1_NOTIFY_BUFFER[5] = 0; 
....................    //wLength 
....................    CDC_EP1_NOTIFY_BUFFER[6] = 2; //sizeof(cdc_serial_state_t) 
....................    CDC_EP1_NOTIFY_BUFFER[7] = 0; 
....................    //data 
....................    CDC_EP1_NOTIFY_BUFFER[8] = (unsigned int8)state; 
....................    CDC_EP1_NOTIFY_BUFFER[9] = (unsigned int16)state >> 8; 
....................  
....................   #if __USB_PIC_PERIF__ 
....................    usb_flush_in(USB_CDC_COMM_IN_ENDPOINT, 10, USB_DTS_TOGGLE); 
....................   #else 
....................    usb_put_packet(USB_CDC_COMM_IN_ENDPOINT, payload, 10, USB_DTS_TOGGLE); 
....................   #endif 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... void usb_cdc_get_discard(void) 
.................... { 
....................    usb_cdc_get_buffer_status.got = FALSE; 
0EDA:  BCF    x7C.0
....................    usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
0EDC:  MOVLW  02
0EDE:  MOVLB  A
0EE0:  MOVWF  x4E
0EE2:  MOVWF  x4F
0EE4:  MOVLB  0
0EE6:  RCALL  0BC2
.................... } 
0EE8:  RETURN 0
....................  
.................... char usb_cdc_getc(void)  
.................... { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit())  
....................    { 
19A6:  BTFSC  x7C.0
19A8:  BRA    19AC
....................      #if defined(USB_ISR_POLLING) 
....................       usb_task(); 
....................      #endif 
....................    } 
19AA:  BRA    19A6
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
19AC:  MOVF   x7E,W
19AE:  INCF   x7E,F
19B0:  ADDLW  A3
19B2:  MOVWF  FE9
19B4:  MOVLW  04
19B6:  MOVWF  FEA
19B8:  BTFSC  FD8.0
19BA:  INCF   FEA,F
19BC:  MOVFF  FEF,2E5
....................  
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len)  
19C0:  MOVF   x7D,W
19C2:  SUBWF  x7E,W
19C4:  BNC   19D6
19C6:  CLRF   19
19C8:  BTFSC  FF2.7
19CA:  BSF    19.7
19CC:  BCF    FF2.7
....................    { 
....................       usb_cdc_get_discard(); 
19CE:  CALL   0EDA
19D2:  BTFSC  19.7
19D4:  BSF    FF2.7
....................    } 
....................  
....................    return(c); 
19D6:  MOVLB  2
19D8:  MOVFF  2E5,01
.................... } 
19DC:  MOVLB  0
19DE:  RETURN 0
....................  
.................... /* 
.................... #if defined(__PCH__) 
.................... static int1 g_Usb_old_gie; 
.................... #else 
.................... static unsigned int16 g_Usb_oldSR; 
.................... #endif 
....................  
.................... void __USB_PAUSE_ISR(void) 
.................... { 
....................  #if defined(__PCH__) 
....................    g_Usb_old_gie = INT_GIE; 
....................    INT_GIE = 0; 
....................  #else 
....................    g_Usb_oldSR = SR; 
....................    SR |= 0xE0; 
....................  #endif 
.................... } 
....................  
.................... void __USB_RESTORE_ISR(void) 
.................... { 
....................   #if defined(__PCH__) 
....................    INT_GIE = g_Usb_old_gie; 
....................   #else 
....................    SR = g_Usb_oldSR; 
....................   #endif 
.................... } 
.................... */ 
....................  
.................... #if defined(__PCH__) 
....................    #define __USB_PAUSE_ISR()  int1 old_gie; old_gie = INT_GIE; INT_GIE = 0 
....................    #define __USB_RESTORE_ISR() INT_GIE = old_gie 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................    #bit SFR_BIT_IPL3=getenv("BIT:IPL3") 
....................    #bit SFR_BIT_NSTDIS=getenv("BIT:NSTDIS") 
....................     
....................    #define __USB_PAUSE_ISR()    \ 
....................       int1 oldIPL3; \ 
....................       int1 oldNSTDIS;   \ 
....................       unsigned int16 oldSR;   \ 
....................       oldNSTDIS = SFR_BIT_NSTDIS; \ 
....................       SFR_BIT_NSTDIS = 0;  \ 
....................       oldSR = SR; \ 
....................       SR |= 0xE0; \ 
....................       oldIPL3 = SFR_BIT_IPL3; \ 
....................       SFR_BIT_IPL3 = 1; \ 
....................       SFR_BIT_NSTDIS = oldNSTDIS 
....................        
....................    #define __USB_RESTORE_ISR()   \ 
....................       oldNSTDIS = SFR_BIT_NSTDIS; \ 
....................       SFR_BIT_NSTDIS = 0;  \ 
....................       SR = oldSR; \ 
....................       SFR_BIT_IPL3 = oldIPL3;  \ 
....................       SFR_BIT_NSTDIS = oldNSTDIS 
.................... #endif 
....................  
....................  
.................... static void _usb_cdc_putc_fast_noflush(char c) 
.................... { 
....................    __USB_PAUSE_ISR(); 
1C86:  MOVLB  2
1C88:  BCF    xE6.0
1C8A:  BTFSC  FF2.7
1C8C:  BSF    xE6.0
1C8E:  BCF    FF2.7
....................  
....................    if (usb_cdc_put_buffer_nextin >= sizeof(usb_cdc_put_buffer)) { 
1C90:  MOVLB  0
1C92:  MOVF   x7B,W
1C94:  SUBLW  3E
1C96:  BC    1C9C
....................       usb_cdc_put_buffer_nextin = sizeof(usb_cdc_put_buffer)-1;  //we just overflowed the buffer! 
1C98:  MOVLW  3E
1C9A:  MOVWF  x7B
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++] = c; 
1C9C:  MOVF   x7B,W
1C9E:  INCF   x7B,F
1CA0:  CLRF   03
1CA2:  ADDLW  3C
1CA4:  MOVWF  FE9
1CA6:  MOVLW  00
1CA8:  ADDWFC 03,W
1CAA:  MOVWF  FEA
1CAC:  MOVFF  2E5,FEF
....................  
....................    __USB_RESTORE_ISR(); 
1CB0:  BCF    FF2.7
1CB2:  MOVLB  2
1CB4:  BTFSC  xE6.0
1CB6:  BSF    FF2.7
.................... } 
1CB8:  MOVLB  0
1CBA:  GOTO   1CC4 (RETURN)
....................  
.................... void usb_cdc_putc_fast(char c) 
.................... { 
....................    _usb_cdc_putc_fast_noflush(c); 
1CBE:  MOVFF  2E4,2E5
1CC2:  BRA    1C86
1CC4:  CLRF   19
1CC6:  BTFSC  FF2.7
1CC8:  BSF    19.7
1CCA:  BCF    FF2.7
....................  
....................   #if defined(USB_ISR_POLLING) 
....................    // if interrupts are disabled, we should clear all activity isrs 
....................    // before we attempt to put any data onto an endpoint. 
....................    if (!usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) 
....................       return; 
....................    usb_task(); 
....................   #endif 
....................    
....................    if (usb_cdc_put_buffer_free())  
1CCC:  MOVLW  02
1CCE:  MOVLB  A
1CD0:  MOVWF  x5B
1CD2:  MOVLB  0
1CD4:  CALL   0CBE
1CD8:  BTFSC  19.7
1CDA:  BSF    FF2.7
1CDC:  MOVF   01,F
1CDE:  BZ    1CF0
1CE0:  CLRF   19
1CE2:  BTFSC  FF2.7
1CE4:  BSF    19.7
1CE6:  BCF    FF2.7
....................    { 
....................       //printf("FL2 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................       usb_cdc_flush_out_buffer(); 
1CE8:  CALL   0FEA
1CEC:  BTFSC  19.7
1CEE:  BSF    FF2.7
....................    } 
....................     
....................    //putc('*'); 
.................... } 
1CF0:  GOTO   1D02 (RETURN)
....................  
.................... void usb_cdc_putc(char c) 
.................... { 
....................    while (!usb_cdc_putready())  
....................    { 
1CF4:  MOVF   x7B,W
1CF6:  SUBLW  3E
1CF8:  BC    1CFC
....................      #if 0 
....................       if (usb_cdc_put_buffer_free())  
....................       { 
....................          //printf("FL1 %LU\r\n", (int16)usb_cdc_put_buffer_nextin); 
....................          usb_cdc_flush_out_buffer(); 
....................       } 
....................      #endif 
....................      #if defined(USB_ISR_POLLING) 
....................       usb_task(); 
....................      #endif      
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
1CFA:  BRA    1CF4
....................    //putc('.'); 
....................    //putc(c); 
....................    usb_cdc_putc_fast(c); 
1CFC:  MOVFF  2E3,2E4
1D00:  BRA    1CBE
.................... } 
1D02:  GOTO   1D24 (RETURN)
....................  
.................... int1 usb_cdc_puts(char *ptr) 
.................... { 
....................  #if USB_EP2_TX_SIZE>=0x100 
....................    unsigned int16 i; 
....................  #else 
....................    unsigned int8 i; 
....................  #endif 
....................    char c; 
....................     
....................    i = 0; 
....................     
....................    if (!usb_cdc_put_buffer_free()) 
....................       return(FALSE); 
....................     
....................    for (;;) 
....................    { 
....................       c = *ptr++; 
....................       if (!c) 
....................          break; 
....................       _usb_cdc_putc_fast_noflush(c); 
....................       if (++i >= USB_EP2_TX_SIZE) 
....................          break; 
....................    } 
....................     
....................    usb_cdc_flush_out_buffer(); 
....................     
....................    return(TRUE); 
.................... } 
....................  
.................... #endif //__USB_CDC_HELPERS_ONLY__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb()  
.................... { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, unsigned int max) { 
....................    unsigned int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[7]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 7); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[13]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 13); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <rpt10.H> 
.................... // 
.................... // gogo40.h - the main constant declarations for the firmware 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
....................  
....................  
....................  
.................... #define byte int 
....................  
.................... #if defined(__PCM__) 
....................  
.................... #define IOPointer int 
....................  
.................... #elif defined(__PCH__) 
....................  
.................... #define IOPointer int16 
....................  
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////// 
....................  
....................  
.................... #define CMD_PING         0x00 
.................... #define CMD_READ_SENSOR      0x01 
.................... #define CMD_MOTOR_CONTROL   0x02 
.................... #define CMD_MOTOR_POWER      0x03 
.................... #define CMD_TALK_TO_MOTOR   0x04 
.................... #define CMD_BURST_MODE      0x05 
.................... #define CMD_MISC_CONTROL   0x06 
....................  
.................... #define TURN_USER_LED_ON      0 
.................... #define TURN_USER_LED_OFF     1 
....................  
.................... #define MISC_USER_LED    0 
.................... #define MISC_BEEP        1 
.................... #define MISC_SET_PWM     2 
.................... #define MISC_UPLOAD_EEPROM    3 
.................... #define MISC_I2C_SETUP  4 
.................... //#define MISC_I2C_RW     5 
.................... #define MISC_AUTORUN_CONFIG   5 
....................  
.................... #define I2C_START  0 
.................... #define I2C_STOP   1 
.................... #define I2C_WRITE  2 
.................... #define I2C_READ   3 
....................  
.................... #define AUTORUN_ON   1 
.................... #define AUTORUN_OFF  0 
....................  
....................  
....................  
....................  
.................... #define MTR_ON       0 
.................... #define MTR_OFF      1 
.................... #define MTR_RD       2 
.................... #define MTR_THISWAY  3 
.................... #define MTR_THATWAY  4 
.................... #define MTR_COAST    5 
....................  
....................  
.................... #define ACK_BYTE       0b10101010   // 0xAA 
.................... #define InHeader1       0x54 
.................... #define InHeader2       0xfe 
.................... #define ReplyHeader1    0x55 
.................... #define ReplyHeader2    0xff 
....................  
.................... #define EEPROMuploadHeader1   0xEE 
.................... #define EEPROMuploadHeader2   0x11 
....................  
.................... #define ON            1 
.................... #define OFF            0 
....................  
.................... // this is used in main(). Determinds how long to wait for the 
.................... // second command byte. 
.................... #define RETRY         100 
....................  
....................  
.................... //  Sensor read modes 
.................... #define NORMAL_READ  0 
.................... #define MAX_READ     1 
.................... #define MIN_READ     2 
.................... #define MEAN_READ    3 
....................  
....................  
.................... // this const defines the last command that is 
.................... // one byte long. Please refer to the CMD bits 
.................... // in the GoGo kit serial protocol 
....................  
.................... #define ONE_BYTE_CMD   3 
....................  
....................  
.................... /// How many motors does the board have. 
.................... #define MotorCount      4 
....................  
.................... /// Motor Modes 
.................... #define MOTOR_NORMAL    0 
.................... #define MOTOR_SERVO     1 
....................  
.................... // Motor Pin Mappings 
....................                                  // Schematic PIN Names 
.................... #define MTR1_CW         PIN_D0   // MD12 
.................... #define MTR1_CC         PIN_D1   // MD11 
.................... //#define MTR1_EN         PIN_B1   // ME1 
....................  
.................... #define MTR2_CW         PIN_D2   // MD22 
.................... #define MTR2_CC         PIN_D3   // MD21 
.................... //#define MTR2_EN         PIN_E6   // ME2 
....................  
.................... #define MTR3_CW         PIN_B2   // MD32 
.................... #define MTR3_CC         PIN_B3   // MD31 
.................... //#define MTR3_EN         PIN_C7   // ME3 
....................  
.................... #define MTR4_CW         PIN_B5   // MD42 
.................... #define MTR4_CC         PIN_B4   // ME41 
.................... //#define MTR4_EN         PIN_D2   // ME4 
....................  
.................... //! 
.................... //!#define MTR1_CW         PIN_B5   // MD12 
.................... //!#define MTR1_CC         PIN_B4   // MD11 
.................... //!//#define MTR1_EN         PIN_B1   // ME1 
.................... //! 
.................... //!#define MTR2_CW         PIN_B2   // MD22 
.................... //!#define MTR2_CC         PIN_B3   // MD21 
.................... //!//#define MTR2_EN         PIN_E6   // ME2 
.................... //! 
.................... //!#define MTR3_CW         PIN_D2   // MD32 
.................... //!#define MTR3_CC         PIN_D3   // MD31 
.................... //!//#define MTR3_EN         PIN_C7   // ME3 
.................... //! 
.................... //!#define MTR4_CW         PIN_D0   // MD42 
.................... //!#define MTR4_CC         PIN_D1   // ME41 
.................... //! 
....................  
....................  
....................  
.................... #define MOTOR_AB_EN     PIN_E6   // controls the power to the motor chip 
.................... #define MOTOR_CD_EN     PIN_B1   // controls the power to the motor chip 
....................  
....................  
....................  
.................... #define PIC_TRIS_A   0b00101111  // A0,1,2,3,5 are Analog inputs 
.................... #define PIC_TRIS_B   0b00000001  // B0 is the run button 
.................... #define PIC_TRIS_C   0b10010000  // C7 = Rs232 Rx 
....................                                  // C4 = I2C SDA 
....................                                   
.................... #define PIC_TRIS_D   0b00000000 
.................... #define PIC_TRIS_E   0b10000000  // E7 = IR input 
.................... #define PIC_TRIS_F   0b01111100 
.................... #define PIC_TRIS_G   0b00000000 
....................  
....................  
.................... #define RUN_BUTTON   PIN_B0 
.................... #define USER_LED     PIN_C0 
.................... #define USER_LED2    PIN_C1 
.................... #define RUN_LED      USER_LED2 
....................  
....................  
....................  
.................... // Macros to simplify I/O operations 
.................... // 
....................  
.................... #define USER_LED_ON      output_high(USER_LED) 
.................... #define USER_LED_OFF     output_low(USER_LED) 
....................  
....................  
.................... //#define RS232_XMIT      PIN_C6  // (output) RS232 serial transmit 
.................... //#define RS232_RCV       PIN_C7  // (input) RS232 serial receive 
....................  
....................  
.................... #define WAITING_FOR_FIRST_HEADER   1 
.................... #define WAITING_FOR_SECOND_HEADER   2 
.................... #define WAITING_FOR_CMD_BYTE      3 
.................... #define WAITING_FOR_SECOND_CMD_BYTE   4 
.................... #define CMD_READY               5 
....................  
.................... #define WAITING_FOR_EXT_CMD_LENGTH  6 
.................... #define WAITING_FOR_EXT_CMD_STREAM  7 
....................  
....................  
.................... //========================================================= 
.................... // I2C Stuff 
....................  
.................... #define I2C_SCL            PIN_C3 
.................... #define I2C_SDA            PIN_C4 
....................  
.................... //========================================================= 
.................... #define PIEZO              PIN_C2 
....................  
.................... #define LOCAL              0 
.................... #define REMOTE             1 
....................  
....................  
....................  
.................... // ======================================================== 
.................... // Serial Buffer Constants 
....................  
.................... #define SERIAL_BUFFER_SIZE             32 
....................  
.................... #define SERIAL_NO_DATA                  0 
.................... #define SERIAL_SUCCESS                  1 
.................... #define SERIAL_OVERFLOW                 2 
....................  
....................  
.................... // ======================================================== 
.................... // Display Module Stuff 
....................  
.................... #define DISPLAY_7SEG_ADDR_1      0xB0 
.................... #define DISPLAY_7SEG_ADDR_2      0xB2 
.................... #define DISPLAY_LCD_ADDR_1       0xB4 
.................... #define DISPLAY_LCD_ADDR_2       0xB6 
....................  
.................... // ======================================================== 
.................... // Communication channels  
.................... #define COMM_SERIAL              1 
.................... #define COMM_USB                 2 
....................  
....................  
.................... #include <bootload.h> 
....................  // define possible reply bytes 
.................... #define READY_FOR_NEXT  0x11 
.................... #define FINISH_FLAG     0x55 
.................... #define BOOTLOADER_OVERWRITE  0x80 
.................... #define ERROR_TIMEOUT   0x88 
....................  
....................  
.................... #define SerBufferSize 16  // serial input buffer size 
....................  
.................... unsigned int a2i(unsigned char asciiByte); 
.................... unsigned int read8(); 
.................... void writeFlash(int16 memoryBlockAddress, int16 positionInMemoryBlock, int16 len, int *Buffer); 
.................... int waitFor(char targetByte); 
.................... void downloadBootloader(); 
....................  
....................  
.................... //#use rs232(baud=9600,UART1) 
.................... #use i2c(master, I2C1, FORCE_HW) 
2CB8:  BCF    FC6.7
2CBA:  BCF    F9E.3
2CBC:  MOVFF  2EC,FC9
2CC0:  MOVLW  02
2CC2:  BTFSC  FC6.7
2CC4:  BRA    2CD0
2CC6:  BTFSS  F9E.3
2CC8:  BRA    2CC6
2CCA:  MOVLW  00
2CCC:  BTFSC  FC5.6
2CCE:  MOVLW  01
2CD0:  MOVWF  01
2CD2:  RETURN 0
2CD4:  BCF    FC6.6
2CD6:  BSF    FC5.3
2CD8:  BTFSC  FC5.3
2CDA:  BRA    2CD8
2CDC:  BTFSC  00.0
2CDE:  BCF    FC5.5
2CE0:  BTFSS  00.0
2CE2:  BSF    FC5.5
2CE4:  BSF    FC5.4
2CE6:  BTFSC  FC5.4
2CE8:  BRA    2CE6
2CEA:  MOVFF  FC9,01
2CEE:  RETURN 0
.................... #use rs232(baud=9600, UART1) 
1C7C:  BTFSS  F9E.4
1C7E:  BRA    1C7C
1C80:  MOVWF  FAE
1C82:  GOTO   1D12 (RETURN)
....................  
.................... #include <logovm.h> 
.................... // 
.................... // logovm.h - Logo compiler constants and function definitions 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
....................  
.................... ///////////////////////////////////////////////////// 
.................... // 
.................... //  Logo Virtual Machine 
.................... // 
.................... //  Written by Arnan (Roger) Sipitakiat 
.................... // 
.................... //  Logo running on the GoGo Board was created based 
.................... //  on the Cricket Logo. 
.................... // 
.................... //  Cricket Logo creators include: 
.................... //    Fred G. Martin 
.................... //    Brian Silverman 
.................... //    Mitchel Resnick 
.................... //    Robbie Berg 
.................... // 
.................... ///////////////////////////////////////////////////// 
....................  
....................  
.................... #include <stack.h> 
.................... // 
.................... // stack.h - declair constants for the Logo VM's stacks 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
....................  
.................... // Stack size increased from 20 in version 4.0.12 
.................... #define STACK_SIZE            64 
.................... #define INPUT_STACK_SIZE      64 
....................  
.................... int   gblStkPtr,   // ptr to the top of the data stack 
....................       gblErrFlag;  // error flag 
.................... unsigned int16 gblStack[STACK_SIZE]; 
....................  
....................  
.................... int   gblInputStkPtr;   // ptr to the top of the procedure input stack 
.................... unsigned int16 gblInputStack[INPUT_STACK_SIZE]; 
....................  
....................  
.................... void stkPush(unsigned int16 stackItem); 
.................... unsigned int16 stkPop(void); 
....................  
.................... void inputPush(unsigned int16 stackItem); 
.................... unsigned int16 inputPop(void); 
....................  
.................... void clearStack(); 
....................  
.................... #include <evalOpcode.h> 
.................... // 
.................... // evalopcode.h - Header declarations for the Logo Operations 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
....................  
.................... ///////////////////////////////////////////////////// 
.................... // 
.................... //  Logo Virtual Machine 
.................... // 
.................... //  Written by Arnan (Roger) Sipitakiat 
.................... // 
.................... //  Logo running on the GoGo Board was created based 
.................... //  on the Cricket Logo. 
.................... // 
.................... //  Cricket Logo creators include: 
.................... //    Fred Martin 
.................... //    Brian Silverman 
.................... //    Mitchel Resnick 
.................... //    Robbie Berg 
.................... // 
.................... ///////////////////////////////////////////////////// 
....................  
....................  
.................... int16 gblLoopAddress=0;   // Stores the start address of a Loop 
.................... int16 gblRepeatCount=0;  // Tracks the progress of the repeat command 
....................  
.................... int1 gblONFORNeedsToFinish=0;  // flags when onfor is launched 
....................                         // it causes fetchNextOpcode() to return 
....................                         // an Off command the next time it is called 
....................  
.................... void evalOpcode(unsigned char opcode); 
.................... #separate void evalOpcode2(unsigned char opcode); 
....................  
....................  
.................... #include <memoryMap.h> 
.................... // 
.................... // memoryMap.c - Defines the memory segments and their addresses 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
.................... #include <eeprom.h> 
.................... // 
.................... // eeprom.h - headles EEPROM operations of the gogoboard 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
.................... #include "24256.c"      // this is CCS's EEPROM routines 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define EEPROM_ADDRESS 0xa0 
.................... #define EEPROM_SIZE   32768 
.................... //#define byte unsigned char 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(I2C_SCL); 
1FE8:  BSF    F94.3
....................    output_float(I2C_SDA); 
1FEA:  BSF    F94.4
....................  
.................... } 
1FEC:  GOTO   20D4 (RETURN)
....................  
....................  
.................... void write_ext_eeprom(long int address, byte data) 
.................... { 
....................    short int status; 
....................    i2c_start(); 
....................    i2c_write(EEPROM_ADDRESS); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_write(data); 
....................    i2c_stop(); 
....................  
....................    // min delay time tested to work was 2 ms. 
....................    // using 5 ms just for safety. 
....................     
....................    delay_ms(5); 
....................  
....................  
....................    // The above delay was added because CCS's pooling code 
....................    // below doesn't work when complied with their 
....................    // newer compiler (4.0). It worked with older versions (3.x)  
....................  
.................... //   i2c_start(); 
.................... //   status=i2c_write(EEPROM_ADDRESS); 
.................... //   while( (status==1)) 
.................... //   { 
.................... //   i2c_start(); 
.................... //   status=i2c_write(EEPROM_ADDRESS); 
.................... //   } 
....................  
.................... } 
....................  
....................  
.................... byte read_ext_eeprom(long int address) { 
....................    byte data; 
....................    i2c_start(); 
....................    i2c_write(EEPROM_ADDRESS); 
....................    i2c_write(address>>8); 
....................    i2c_write(address); 
....................    i2c_start(); 
....................    i2c_write(0xa1); 
....................    data=i2c_read(0); 
....................    i2c_stop(); 
....................    return(data); 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #define  FLASH32KWORDS 
....................  
.................... #if defined (__PCM__) 
....................     // Memory Map for PCM (14 bit) parts (i.e. the 16F877 chip) 
....................  
....................     ////////////////////////////////////////////////// 
....................     // 
....................     //  GoGo Board on-chip FLASH Memory Map (8K) 
....................     // 
....................     //  1FFF  +---------------+ 
....................     //        |  Bootloader   | 
....................     //        |               | 
....................     //  1D00  +---------------+ 
....................     //        |Logo Procedures| 
....................     //  1C00  +---------------+ 
....................     //        |               | 
....................     //        | GoGo Firmware | 
....................     // 
....................     //        |               | 
....................     //  0000  +---------------+ 
....................      
....................      
....................      
....................     ////////////////////////////////////////////////// 
....................     //   User program memory map 
....................     //   we storm the cricket logo code in the 
....................     //   flash memory to increase the speed. 
....................     // 
....................     //   The size must be limited to 256 bytes because 
....................     //   the boot loader begins at address 0x1d00 
....................     // 
....................     #define FLASH_USER_PROGRAM_BASE_ADDRESS   0x1C00 
....................      
....................      
....................     /////////////////////////////////////////////////// 
....................     //  This defines where the bootloader begines 
....................     //  the user program must not exceed this address 
....................     #define FLASH_BOOTLOADER_BASE_ADDRESS     0x1D00 
....................      
....................      
....................     ////////////////////////////////////////////////// 
....................     //  Location of the run button vector. 
....................     //  This is 0xff0 in the cricket. We map it to 
....................     //  the following address. 
....................     #define RUN_BUTTON_BASE_ADDRESS           0x1CF0 
....................  
....................  
....................     ////////////////////////////////////////////////// 
....................     // 
....................     //  GoGo Board EEPROM chip Memory Map (32K) 
....................     // 
....................     //  7FFF  +---------------+ 
....................     //        |               | 
....................     //        |               | 
....................     //        |               | 
....................     //        |  Data Logging | 
....................     //        |               | 
....................     //        |               | 
....................     //        |               | 
....................     //  0500  +---------------+ 
....................     //        |               | 
....................     //        | Array Storage | 
....................     //        |               | 
....................     //  0010  +---------------+ 
....................     //        | Misc Storage  | 
....................     //  0000  +---------------+ 
....................      
....................      
....................      
....................      
....................     ////////////////////////////////////////////////// 
....................     // 
....................     //  The following addresses are locations in the 
....................     //  EEPROM chip 
....................      
....................      
....................     ///////////////////////////////////////////////// 
....................     //   Data recording memory map 
....................     //   Mem start from 0x0500 and goes to 0x7FFF (~30k) 
....................     #define RECORD_BASE_ADDRESS      0x0500 
....................      
....................      
....................     ///////////////////////////////////////////////// 
....................     //   Base address for the array memory 
....................     #define ARRAY_BASE_ADDRESS      0x10 
....................      
....................      
....................     ////////////////////////////////////////////////// 
....................     //  Base address for the memory pointer storage 
....................     //  - Normally this is kept in the variable gblRecordPtr 
....................     //  - But we record this value to the eeprom chip 
....................     //    everytime we record data. 
....................     //  - This way we know where is the most recently 
....................     //    recorded location. It would be useful to know 
....................     //    this in the case of temporary power loss. 
....................     //  - It is used for automatic EEPROM upload 
....................      
....................     // note that the mem pointer occupies two bytes 
....................     #define MEM_PTR_LOG_BASE_ADDRESS 0x00 
....................  
....................  
....................  
.................... // for PIC18 parts with 16K words flash memory. I.e. the 18F458, 18F4550 chips 
.................... #elif defined(__PCH__) 
....................  
....................    #ifdef FLASH16KWORDS 
....................  
....................     ////////////////////////////////////////////////// 
....................     // 
....................     //  GoGo Board on-chip FLASH Memory Map (16K Words) 
....................     // 
....................     //  3FFF  +---------------+ 
....................     //        |  Bootloader   | 
....................     //  3D00  +---------------+ 
....................     //  3CF0  +---------------+ Configuration Bytes (see below) 
....................     //        |Logo Procedures| 1.0K Words 
....................     //        |               | 
....................     //  3900  +---------------+ 
....................     //        | Array Storage | 0.5K Words 
....................     //  3700  +---------------+ 
....................     //        |               | 
....................     //        |               | 
....................     //        | Data Logging  | ~4 K Words 
....................     //        |               | 
....................     //        |               | 
....................     //  2800  +---------------+ -> check RESERVED_MEMORY_START defined in gogo40.c 
....................     //        |               | 
....................     //        |               | 
....................     //        | GoGo Firmware | 10K Words 
....................     //        |               | 
....................     //        |               | 
....................     //  0000  +---------------+ 
....................  
....................     // Note that the addresses above are word addresses. 
....................     // PCH parts address memory in bytes which are 2x of 
....................     // the Word addresses 
....................  
....................     //  There are 16 configureation words between address 
....................     //  3CF0 and 3D00. Here's the layout. 
....................     // 
....................     //  L,L,L,L,L,L,L,L,D,D,D,D,D,D,D,D 
....................     //  ^               ^ 
....................     //  3CF0            3CF8 
....................     // 
....................     //  L = Logo Configurations (i.e. the start button pointer) 
....................     //  D = Data Logger Configurations (i.e. current data location) 
....................  
....................  
....................     /////////////////////////////////////////////////// 
....................     //  This defines where the bootloader begines 
....................     //  the user program must not exceed this address 
....................     #define FLASH_BOOTLOADER_BASE_ADDRESS     0x7A00 
....................  
....................  
....................     ////////////////////////////////////////////////// 
....................     //  Location of the run button vector. 
....................     //  This is 0xff0 in the cricket. We map it to 
....................     //  the following address. 
....................     #define RUN_BUTTON_BASE_ADDRESS           0x79E0 
....................      
....................  
....................     ////////////////////////////////////////////////// 
....................     //  Base address for the memory pointer storage 
....................     //  - Normally this is kept in the variable gblRecordPtr 
....................     //  - But we record this value to the flash mem 
....................     //    everytime we record data. 
....................     //  - This way we know where is the most recently 
....................     //    recorded location. It would be useful to know 
....................     //    this in the case of temporary power loss. 
....................     //  - It is used for automatic Data upload 
....................  
....................     // note that the mem pointer occupies two bytes 
....................     #define MEM_PTR_LOG_BASE_ADDRESS 0x79F0 
....................  
....................     ////////////////////////////////////////////////// 
....................     // Saves  the configuration for Logo procedure 
....................     // autorun. 0=off, 1=on 
....................     // If turned on. Any stored Logo procedure will 
....................     // run automatically everyting the board is 
....................     // turned on. 
....................     #define AUTORUN_STATUS_ADDRESS 0x79F2 
....................  
....................  
....................     ////////////////////////////////////////////////// 
....................     //   User program memory map 
....................     // 
....................     #define FLASH_USER_PROGRAM_BASE_ADDRESS   0x7200 
....................  
....................  
....................     ///////////////////////////////////////////////// 
....................     //   Base address for the array memory 
....................     #define ARRAY_BASE_ADDRESS      0x6E00 
....................  
....................  
....................     //////////////////////////////////////////////////////////////// 
....................     //   Data recording memory map 
....................     //   Start at RESERVED_MEMORY_START which is defined in gogo40.c 
....................     #define RECORD_BASE_ADDRESS      RESERVED_MEMORY_START 
....................  
....................  
....................    //////////////////////////////////////////////////////////////// 
....................    //  PIC 18F66J50 (32 Kwords) 
....................    //////////////////////////////////////////////////////////////// 
....................     
....................    #elif defined(FLASH32KWORDS) 
....................     
....................     ////////////////////////////////////////////////// 
....................     // 
....................     //  GoGo Board on-chip FLASH Memory Map (32K Words) 
....................     // 
....................     //  7FFF  +---------------+ 
....................     //        |  Bootloader   | 
....................     //  7D00  +---------------+ 
....................     //  7CF0  +---------------+ Configuration Bytes (see below) 
....................     //        |Logo Procedures| ~2.0K Words 
....................     //        |               | 
....................     //  7400  +---------------+ 
....................     //        | Array Storage | 0.5K Words 
....................     //  7200  +---------------+ 
....................     //        |               | 
....................     //        |               | 
....................     //        | Data Logging  | ~18 K Words 
....................     //        |               | 
....................     //        |               | 
....................     //  2800  +---------------+ -> check RESERVED_MEMORY_START defined in gogo40.c 
....................     //        |               | 
....................     //        |               | 
....................     //        | GoGo Firmware | ~10K Words 
....................     //        |               | 
....................     //        |               | 
....................     //  0000  +---------------+ 
....................  
....................     // Note that the addresses above are word addresses. 
....................     // PCH parts address memory in bytes which are 2x of 
....................     // the Word addresses 
....................  
....................     //  There are 16 configureation words between address 
....................     //  7CF0 and 7D00. Here's the layout. 
....................     // 
....................     //  L,L,L,L,L,L,L,L,D,D,D,D,D,D,D,D 
....................     //  ^               ^ 
....................     //  7CF0            7CF8 
....................     // 
....................     //  L = Logo Configurations (i.e. the start button pointer) 
....................     //  D = Data Logger Configurations (i.e. current data location) 
....................     // 
....................     //  L0 = Run button pointer 
....................     //  D0 = Data record pointer 
....................     //  D1 = Autorun flag 
....................  
....................     /////////////////////////////////////////////////// 
....................     //  This defines where the bootloader begines 
....................     //  the user program must not exceed this address 
....................     #define FLASH_BOOTLOADER_BASE_ADDRESS     0xFA00 
....................  
....................  
....................     ////////////////////////////////////////////////// 
....................     //  Location of the run button vector. 
....................     //  This is 0xff0 in the cricket. We map it to 
....................     //  the following address. 
....................     #define RUN_BUTTON_BASE_ADDRESS           0xF9E0 
....................      
....................  
....................     ////////////////////////////////////////////////// 
....................     //  Base address for the memory pointer storage 
....................     //  - Normally this is kept in the variable gblRecordPtr 
....................     //  - But we record this value to the flash mem 
....................     //    everytime we record data. 
....................     //  - This way we know where is the most recently 
....................     //    recorded location. It would be useful to know 
....................     //    this in the case of temporary power loss. 
....................     //  - It is used for automatic Data upload 
....................  
....................     // note that the mem pointer occupies two bytes 
....................     #define MEM_PTR_LOG_BASE_ADDRESS 0xF9F0 
....................  
....................     ////////////////////////////////////////////////// 
....................     // Saves  the configuration for Logo procedure 
....................     // autorun. 0=off, 1=on 
....................     // If turned on. Any stored Logo procedure will 
....................     // run automatically everyting the board is 
....................     // turned on. 
....................     #define AUTORUN_STATUS_ADDRESS 0xF9F2 
....................  
....................  
....................     ////////////////////////////////////////////////// 
....................     //   User program memory map 
....................     // 
....................     #define FLASH_USER_PROGRAM_BASE_ADDRESS   0xE800 
....................  
....................  
....................     ///////////////////////////////////////////////// 
....................     //   Base address for the array memory 
....................     #define ARRAY_BASE_ADDRESS      0xE400 
....................  
....................  
....................     //////////////////////////////////////////////////////////////// 
....................     //   Data recording memory map 
....................     //   Start at RESERVED_MEMORY_START which is defined in gogo40.c 
....................     #define RECORD_BASE_ADDRESS      RESERVED_MEMORY_START    
....................  
....................    #endif 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /// Logo VM state machine definition 
....................  
.................... #define IDLE                     0 
....................  
.................... /// Comm protocol Sates 
....................  
.................... #define SET_PTR_HI_BYTE          128 
.................... #define SET_PTR_LOW_BYTE         129 
.................... #define READ_BYTES_COUNT_HI      130 
.................... #define READ_BYTES_COUNT_LOW     131 
.................... #define WRITE_BYTES_COUNT_HI     132 
.................... #define WRITE_BYTES_COUNT_LOW    133 
.................... #define WRITE_BYTES_SENDING      134 
.................... #define CRICKET_NAME             135 
....................  
....................  
....................  
.................... /// Comm commands 
....................  
.................... #define SET_PTR         0x83 
.................... #define READ_BYTES      0x84 
.................... #define WRITE_BYTES     0x85 
.................... #define RUN             0x86 
.................... #define CRICKET_CHECK   0x87 
....................  
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////// 
.................... // 
.................... //   Op code 
....................  
.................... #define  CODE_END             0 
.................... #define  NUM8                 1 
.................... #define  NUM16                2 
.................... #define  LIST                 3 
.................... #define  EOL                  4 
.................... #define  EOLR                 5 
.................... #define  LTHING               6 
.................... #define  STOP                 7 
.................... #define  OUTPUT               8 
.................... #define  REPEAT               9 
.................... #define  COND_IF              10 
.................... #define  COND_IFELSE          11 
.................... #define  BEEP                 12 
.................... #define  NOTE                 13 
.................... #define  WAITUNTIL            14 
.................... #define  LOOP                 15 
.................... #define  WAIT                 16 
.................... #define  TIMER                17 
.................... #define  RESETT               18 
.................... #define  SEND                 19 
.................... #define  IR                   20 
.................... #define  NEWIR                21 
.................... #define  RANDOM               22 
.................... #define  OP_PLUS               23 
.................... #define  OP_MINUS               24 
.................... #define  OP_MULTIPLY            25 
.................... #define  OP_DIVISION            26 
.................... #define  OP_REMAINDER         27 
.................... #define  OP_EQUAL               28 
.................... #define  OP_GREATER            29 
.................... #define  OP_LESS               30 
.................... #define  OP_AND               31 
.................... #define  OP_OR                  32 
.................... #define  OP_XOR               33 
.................... #define  OP_NOT               34 
.................... #define  SETGLOBAL            35 
.................... #define  GETGLOBAL            36 
.................... #define  ASET                  37 
.................... #define  AGET                  38 
.................... #define  RECORD               39 
.................... #define  RECALL               40 
.................... #define  RESETDP               41 
.................... #define  SETDP                  42 
.................... #define  ERASE                  43 
.................... #define  WHEN                  44 
.................... #define  WHENOFF               45 
.................... #define  M_A                  46 
.................... #define  M_B                  47 
.................... #define  M_AB                  48 
.................... #define  M_ON                  49 
.................... #define  M_ONFOR               50 
.................... #define  M_OFF                  51 
.................... #define  M_THISWAY            52 
.................... #define  M_THATWAY            53 
.................... #define  M_RD                  54 
.................... #define  SENSOR1               55 
.................... #define  SENSOR2               56 
.................... #define  SWITCH1               57 
.................... #define  SWITCH2               58 
.................... #define  SETPOWER               59 
.................... #define  BRAKE                  60 
.................... #define  BSEND                  61 
.................... #define  BSR                  62 
.................... #define  M_C                  63 
.................... #define  M_D                  64 
.................... #define  M_CD                  65 
.................... #define  M_ABCD               66 
.................... #define  FASTSEND               67 
.................... #define  REALLY_STOP          68 
.................... #define  EB                     69 
.................... #define  DB                     70 
.................... #define  LOW_BYTE               71 
.................... #define  HIGH_BYTE            72 
....................  
.................... /// These code are unique to the GoGo board 
.................... #define  SENSOR3              73 
.................... #define  SENSOR4              74 
.................... #define  SENSOR5              75 
.................... #define  SENSOR6              76 
.................... #define  SENSOR7              77 
.................... #define  SENSOR8              78 
.................... #define  SWITCH3              79 
.................... #define  SWITCH4              80 
.................... #define  SWITCH5              81 
.................... #define  SWITCH6              82 
.................... #define  SWITCH7              83 
.................... #define  SWITCH8              84 
....................  
.................... #define ULED_ON               85 
.................... #define ULED_OFF              86 
....................  
.................... #define SERVO_SET_H           87 
.................... #define SERVO_LT              88 
.................... #define SERVO_RT              89 
....................  
.................... #define TALK_TO_MOTOR        90   // this replaces the M_A, M_B, M_C, ... commands. 
....................                            // it will allow a more flexible motor addressing 
....................                            // i.e. abc, would now work. 
....................                            // Only the GoGo Compiler (not Jackal/Logo Blocks) 
....................                            // will make use of this. 
....................  
.................... #define CL_I2C_START          91 
.................... #define CL_I2C_STOP           92 
.................... #define CL_I2C_WRITE          93 
.................... #define CL_I2C_READ           94 
....................  
.................... // serial communication commands 
.................... #define SERIAL                95 
.................... #define NEWSERIAL             96 
....................  
.................... // DS1307 Realtime clock module commands 
.................... #define RTC_INIT              97 
.................... #define RTC_GET_ITEM          98 
....................  
.................... // 7-segment/LCD display module commands 
.................... #define DISPLAY_SHOW             99 
....................  
.................... #define DISPLAY_CLS           100  
.................... #define DISPLAY_GETPOS        101 // does nothing on 7-segment displays 
.................... #define DISPLAY_SETPOS        102 // returns 0 on 7-segment displays 
.................... #define TALK_TO_7SEG_1        103 
.................... #define TALK_TO_7SEG_2        104 
.................... #define TALK_TO_LCD_1         105 
.................... #define TALK_TO_LCD_2         106 
....................  
....................  
....................  
.................... ///////////////////////////////////////////////// 
.................... //   Global variables 
....................  
....................  
.................... int16 globalVariables[16]={0}; 
....................  
.................... unsigned int16 gblRecordPtr; // pointer to the current location in the data eeprom 
....................                              // it will be initiazlied to the most recent record location 
....................                              // in init_variables() 
....................  
.................... unsigned int16  gblMemPtr,     // FLASH/EEPROM pointer 
....................                 gblRWCount;    // Read/Write length 
....................  
.................... // Sends bytes to the computer 
.................... void sendBytes(unsigned int16 memPtr, unsigned int16 count); 
.................... unsigned char fetchNextOpcode(); 
....................  
.................... #include <stdlib.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
35F2:  MOVFF  1B4,2B5
35F6:  MOVFF  1B3,2B4
35FA:  MOVFF  1B2,2B3
35FE:  MOVFF  1B1,2B2
3602:  MOVLW  41
3604:  MOVLB  2
3606:  MOVWF  xB9
3608:  MOVLW  C6
360A:  MOVWF  xB8
360C:  MOVLW  4E
360E:  MOVWF  xB7
3610:  MOVLW  6D
3612:  MOVWF  xB6
3614:  MOVLB  0
3616:  BRA    354E
3618:  MOVLW  39
361A:  MOVLB  2
361C:  ADDWF  00,W
361E:  MOVLB  1
3620:  MOVWF  xB1
3622:  MOVLW  30
3624:  MOVLB  2
3626:  ADDWFC 01,W
3628:  MOVLB  1
362A:  MOVWF  xB2
362C:  MOVLW  00
362E:  MOVLB  2
3630:  ADDWFC 02,W
3632:  MOVLB  1
3634:  MOVWF  xB3
3636:  MOVLW  00
3638:  MOVLB  2
363A:  ADDWFC 03,W
363C:  MOVLB  1
363E:  MOVWF  xB4
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
3640:  MOVFF  1B3,00
3644:  MOVFF  1B4,01
3648:  CLRF   02
364A:  CLRF   03
364C:  MOVFF  1B4,2B4
3650:  MOVFF  1B3,2B3
3654:  MOVFF  1B4,2E6
3658:  MOVFF  1B3,2E5
365C:  MOVLW  7F
365E:  MOVLB  2
3660:  MOVWF  xE8
3662:  SETF   xE7
3664:  MOVLB  0
3666:  RCALL  35AC
3668:  MOVFF  00,01
366C:  MOVFF  03,02
.................... } 
3670:  GOTO   4A58 (RETURN)
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
1236:  MOVFF  A4D,1B4
123A:  MOVFF  A4C,1B3
123E:  MOVFF  A4B,1B2
1242:  MOVFF  A4A,1B1
.................... } 
1246:  RETURN 0
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <i2cDisplay.h> 
.................... //#define DISPLAY_ADDRESS 0xB0  // display address is dynamic depending on  
....................                                 // which module is being connected 
.................... #define DISPLAY_CMD_PING  1 
.................... #define DISPLAY_CMD_SEND_VALUE 2 
.................... #define DISPLAY_CMD_SEND_TEXT   3 
.................... #define DISPLAY_CMD_UPDATE_SENSORS 4 
.................... #define DISPLAY_CMD_SEND_LONG_TEXT  5 
.................... #define DISPLAY_CMD_CLS 6 
.................... #define DISPLAY_CMD_GETPOS 7 
.................... #define DISPLAY_CMD_SETPOS 8 
....................  
.................... int displayPing(); 
.................... void displayValue(int16 val); 
.................... void displayText(char ch1, char ch2, char ch3, char ch4); 
.................... void displayLongText(char *text); 
.................... void displaySendSensors(void); 
.................... void clearDisplay(); 
.................... int getDisplayPos(); 
.................... void setDisplayPos(int pos); 
....................  
.................... // 1 -> use the pi-topping builtin 7segment display 
.................... // 0 -> use external 7segment via i2c  
.................... int1 gblUseOnBoard7Segment = 1; 
....................  
.................... #include <i2c.h>   // i2c read/write routines 
.................... void resetI2C(); 
.................... int i2cWrite(int slaveAddress, int registerAddress, int registerValue); 
.................... int i2cRead(int slaveAddress, int registerAddress, int *registerValue); 
....................  
.................... #include <ds1307.h>   // real time clock module 
.................... BYTE bin2bcd(BYTE binary_value); 
.................... BYTE bcd2bin(BYTE bcd_value); 
.................... void rtcInit();  
.................... int rtcGetItem(int itemNumber); 
.................... void rtcSetItem(int itemNumber, itemValue); 
....................  
.................... #include <7segment.h> // on-baord 7-segment display driver 
.................... #define  EN_DIGIT1   PIN_F7 
.................... #define  EN_DIGIT2   PIN_E3 
.................... #define  EN_DIGIT3   PIN_E4 
.................... #define  EN_DIGIT4   PIN_E0 
....................  
.................... #define  SEG_A       PIN_E1 
.................... #define  SEG_B       PIN_E2 
.................... #define  SEG_C       PIN_G3 
.................... #define  SEG_D       PIN_G1 
.................... #define  SEG_E       PIN_G0 
.................... #define  SEG_F       PIN_E5 
.................... #define  SEG_G       PIN_G4 
.................... #define  SEG_DP      PIN_G2 
....................  
.................... void showNextDigit(); 
.................... void turnOffAllSegments(); 
.................... int Char2Segments(char inChar); 
.................... void cls_internal7Seg(); 
.................... void showOnBuiltIn7Segment(char ch1, char ch2, char ch3, char ch4); 
....................  
.................... int gblDisplayDigit=0; 
....................  
.................... //!int gblCharCodeToShow1 = 0b00111101;  // 'G' 
.................... //!int gblCharCodeToShow2 = 0b01011100;  // 'o' 
.................... //!int gblCharCodeToShow3 = 0b00111101;  // 'G' 
.................... //!int gblCharCodeToShow4 = 0b01011100;  // 'o' 
....................  
.................... int gblCharCodeToShow1 = 0;  // 'G' 
.................... int gblCharCodeToShow2 = 0;  // 'o' 
.................... int gblCharCodeToShow3 = 0;  // 'G' 
.................... int gblCharCodeToShow4 = 0;  // 'o' 
....................  
....................  
....................  
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C)   
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #use fast_io(F) 
.................... #use fast_io(G) 
....................  
....................  
.................... #define HARDWARE_ID1     0x01   // 02 = Pi-Topping Board (for the Raspberry Pi) 
.................... #define HARDWARE_ID2     0x10   // 10 = version 1.0 
.................... #define FIRMWARE_ID      1   // Firmware version 
....................  
....................  
....................  
.................... #define defaultPort      0 
....................  
.................... #define channelSwitchDelay   100   // delay time in us after switching adc channels 
....................                               // Don't decrease this value without testing. 
....................                               // If the delay is too short (i.e. 10us) the adc won't 
....................                               // have enough time to stabilize before reading the 
....................                               // next channel. 
....................  
.................... /// Timer 1 Counter 
.................... /// This value should be 3036 ( 65536 - 0.1/(4/20000000) * 8) 
.................... /// where 0.1 is the time in seconds we want the ISR to be called 
.................... /// 4/20000000 is the time each counter takes to tick 
.................... /// 8 is the timer divider ... see setup_timer_1() 
....................  
.................... //#define T1_COUNTER      3036     // tick rate = 1.60/8 uSec (value according to the math) 
....................  
.................... #define T0_COUNTER      56161      // at 48Mhz, and prescale=128 the interrupt period is 
....................                                    // calculated from 1/48 * 4 * 128 * (65536-56161)= 100 ms 
.................... #define PWM_PERIOD      27135      // 65535-38400. Used in Timer1, which gives a 25.6 ms period 
....................  
....................  
....................  
.................... #define  CMD_TIMEOUT_PERIOD  4     // determins how long befor the board will reset 
....................                                     // the command state. Units in 1/10 of a second 
....................  
....................  
.................... // RESERVED_MEMORY_START must be the same as RECORD_BASE_ADDRESS in memoryMap.h 
.................... #define RESERVED_MEMORY_START    0x5800 // must be a multiple of getenv("FLASH_ERASE_SIZE"), which is 1024 in the pic18F66J50 
.................... #define RESERVED_MEMORY_END      0xFFF0 
....................  
.................... #if defined(__PCM__) 
....................    // reserve memory for the bootloader. This allows firmware updates via the serial port 
....................    #org 0x1d00, 0x1FFF void loader16F876(void) {} 
....................     
....................    // This memory area is used to store Cricket Logo commands 
....................    #org 0x1c00, 0x1cff void cricketLogoMemoryArea(void) {} 
....................  
.................... #elif defined(__PCH__) 
....................    // reserve memory for the bootloader. This allows firmware updates via the serial port 
.................... ///   #org 0x6500, 0x7FFF void loader16F876(void) {}  // these are byte addresses.  
....................                                                    // equiv word addresses are 3D00 - 3FFF 
....................     
....................    // This memory area is used to store Cricket Logo commands 
.................... ///   #org 0x7200, 0x79DF void cricketLogoMemoryArea(void) {} // equiv word addresses are 3900 - 3DEF 
....................       #org RESERVED_MEMORY_START, RESERVED_MEMORY_END void reserved(void) {}  
5800:  RETURN 0
....................                                                  // do not allow gogo code to use the upper parts of 
....................                                                  // the flash memory. They are reserved for data logging 
....................                                                  // array storage, and the logo code. See memoryMap.h 
....................                                                  // for memory allocation details. 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... ///////////////////////////////////////////////////////////////// 
.................... //  Function Declaration 
.................... ///////////////////////////////////////////////////////////////// 
....................  
.................... void startStopLogoProcedures(void);  
.................... void stopLogoProcedures(void); 
....................  
....................  
.................... void setHigh(IOPointer Pin); 
.................... void setLow(IOPointer Pin); 
.................... int  readPin(IOPointer Pin); 
....................  
.................... short getBit(int InByte, int BitNo); 
.................... void setBit(int *InByte, int BitNo); 
.................... void clearBit(int *InByte, int BitNo); 
....................  
.................... void Ping(int Param); 
.................... void TalkToMotor(int MotorBits); 
.................... void MotorControl(int MotorCmd); 
.................... void SetMotorPower(int Power); 
.................... void ChangeMotorPower(int delta); 
.................... void createPWMVectorTable(void); 
.................... //void sortMtrDuty(); 
.................... void SetMotorMode(int motorMode); // normal or servo 
....................  
.................... void ENHigh(int groupNo); 
.................... void ENLow(int groupNo); 
....................  
.................... void MotorON(int MotorNo); 
.................... void MotorOFF(int MotorNo); 
.................... void MotorRD(int MotorNo); 
.................... void MotorThisWay(int MotorNo); 
.................... void MotorThatWay(int MotorNo); 
.................... void MotorCoast(int MotorNo); 
.................... void miscControl(int cur_param, int cur_ext, int cur_ext_byte); 
....................  
.................... void beep(); 
....................  
.................... void SetBurstMode(int SensorBits, int Mode); 
.................... void DoSensorStuff(); 
.................... // this prints the result back to the PC 
.................... //#inline int16 outputSensor(int Target, int readMode); 
.................... // this one just returns the sensor value 
.................... unsigned int16 readSensor(int sensorNo); 
.................... long getSensorVal(); 
.................... void switchAdcChannel(int channelNo); 
....................  
.................... void ProcessInput(); 
.................... void ProcessRFInput(); 
.................... //int  process_input(); 
.................... //void Add_to_CMD(int InByte); 
.................... //void EndCMD(); 
.................... //byte get_cmd_buff(int *cmd_ptr); 
.................... void init_variables(); 
.................... void intro (); 
.................... void Halt(); 
.................... void initBoard(); 
....................  
.................... void DoDisplayModuleStuff(); 
.................... void DoMotorStuff(); 
....................  
.................... ////////////////////////////////////////// 
.................... // Flash memory routines 
.................... ///////////////////////////////////////// 
....................  
.................... void FLASHSetWordAddress(int16 address); 
.................... void FLASHBufferedWrite(int16 InByte) ; 
.................... void FLASHFlushBuffer(); 
.................... void FLASHWrite(int16); 
.................... void writeFLASH(int16 memoryBlockAddress, int16 positionInMemoryBlock, int16 len, int *Buffer); 
....................  
....................  
.................... timer2ISR(); 
....................  
.................... ///////////////////////////////////////////////////////////////// 
.................... //  Global Variables 
.................... ///////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //IOPointer  MotorENPins [MotorCount]={  MTR1_EN, MTR2_EN, MTR3_EN, MTR4_EN}; 
.................... IOPointer  MotorCWPins [MotorCount]={  MTR1_CW, MTR2_CW, MTR3_CW, MTR4_CW}; 
.................... IOPointer  MotorCCPins [MotorCount]={  MTR1_CC, MTR2_CC, MTR3_CC, MTR4_CC}; 
....................  
.................... unsigned int CMD_STATE; 
....................  
.................... int gbl_cur_cmd, gbl_cur_param, gbl_cur_ext, gbl_cur_ext_byte; 
.................... int gblExtCMDBuffer[32];   // buffer to hold the gogo extended command stream 
.................... int1 gblExtCmdMode=0;   // flag. Tells us if the command recieved is an extended command. 
.................... int gblExtCmdLen; 
.................... int gblExtCmdBufferIndex; 
....................  
....................  
.................... int gblSensorPortMap[8] = {11,10,7,3,2,1,0,4}; // this array maps the sensor number to the  
....................                                             // physical sensor port used on the PIC 
....................  
.................... int gblBurstModeBits; 
.................... int gblBurstModeCounter=0;   // tracks which sensor is the current burst mode sensor 
....................  
.................... int1 gblSlowBurstMode=0;  // determinds which burst mode we're in (0=normal, 1=slow) 
....................                           // as of GoGo 4.0, this option has no effect.  
....................                            
.................... int1 gblBurstModeTimerHasTicked=0;  // ticks every 1/72 sec (by timer0) 
.................... int gblCurSensorChannel; 
....................  
....................  
....................  
....................  
.................... int gblMotorMode=0b00000000;   // default to normal mode 
.................... int gblActiveMotors; 
.................... int gblMotorDir=0; 
.................... int gblMotorONOFF = 0; 
.................... int gblMtrDuty[MotorCount+1] = {0xff,0xff,0xff,0xff,0xff};  // Motor PWM Duty cycle 
.................... int gblMtrPrevDuty[MotorCount+1] = {0xff,0xff,0xff,0xff,0xff};  //Prev PWM Duty cycle -> to detect change  
.................... int1 gblMtrNeedToRecreateMtrDutyVector = 0;  // True when gblMtrDuty != gblMtrPrevDuty 
.................... int1 gblAtEndOfPWMCycle = 0; // True when at end of a PWM cycle. This is when we can 
....................                              // update the duty vector  
.................... //int gblMtrDutyIndex[MotorCount+1] = {0,1,2,3,4}; // index to the sorted gblMtrDuty[] 
.................... //unsigned int gblTimer0Counter = MotorCount; // Motor duty cycle counter. 
.................... //unsigned int gblDutyCycleFlag = 0; // used to find the next duty cycle in timer0 
.................... //unsigned int gblCurrentDutyIndex = 0; // keeps track of the current duty cycle being used. 
....................  
.................... int1 flgNeedToTurnOffAllMotors=0; // flag to tell the main loop to turn off all motors 
....................  
.................... ////////////////////////////////////////////////////////// 
.................... // PWM variables 
.................... ////////////////////////////////////////////////////////// 
.................... int16 gblPWMVector[4] = {0,0,0,0}; 
.................... int   gblPWMVectorPorts[4] = {0,0,0,0}; 
.................... int   gblPWMVectorLen = 0; 
.................... int16 gblPWMTerminatingVector = PWM_PERIOD; 
.................... int   gblPWMVectorIndexCounter = 0; 
....................  
....................  
....................  
....................  
.................... // These two variables are for the NEWSERIAL, SERIAL commands in the Logo VM 
.................... unsigned char gblMostRecentlyReceivedByte; 
.................... int1 gblNewByteHasArrivedFlag = 0; 
....................  
....................  
....................  
.................... int1 gblLogoIsRunning = 0;     // flags if logo procedures are runing 
.................... int1 gblButtonPressed = 0;    // flags when the run button is pressed 
.................... int1 gblBtn1AlreadyPressed = 0; 
.................... unsigned int16 gblWaitCounter =0;  // used for the wait cmd in Logo vm 
....................  
....................  
.................... unsigned int16 gblTimer = 0;   // This is the timer for the TIMER and RESETT commands 
....................  
.................... int gblCmdTimeOut = 0; // counter to make sure the command state is not stuck somewhere 
....................  
.................... int gblSerialBuffer[SERIAL_BUFFER_SIZE]; 
.................... int gblSerialBufferPutIndex=0; 
.................... int gblSerialBufferGetIndex=0; 
.................... int gblSerialBufferIsFull=FALSE; 
....................  
.................... ////////////////////////////////////////////////////////// 
.................... // I2C add-on display module variables 
.................... ////////////////////////////////////////////////////////// 
....................  
.................... int gblTimeToProbeDisplayModule = 0; 
.................... int1 gblDisplayPresent = 0; 
.................... int gblTimeToSendSensorValues = 0; 
.................... int gblDisplayAddress = 0;   // the gogo will auto detect any connected display 
.................... int gblDisplayAddressList[4] = {DISPLAY_7SEG_ADDR_1, DISPLAY_7SEG_ADDR_2, DISPLAY_LCD_ADDR_1, DISPLAY_LCD_ADDR_2}; // All the possible display addresses 
....................                                                 // 0xB0 = 7-segment #1 
....................                                                 // 0xB2 = 7-segment #2 
....................                                                 // 0xB4 = LCD #1 
....................                                                 // 0xB6 = LCD #2 
.................... int1 gblAutoDetectDisplays = 1; // flag indication whether or not we should auto detect displays 
....................                                 // This flag will be off when a user explicitly addresses a  
....................                                 // display module in the Logo code. It will be reset only after 
....................                                 // a re-boot. 
....................  
.................... int1 gblI2CisBusy = 0; 
....................  
.................... ////////////////////////////////////////////////////////// 
.................... // IR variables 
.................... ////////////////////////////////////////////////////////// 
....................  
.................... int16 gblIRCode = 0;       // holds the most recently recived IR Code 
.................... int16 gblIRCodeTemp = 0 ;  // work variable 
.................... int1 gblCCP2_FE = 1;       // flag to determine a Falling Edge event 
.................... int16 gblREPulseTimeStamp=0; 
.................... int gblIRPulseCount = 0;  // identifies the current pulse # 
.................... //int16 gblIRLog[13] = {0}; 
.................... int1 gblIRActivity = 1;  // indicate that there has been an IR activity. 
....................                          // Timer3's ISR uses this flag to determine when 
....................                          // an IR transmission is complete 
.................... int16 gblPrevIR;         // records the prev IR code 
.................... int IRThreashold=0;    
.................... int1 gblNewIRCodeHasArrivedFlag=0;  // flag used in the Logo VM 
....................  
.................... int1 gblNeedToBeep=0;   // flag telling the main loop to beep. Use to indicate 
....................                         // when logo procedure download is done. 
.................... int1 gblPauseI2CActivity = 0;  // when true-> all display i2c activity is paused 
....................  
....................  
.................... #if defined(__PCH__) 
.................... int gblFlashBuffer[getenv("FLASH_WRITE_SIZE")]; // buffer for flash write operations 
.................... int16 gblFlashOffsetIndex=0; // where in the flash block to write  
.................... int16 gblFlashBaseAddress; // where the flash buffer shuld be written to in the flash mem 
.................... int16 gblFlashBufferCounter = 0;  // counts the number of bytes to write 
.................... #endif 
....................  
.................... int gblCommChannel=COMM_USB; 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   I N T E R R U P T    S E R V I C E    R O U T I N E S 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #int_rda 
.................... void serial_isr(void) 
.................... { 
....................  
....................    if (gblSerialBufferIsFull == FALSE) 
11FE:  MOVLB  2
1200:  MOVF   x43,F
1202:  BNZ   122E
....................    { 
....................       gblSerialBuffer[gblSerialBufferPutIndex] = getchar();          
1204:  CLRF   03
1206:  MOVF   x41,W
1208:  ADDLW  21
120A:  MOVWF  FE9
120C:  MOVLW  02
120E:  ADDWFC 03,W
1210:  MOVWF  FEA
1212:  BTFSS  F9E.5
1214:  BRA    1212
1216:  MOVFF  FAF,FEF
....................       gblSerialBufferPutIndex++; 
121A:  INCF   x41,F
....................       if (gblSerialBufferPutIndex >= SERIAL_BUFFER_SIZE) 
121C:  MOVF   x41,W
121E:  SUBLW  1F
1220:  BC    1224
....................          gblSerialBufferPutIndex = 0;    
1222:  CLRF   x41
....................        
....................       if (gblSerialBufferPutIndex == gblSerialBufferGetIndex) 
1224:  MOVF   x42,W
1226:  SUBWF  x41,W
1228:  BNZ   122E
....................          gblSerialBufferIsFull = TRUE; 
122A:  MOVLW  01
122C:  MOVWF  x43
....................       
....................    } 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
122E:  BCF    F9E.5
1230:  MOVLB  0
1232:  GOTO   00A8
.................... #int_rtcc                           
.................... void rtccISR() {                       
....................  
....................  
....................       set_rtcc(T0_COUNTER);  // this is to keep the interrupt period constant  
130C:  MOVLW  DB
130E:  MOVWF  FD7
1310:  MOVLW  61
1312:  MOVWF  FD6
....................  
....................       gblTimer++;  // increase the global timer 
1314:  MOVLB  2
1316:  INCF   x1E,F
1318:  BTFSC  FD8.2
131A:  INCF   x1F,F
....................  
....................       // if the board is receiving a command from a computer 
....................       // then increase the timeout counter 
....................       if (CMD_STATE != WAITING_FOR_FIRST_HEADER) { 
131C:  MOVLB  1
131E:  DECFSZ xCA,W
1320:  BRA    1324
1322:  BRA    1328
....................          gblCmdTimeOut++;  // Command timout counter. Used at the end of main() 
1324:  MOVLB  2
1326:  INCF   x20,F
....................       } 
....................  
....................       // the Wait opcode sets gblWaitCounter, 
....................       // then waits until it gets to 0. 
....................       if (gblWaitCounter > 0) { gblWaitCounter--; } 
1328:  MOVLB  2
132A:  MOVF   x1C,F
132C:  BNZ   1332
132E:  MOVF   x1D,F
1330:  BZ    133A
1332:  MOVF   x1C,W
1334:  BTFSC  FD8.2
1336:  DECF   x1D,F
1338:  DECF   x1C,F
....................  
....................  
....................       //////////////////////////////////////////// 
....................       // check menu button (button 1) 
....................       // if it is pressed 
....................       if (input(RUN_BUTTON) == 0) { 
133A:  BTFSC  F81.0
133C:  BRA    1350
....................             // if button not already pressed 
....................             if ( gblBtn1AlreadyPressed) { 
133E:  BTFSS  x0A.4
1340:  BRA    1344
....................                // do nothing if button press has been processed before 
....................             } else { 
1342:  BRA    134E
....................                gblButtonPressed = !gblButtonPressed; 
1344:  BTG    x0A.3
....................                gblBtn1AlreadyPressed=1; 
1346:  BSF    x0A.4
....................                 
....................                startStopLogoProcedures(); 
1348:  MOVLB  0
134A:  RCALL  127A
134C:  MOVLB  2
....................                 
....................               //////////////////////////////////////////////////////// 
....................  
....................             }  
....................       } else if (gblBtn1AlreadyPressed) { 
134E:  BRA    1356
1350:  BTFSS  x0A.4
1352:  BRA    1356
....................          gblBtn1AlreadyPressed=0; 
1354:  BCF    x0A.4
....................       } 
....................  
....................       // tells main() to check if the display module is connected every 1 second 
....................       gblTimeToProbeDisplayModule++;                                
1356:  INCF   x44,F
....................  
.................... } 
....................  
....................  
.................... // Timer1 contains the motor PWM signal algorithm 
....................  
1358:  BCF    FF2.2
135A:  MOVLB  0
135C:  GOTO   00A8
.................... #int_timer1 
.................... void timer1ISR() { 
....................  
....................    int associatedPorts; 
....................    int i; 
....................     
....................    //////////////////////////////////////////////////////////////////////////// 
....................    // If this interrupt has taken place at the end of a PWM pulse. Thus, we need 
....................    // to put these pulses "low"  
....................    //////////////////////////////////////////////////////////////////////////// 
....................     
....................    if (gblPWMVectorIndexCounter < gblPWMVectorLen) { 
13EE:  MOVLB  2
13F0:  MOVF   x17,W
13F2:  SUBWF  x1A,W
13F4:  BTFSC  FD8.0
13F6:  BRA    14FE
....................       // cache array val in a normal variable 
....................       associatedPorts = gblPWMVectorPorts[gblPWMVectorIndexCounter]; 
13F8:  CLRF   03
13FA:  MOVF   x1A,W
13FC:  ADDLW  13
13FE:  MOVWF  FE9
1400:  MOVLW  02
1402:  ADDWFC 03,W
1404:  MOVWF  FEA
1406:  MOVFF  FEF,A4A
....................       for (i=0 ; i<MotorCount ; i++) { 
140A:  MOVLB  A
140C:  CLRF   x4B
140E:  MOVF   x4B,W
1410:  SUBLW  03
1412:  BNC   14C0
....................          if (getBit(associatedPorts, i)) { 
1414:  MOVFF  A4A,A4C
1418:  MOVFF  A4B,A4D
141C:  MOVLB  0
141E:  RCALL  1360
1420:  MOVF   01,F
1422:  BZ    14BA
....................             if (getBit(gblMotorONOFF, i) == ON) { 
1424:  MOVFF  1FF,A4C
1428:  MOVFF  A4B,A4D
142C:  RCALL  1360
142E:  DECFSZ 01,W
1430:  BRA    14BA
....................                if (getBit(gblMotorMode, i) == MOTOR_NORMAL) { 
1432:  MOVFF  1FC,A4C
1436:  MOVFF  A4B,A4D
143A:  RCALL  1360
143C:  MOVF   01,F
143E:  BNZ   1492
....................                      setLow(MotorCWPins[i]); 
1440:  BCF    FD8.0
1442:  MOVLB  A
1444:  RLCF   x4B,W
1446:  CLRF   03
1448:  ADDLW  BA
144A:  MOVWF  FE9
144C:  MOVLW  01
144E:  ADDWFC 03,W
1450:  MOVWF  FEA
1452:  MOVFF  FEC,A4D
1456:  MOVF   FED,F
1458:  MOVFF  FEF,A4C
145C:  MOVFF  A4D,A4F
1460:  MOVFF  A4C,A4E
1464:  MOVLB  0
1466:  RCALL  13C0
....................                      setLow(MotorCCPins[i]); 
1468:  BCF    FD8.0
146A:  MOVLB  A
146C:  RLCF   x4B,W
146E:  CLRF   03
1470:  ADDLW  C2
1472:  MOVWF  FE9
1474:  MOVLW  01
1476:  ADDWFC 03,W
1478:  MOVWF  FEA
147A:  MOVFF  FEC,A4D
147E:  MOVF   FED,F
1480:  MOVFF  FEF,A4C
1484:  MOVFF  A4D,A4F
1488:  MOVFF  A4C,A4E
148C:  MOVLB  0
148E:  RCALL  13C0
....................                } 
....................                // this is the servo mode 
....................                else 
1490:  BRA    14BA
....................                   setLow(MotorCCPins[i]); 
1492:  BCF    FD8.0
1494:  MOVLB  A
1496:  RLCF   x4B,W
1498:  CLRF   03
149A:  ADDLW  C2
149C:  MOVWF  FE9
149E:  MOVLW  01
14A0:  ADDWFC 03,W
14A2:  MOVWF  FEA
14A4:  MOVFF  FEC,A4D
14A8:  MOVF   FED,F
14AA:  MOVFF  FEF,A4C
14AE:  MOVFF  A4D,A4F
14B2:  MOVFF  A4C,A4E
14B6:  MOVLB  0
14B8:  RCALL  13C0
....................             } 
....................          } 
....................       } 
14BA:  MOVLB  A
14BC:  INCF   x4B,F
14BE:  BRA    140E
....................        
....................       /////////////////////////////////////////////// 
....................       // setup for the next interrupt 
....................       /////////////////////////////////////////////// 
....................       if (++gblPWMVectorIndexCounter < gblPWMVectorLen) { 
14C0:  MOVLB  2
14C2:  INCF   x1A,F
14C4:  MOVF   x17,W
14C6:  SUBWF  x1A,W
14C8:  BC    14EE
....................          set_timer1(gblPWMVector[gblPWMVectorIndexCounter]); 
14CA:  BCF    FD8.0
14CC:  RLCF   x1A,W
14CE:  CLRF   03
14D0:  ADDLW  0B
14D2:  MOVWF  FE9
14D4:  MOVLW  02
14D6:  ADDWFC 03,W
14D8:  MOVWF  FEA
14DA:  MOVFF  FEC,A4D
14DE:  MOVF   FED,F
14E0:  MOVFF  FEF,A4C
14E4:  MOVFF  A4D,FCF
14E8:  MOVFF  A4C,FCE
....................       } else { 
14EC:  BRA    14FC
....................          set_timer1(gblPWMTerminatingVector); 
14EE:  MOVFF  219,FCF
14F2:  MOVFF  218,FCE
....................          gblAtEndOfPWMCycle = 1;  // notify main loop that we have reached the end 
14F6:  MOVLB  0
14F8:  BSF    x7F.7
14FA:  MOVLB  2
....................                                   // of a PWM cycle. It can make changes to the  
....................                                   // PWM vectors if needed (without disrupting  
....................                                   // the PWM pulses) 
....................       } 
....................        
....................    }  
....................  
....................    ///////////////////////////////////////////////////////////// 
....................    //  Else then this interrupt is at the beginning of a new PWM pulse 
....................    //  Thus, we need to put all the pulses "high" 
....................    ///////////////////////////////////////////////////////////// 
....................  
....................  
....................    else { 
14FC:  BRA    170C
....................          gblAtEndOfPWMCycle = 0; 
14FE:  MOVLB  0
1500:  BCF    x7F.7
....................  
....................          for (i=0 ; i<MotorCount ; i++)  { 
1502:  MOVLB  A
1504:  CLRF   x4B
1506:  MOVF   x4B,W
1508:  SUBLW  03
150A:  BTFSS  FD8.0
150C:  BRA    16EE
....................             if (getBit(gblMotorONOFF, i) == ON) { 
150E:  MOVFF  1FF,A4C
1512:  MOVFF  A4B,A4D
1516:  MOVLB  0
1518:  RCALL  1360
151A:  DECFSZ 01,W
151C:  BRA    1698
....................                //if (i==0) { output_high(USER_LED); } else {output_low(USER_LED);} 
....................                if (gblMtrDuty[i] > 0) { 
151E:  CLRF   03
1520:  MOVLB  A
1522:  MOVFF  A4B,FE9
1526:  MOVLW  02
1528:  ADDWF  03,W
152A:  MOVWF  FEA
152C:  MOVF   FEF,F
152E:  BTFSC  FD8.2
1530:  BRA    1648
....................                   if (getBit(gblMotorMode, i) == MOTOR_NORMAL) { 
1532:  MOVFF  1FC,A4C
1536:  MOVFF  A4B,A4D
153A:  MOVLB  0
153C:  RCALL  1360
153E:  MOVF   01,F
1540:  BNZ   15F4
....................                      if (getBit(gblMotorDir, i)) { 
1542:  MOVFF  1FE,A4C
1546:  MOVFF  A4B,A4D
154A:  RCALL  1360
154C:  MOVF   01,F
154E:  BZ    15A2
....................                         setHigh(MotorCWPins[i]); 
1550:  BCF    FD8.0
1552:  MOVLB  A
1554:  RLCF   x4B,W
1556:  CLRF   03
1558:  ADDLW  BA
155A:  MOVWF  FE9
155C:  MOVLW  01
155E:  ADDWFC 03,W
1560:  MOVWF  FEA
1562:  MOVFF  FEC,A4D
1566:  MOVF   FED,F
1568:  MOVFF  FEF,A4C
156C:  MOVFF  A4D,A4F
1570:  MOVFF  A4C,A4E
1574:  MOVLB  0
1576:  RCALL  13D6
....................                         setLow(MotorCCPins[i]); 
1578:  BCF    FD8.0
157A:  MOVLB  A
157C:  RLCF   x4B,W
157E:  CLRF   03
1580:  ADDLW  C2
1582:  MOVWF  FE9
1584:  MOVLW  01
1586:  ADDWFC 03,W
1588:  MOVWF  FEA
158A:  MOVFF  FEC,A4D
158E:  MOVF   FED,F
1590:  MOVFF  FEF,A4C
1594:  MOVFF  A4D,A4F
1598:  MOVFF  A4C,A4E
159C:  MOVLB  0
159E:  RCALL  13C0
....................                      } else { 
15A0:  BRA    15F2
.................... //                        if (i == 0) { 
....................                            setHigh(MotorCCPins[i]); 
15A2:  BCF    FD8.0
15A4:  MOVLB  A
15A6:  RLCF   x4B,W
15A8:  CLRF   03
15AA:  ADDLW  C2
15AC:  MOVWF  FE9
15AE:  MOVLW  01
15B0:  ADDWFC 03,W
15B2:  MOVWF  FEA
15B4:  MOVFF  FEC,A4D
15B8:  MOVF   FED,F
15BA:  MOVFF  FEF,A4C
15BE:  MOVFF  A4D,A4F
15C2:  MOVFF  A4C,A4E
15C6:  MOVLB  0
15C8:  RCALL  13D6
....................                            setLow(MotorCWPins[i]); 
15CA:  BCF    FD8.0
15CC:  MOVLB  A
15CE:  RLCF   x4B,W
15D0:  CLRF   03
15D2:  ADDLW  BA
15D4:  MOVWF  FE9
15D6:  MOVLW  01
15D8:  ADDWFC 03,W
15DA:  MOVWF  FEA
15DC:  MOVFF  FEC,A4D
15E0:  MOVF   FED,F
15E2:  MOVFF  FEF,A4C
15E6:  MOVFF  A4D,A4F
15EA:  MOVFF  A4C,A4E
15EE:  MOVLB  0
15F0:  RCALL  13C0
.................... //                        } 
....................                      } 
....................                   } 
....................                   // this is the servo mode 
....................                   else { 
15F2:  BRA    1644
....................                      setHigh(MotorCCPins[i]);  // this is the servo pulse pin 
15F4:  BCF    FD8.0
15F6:  MOVLB  A
15F8:  RLCF   x4B,W
15FA:  CLRF   03
15FC:  ADDLW  C2
15FE:  MOVWF  FE9
1600:  MOVLW  01
1602:  ADDWFC 03,W
1604:  MOVWF  FEA
1606:  MOVFF  FEC,A4D
160A:  MOVF   FED,F
160C:  MOVFF  FEF,A4C
1610:  MOVFF  A4D,A4F
1614:  MOVFF  A4C,A4E
1618:  MOVLB  0
161A:  RCALL  13D6
....................                      setHigh(MotorCWPins[i]);  // this is the servo powor pin 
161C:  BCF    FD8.0
161E:  MOVLB  A
1620:  RLCF   x4B,W
1622:  CLRF   03
1624:  ADDLW  BA
1626:  MOVWF  FE9
1628:  MOVLW  01
162A:  ADDWFC 03,W
162C:  MOVWF  FEA
162E:  MOVFF  FEC,A4D
1632:  MOVF   FED,F
1634:  MOVFF  FEF,A4C
1638:  MOVFF  A4D,A4F
163C:  MOVFF  A4C,A4E
1640:  MOVLB  0
1642:  RCALL  13D6
....................                   } 
....................                }  
....................                // force both CC, CW pins low if power is 0 
....................                // this is just in case something has accidentally 
....................                // cased any pin to go high 
....................                else { 
1644:  BRA    1696
1646:  MOVLB  A
....................                   setLow(MotorCWPins[i]); 
1648:  BCF    FD8.0
164A:  RLCF   x4B,W
164C:  CLRF   03
164E:  ADDLW  BA
1650:  MOVWF  FE9
1652:  MOVLW  01
1654:  ADDWFC 03,W
1656:  MOVWF  FEA
1658:  MOVFF  FEC,A4D
165C:  MOVF   FED,F
165E:  MOVFF  FEF,A4C
1662:  MOVFF  A4D,A4F
1666:  MOVFF  A4C,A4E
166A:  MOVLB  0
166C:  RCALL  13C0
....................                   setLow(MotorCCPins[i]); 
166E:  BCF    FD8.0
1670:  MOVLB  A
1672:  RLCF   x4B,W
1674:  CLRF   03
1676:  ADDLW  C2
1678:  MOVWF  FE9
167A:  MOVLW  01
167C:  ADDWFC 03,W
167E:  MOVWF  FEA
1680:  MOVFF  FEC,A4D
1684:  MOVF   FED,F
1686:  MOVFF  FEF,A4C
168A:  MOVFF  A4D,A4F
168E:  MOVFF  A4C,A4E
1692:  MOVLB  0
1694:  RCALL  13C0
....................                } 
....................             } else {  // turn motors off here 
1696:  BRA    16E8
....................               setLow(MotorCWPins[i]); 
1698:  BCF    FD8.0
169A:  MOVLB  A
169C:  RLCF   x4B,W
169E:  CLRF   03
16A0:  ADDLW  BA
16A2:  MOVWF  FE9
16A4:  MOVLW  01
16A6:  ADDWFC 03,W
16A8:  MOVWF  FEA
16AA:  MOVFF  FEC,A4D
16AE:  MOVF   FED,F
16B0:  MOVFF  FEF,A4C
16B4:  MOVFF  A4D,A4F
16B8:  MOVFF  A4C,A4E
16BC:  MOVLB  0
16BE:  RCALL  13C0
....................               setLow(MotorCCPins[i]); 
16C0:  BCF    FD8.0
16C2:  MOVLB  A
16C4:  RLCF   x4B,W
16C6:  CLRF   03
16C8:  ADDLW  C2
16CA:  MOVWF  FE9
16CC:  MOVLW  01
16CE:  ADDWFC 03,W
16D0:  MOVWF  FEA
16D2:  MOVFF  FEC,A4D
16D6:  MOVF   FED,F
16D8:  MOVFF  FEF,A4C
16DC:  MOVFF  A4D,A4F
16E0:  MOVFF  A4C,A4E
16E4:  MOVLB  0
16E6:  RCALL  13C0
....................             } 
....................  
....................              
....................          } 
16E8:  MOVLB  A
16EA:  INCF   x4B,F
16EC:  BRA    1506
....................        
....................        
....................       if (gblPWMVectorLen > 0) { 
16EE:  MOVLB  2
16F0:  MOVF   x17,F
16F2:  BZ    1700
....................  
....................          /////////////////////////////////////////////// 
....................          // setup for the next interrupt 
....................          ////////////////////////////////////////////// 
....................          gblPWMVectorIndexCounter = 0; 
16F4:  CLRF   x1A
....................          set_timer1(gblPWMVector[0]); 
16F6:  MOVFF  20C,FCF
16FA:  MOVFF  20B,FCE
....................        
....................       
....................       } else {  // PWM is not in use -> keep interrupt rate = PWM Period 
16FE:  BRA    170C
....................          set_timer1(PWM_PERIOD); 
1700:  MOVLW  69
1702:  MOVWF  FCF
1704:  SETF   FCE
....................          gblAtEndOfPWMCycle = 1; // needed to make this flag work when no PWM is active 
1706:  MOVLB  0
1708:  BSF    x7F.7
170A:  MOVLB  2
....................       } 
....................  
....................  
....................    } 
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... // timer2 is neccessary for the PIC's hardware PWM (which drives the beeper) 
170C:  BCF    F9E.0
170E:  MOVLB  0
1710:  GOTO   00A8
.................... #int_timer2 
.................... void timer2ISR() { 
....................    gblBurstModeTimerHasTicked=1;  // this triggers the slow burst mode to send data. See DoSensorStuff() 
17AE:  BSF    x7F.5
....................  
....................    gblTimeToSendSensorValues++; // signal main() to send sensor data to the diaply module 
17B0:  MOVLB  2
17B2:  INCF   x45,F
....................     
....................    showNextDigit(); 
17B4:  MOVLB  0
17B6:  BRA    1728
....................    
.................... } 
....................  
.................... // timer3 interrupt is fired only when no IR pulses have been received (end of transmission) 
17B8:  BCF    F9E.1
17BA:  GOTO   00A8
.................... #int_timer3 
.................... void timer3ISR() { 
....................     
....................    // if no IR Activity in the past timer3 period -> assume IR data is done 
....................    if (!gblIRActivity) { 
17BE:  MOVLB  2
17C0:  BTFSC  x4F.1
17C2:  BRA    17EA
....................       // only update if a new value has arrived 
....................       if (gblIRCodeTemp != 0) { 
17C4:  MOVF   x4D,F
17C6:  BNZ   17CC
17C8:  MOVF   x4E,F
17CA:  BZ    17DA
....................          gblIRCode = gblIRCodeTemp; 
17CC:  MOVFF  24E,24C
17D0:  MOVFF  24D,24B
....................          gblIRCodeTemp = 0; 
17D4:  CLRF   x4E
17D6:  CLRF   x4D
....................          gblNewIRCodeHasArrivedFlag = 1;  // this flag is used in the Logo VM 
17D8:  BSF    x4F.2
....................       } 
....................  
....................       // if time has passed with no activity -> reset gblPrevIRCode so that it 
....................       // recognizes any incoming IR Code as a new event (even if it is the same 
....................       // code as before). 
....................       if (IRThreashold++ > 50) { 
17DA:  MOVF   x55,W
17DC:  INCF   x55,F
17DE:  SUBLW  32
17E0:  BC    17E8
....................          gblPrevIR = 0; 
17E2:  CLRF   x54
17E4:  CLRF   x53
....................          IRThreashold = 0; 
17E6:  CLRF   x55
....................       } 
....................  
....................    } else { 
17E8:  BRA    1810
....................       // if there is IR activity -> check for special purpose codes 
....................        
....................       if (gblPrevIR != gblIRCode) { 
17EA:  MOVF   x4B,W
17EC:  SUBWF  x53,W
17EE:  BNZ   17F6
17F0:  MOVF   x4C,W
17F2:  SUBWF  x54,W
17F4:  BZ    1810
....................           
....................          if (gblIRCode == 149 ) {   // ON/OFF button -> run/stop Logo procedures 
17F6:  MOVF   x4B,W
17F8:  SUBLW  95
17FA:  BNZ   1806
17FC:  MOVF   x4C,F
17FE:  BNZ   1806
....................             startStopLogoProcedures(); 
1800:  MOVLB  0
1802:  RCALL  127A
1804:  MOVLB  2
....................          } 
....................           
....................          gblPrevIR = gblIRCode; // to prevent re-entrance 
1806:  MOVFF  24C,254
180A:  MOVFF  24B,253
....................          IRThreashold = 0;  
180E:  CLRF   x55
....................       } 
....................    } 
....................    gblIRActivity = 0; 
1810:  BCF    x4F.1
.................... } 
....................  
....................  
1812:  BCF    FA1.1
1814:  MOVLB  0
1816:  GOTO   00A8
.................... #int_ccp2 
.................... void ccp2_isr() { 
....................  
.................... //  Captures IR pulses 
.................... // 
.................... //  For a SONY remote: 
.................... // 
.................... //  Logic 0 = 0.6ms high + 0.6ms low 
.................... //  Logic 1 = 1.2ms high + 0.6ms low 
.................... //  Start Bit = 2.4ms high + 0.6ms low 
.................... // 
.................... //  Note that the IR sensor on the board inverts the logic above! 
.................... // 
.................... //  commands are transmitted every 45 ms (from start to start) when the 
.................... //  remote button is held pressed. 
....................  
....................  
....................    int16 pulseWidth; 
....................  
....................    gblIRActivity = 1;  // indicate that there has been an IR activity. 
181A:  MOVLB  2
181C:  BSF    x4F.1
....................                        // Timer3's ISR uses this flag to determine when 
....................                        // an IR transmission is complete 
....................  
....................    // If a falling edge event occured, We will timestamp the CCP_2 value 
....................    // and configure CCP2 to interrupt again at the raising edge. 
....................    if (gblCCP2_FE) { 
181E:  BTFSS  x4F.0
1820:  BRA    1838
....................        
....................       setup_ccp2( CCP_CAPTURE_RE); 
1822:  CLRF   FB6
1824:  MOVLW  05
1826:  MOVWF  FB6
1828:  CLRF   FB9
182A:  CLRF   FBA
....................       gblCCP2_FE = 0; 
182C:  BCF    x4F.0
....................        
....................       gblREPulseTimeStamp = CCP_2; 
182E:  MOVFF  FB8,251
1832:  MOVFF  FB7,250
....................        
....................     
....................    } else { 
1836:  BRA    18EC
....................       // A rising edge event occured. We calculate the pulse width to 
....................       // determine a bit 0 or bit 1.  
....................  
....................       setup_ccp2( CCP_CAPTURE_FE); 
1838:  CLRF   FB6
183A:  MOVLW  04
183C:  MOVWF  FB6
183E:  CLRF   FB9
1840:  CLRF   FBA
....................       gblCCP2_FE = 1; 
1842:  BSF    x4F.0
....................     
....................       if (CCP_2 > gblREPulseTimeStamp)  // this is the normal case  
1844:  MOVF   x51,W
1846:  SUBWF  FB8,W
1848:  BNC   1868
184A:  BNZ   1852
184C:  MOVF   FB7,W
184E:  SUBWF  x50,W
1850:  BC    1868
....................          pulseWidth = CCP_2 - gblREPulseTimeStamp; 
1852:  MOVF   x50,W
1854:  SUBWF  FB7,W
1856:  MOVLB  A
1858:  MOVWF  x4A
185A:  MOVLB  2
185C:  MOVF   x51,W
185E:  SUBWFB FB8,W
1860:  MOVLB  A
1862:  MOVWF  x4B
....................       else  // this means time3 has wrapped around 
1864:  BRA    1888
1866:  MOVLB  2
....................          pulseWidth = 65535 - gblREPulseTimeStamp + CCP_2; 
1868:  MOVLW  FF
186A:  BSF    FD8.0
186C:  SUBFWB x50,W
186E:  MOVLB  A
1870:  MOVWF  x4C
1872:  MOVLW  FF
1874:  MOVLB  2
1876:  SUBFWB x51,W
1878:  MOVLB  A
187A:  MOVWF  x4D
187C:  MOVF   FB7,W
187E:  ADDWF  x4C,W
1880:  MOVWF  x4A
1882:  MOVF   FB8,W
1884:  ADDWFC x4D,W
1886:  MOVWF  x4B
....................        
....................       //gblIRLog[gblIRPulseCount] = pulseWidth; 
....................        
....................  
....................       if (pulseWidth < 3000) { 
1888:  MOVF   x4B,W
188A:  SUBLW  0B
188C:  BNC   18A2
188E:  BNZ   1896
1890:  MOVF   x4A,W
1892:  SUBLW  B7
1894:  BNC   18A2
....................          // ignore short pulses -> probably noise 
....................          gblIRCodeTemp = 0; 
1896:  MOVLB  2
1898:  CLRF   x4E
189A:  CLRF   x4D
....................          gblIRPulseCount = 0; 
189C:  CLRF   x52
....................          
....................       } else if (pulseWidth < 5000) {  // Logic 0 
189E:  BRA    18EC
18A0:  MOVLB  A
18A2:  MOVF   x4B,W
18A4:  SUBLW  13
18A6:  BNC   18B8
18A8:  BNZ   18B0
18AA:  MOVF   x4A,W
18AC:  SUBLW  87
18AE:  BNC   18B8
....................                                        // theoretical pulse count is 3600 (0.6 ms) 
....................                                        // actual pulses from test hovers just above 4000 
....................          // just increase the counter 
....................          gblIRPulseCount++; 
18B0:  MOVLB  2
18B2:  INCF   x52,F
....................  
....................       } else if (pulseWidth < 9000) {  // Logic 1 
18B4:  BRA    18EC
18B6:  MOVLB  A
18B8:  MOVF   x4B,W
18BA:  SUBLW  23
18BC:  BNC   18E4
18BE:  BNZ   18C6
18C0:  MOVF   x4A,W
18C2:  SUBLW  27
18C4:  BNC   18E4
....................                                        // theoretical pulse count is 7200 (1.2 ms) 
....................                                        // actual pulses from test hovers around 7600 
....................        
....................          // set the bit  
....................          gblIRCodeTemp |= (1 << gblIRPulseCount); 
18C6:  MOVLW  01
18C8:  MOVWF  00
18CA:  MOVLB  2
18CC:  MOVF   x52,W
18CE:  MOVWF  01
18D0:  BZ    18DA
18D2:  BCF    FD8.0
18D4:  RLCF   00,F
18D6:  DECFSZ 01,F
18D8:  BRA    18D2
18DA:  MOVF   00,W
18DC:  IORWF  x4D,F
....................          gblIRPulseCount++; 
18DE:  INCF   x52,F
....................  
....................       }   else { 
18E0:  BRA    18EC
18E2:  MOVLB  A
....................          // a long pulse is marks the beginning of a new IR transmission 
....................          gblIRCodeTemp = 0; 
18E4:  MOVLB  2
18E6:  CLRF   x4E
18E8:  CLRF   x4D
....................          gblIRPulseCount = 0; 
18EA:  CLRF   x52
....................       } 
....................        
....................     
....................    } 
....................  
....................  
....................  
.................... } 
....................  
.................... /* 
.................... #INT_LOWVOLT 
.................... void lowVoltISR() { 
....................    stopLogoProcedures(); 
.................... } 
.................... */ 
....................  
18EC:  BCF    FA1.0
18EE:  MOVLB  0
18F0:  GOTO   00A8
.................... void stopLogoProcedures(void) { 
....................  
.................... //      output_toggle(USER_LED); 
.................... //      disable_interrupts(GLOBAL);     // why do this?? 
....................  
....................       gblWaitCounter = 0;  // reset wait command (so the running Logo wait code 
1262:  MOVLB  2
1264:  CLRF   x1D
1266:  CLRF   x1C
....................                            // stops immediately). 
....................       gblONFORNeedsToFinish = 0; // incase an onfor is running. 
1268:  MOVLB  0
126A:  BCF    x7F.1
....................       gblLogoIsRunning = 0; 
126C:  MOVLB  2
126E:  BCF    x0A.2
....................       flgNeedToTurnOffAllMotors=1;  // tell the main loop to turn off the motors 
1270:  BSF    x0A.0
....................       cls_internal7Seg();   // clear the internal 7-segment's screen 
1272:  MOVLB  0
1274:  RCALL  1254
....................  
....................       output_low(RUN_LED); 
1276:  BCF    F8B.1
.................... } 
1278:  RETURN 0
....................  
....................  
....................  
....................  
.................... void startStopLogoProcedures(void) { 
....................  
....................       gblWaitCounter = 0;  // reset wait command (so the running Logo wait code 
127A:  MOVLB  2
127C:  CLRF   x1D
127E:  CLRF   x1C
....................                            // stops immediately). 
....................       gblONFORNeedsToFinish = 0; // incase an onfor is running. 
1280:  MOVLB  0
1282:  BCF    x7F.1
....................  
....................  
....................      //////////////////////////////////////////////////////// 
....................      // run Logo procedures 
....................      if (!gblLogoIsRunning) 
1284:  MOVLB  2
1286:  BTFSC  x0A.2
1288:  BRA    1302
....................      { 
....................          srand(gblTimer);  // seed for the random function; 
128A:  MOVLB  A
128C:  CLRF   x4D
128E:  CLRF   x4C
1290:  MOVFF  21F,A4B
1294:  MOVFF  21E,A4A
1298:  MOVLB  0
129A:  RCALL  1236
....................          //ms1test 
....................          //output_high(RUN_LED); 
....................          output_high(RUN_LED); 
129C:  BSF    F8B.1
....................          ///////////////////////////////////////////////// 
....................          //   get the address of the procedure 
....................          //   to run. 
....................  
....................          // gblMemPtr is defined in eeprom.h 
.................... //                  gblMemPtr = read_program_eeprom(RUN_BUTTON_BASE_ADDRESS) << 8; 
.................... //                  gblMemPtr += read_program_eeprom(RUN_BUTTON_BASE_ADDRESS+1); 
....................  
....................         #if defined(__PCM__) 
....................          gblMemPtr = read_program_eeprom(RUN_BUTTON_BASE_ADDRESS+1); 
....................         #elif defined (__PCH__) 
....................          //gblMemPtr = read_program_eeprom( (RUN_BUTTON_BASE_ADDRESS+1)<<1 ); 
....................          gblMemPtr = (read_program_eeprom( RUN_BUTTON_BASE_ADDRESS ) << 8) + read_program_eeprom( (RUN_BUTTON_BASE_ADDRESS+2) ); 
129E:  MOVFF  FF2,A4A
12A2:  BCF    FF2.7
12A4:  CLRF   FF8
12A6:  MOVLW  F9
12A8:  MOVWF  FF7
12AA:  MOVLW  E0
12AC:  MOVWF  FF6
12AE:  TBLRD*+
12B0:  MOVF   FF5,W
12B2:  TBLRD*
12B4:  MOVFF  FF5,03
12B8:  CLRF   FF8
12BA:  MOVLB  A
12BC:  BTFSC  x4A.7
12BE:  BSF    FF2.7
12C0:  MOVWF  x4A
12C2:  MOVWF  x4B
12C4:  CLRF   x4A
12C6:  MOVFF  FF2,A4C
12CA:  BCF    FF2.7
12CC:  CLRF   FF8
12CE:  MOVLW  F9
12D0:  MOVWF  FF7
12D2:  MOVLW  E2
12D4:  MOVWF  FF6
12D6:  TBLRD*+
12D8:  MOVF   FF5,W
12DA:  TBLRD*
12DC:  MOVFF  FF5,03
12E0:  CLRF   FF8
12E2:  BTFSC  x4C.7
12E4:  BSF    FF2.7
12E6:  ADDWF  x4A,W
12E8:  MOVLB  1
12EA:  MOVWF  xAB
12EC:  MOVF   03,W
12EE:  MOVLB  A
12F0:  ADDWFC x4B,W
12F2:  MOVLB  1
12F4:  MOVWF  xAC
.................... //         gblMemPtr = gblMemPtr << 1; 
....................           
....................         
....................         #endif 
....................  
....................          clearStack(); 
12F6:  MOVLB  0
12F8:  RCALL  1248
....................          gblNewByteHasArrivedFlag=0; 
12FA:  MOVLB  2
12FC:  BCF    x0A.1
....................          gblLogoIsRunning = 1; 
12FE:  BSF    x0A.2
....................       } else {  // stop Logo 
1300:  BRA    1308
....................          stopLogoProcedures(); 
1302:  MOVLB  0
1304:  RCALL  1262
1306:  MOVLB  2
....................       } 
....................  
.................... } 
1308:  MOVLB  0
130A:  RETURN 0
....................  
....................  
....................  
.................... void setLow(IOPointer Pin) 
.................... { 
.................... //   *(Pin>>3) &= (~(1<<(Pin&7))); 
....................    output_bit(Pin, 0); 
13C0:  MOVFF  A4E,A50
13C4:  MOVLB  A
13C6:  CLRF   x51
13C8:  MOVLW  0F
13CA:  MOVWF  x53
13CC:  MOVLW  89
13CE:  MOVWF  x52
13D0:  MOVLB  0
13D2:  RCALL  137E
.................... } 
13D4:  RETURN 0
....................  
.................... void setHigh(IOPointer Pin) 
.................... { 
.................... //   *(Pin>>3) |= (1<<(Pin&7)); 
....................    output_bit(Pin, 1); 
13D6:  MOVFF  A4E,A50
13DA:  MOVLW  01
13DC:  MOVLB  A
13DE:  MOVWF  x51
13E0:  MOVLW  0F
13E2:  MOVWF  x53
13E4:  MOVLW  89
13E6:  MOVWF  x52
13E8:  MOVLB  0
13EA:  RCALL  137E
....................  
.................... } 
13EC:  RETURN 0
....................  
....................  
.................... int readPin(IOPointer Pin) 
.................... { 
.................... //   return (*(Pin>>3) & (1<<(Pin&7))) ; 
....................    return (input(Pin)); 
....................  
.................... } 
....................  
....................  
....................  
.................... ////////////////////////////////////////////////// 
.................... short getBit(int InByte, int BitNo) 
.................... {  return ((InByte >> BitNo) & 1); 
1360:  MOVLB  A
1362:  MOVFF  A4C,00
1366:  MOVF   x4D,W
1368:  MOVWF  01
136A:  BZ    1374
136C:  BCF    FD8.0
136E:  RRCF   00,F
1370:  DECFSZ 01,F
1372:  BRA    136C
1374:  MOVF   00,W
1376:  ANDLW  01
1378:  MOVWF  01
.................... } 
137A:  MOVLB  0
137C:  RETURN 0
....................  
.................... void setBit(int *InByte, int BitNo) 
.................... {  *InByte |= (1<<BitNo); 
28EC:  MOVFF  2EB,03
28F0:  MOVLB  2
28F2:  MOVFF  2EA,FE9
28F6:  MOVFF  2EB,FEA
28FA:  MOVLW  01
28FC:  MOVWF  00
28FE:  MOVF   xEC,W
2900:  MOVWF  01
2902:  BZ    290C
2904:  BCF    FD8.0
2906:  RLCF   00,F
2908:  DECFSZ 01,F
290A:  BRA    2904
290C:  MOVF   00,W
290E:  IORWF  FEF,W
2910:  MOVWF  FEF
.................... } 
2912:  MOVLB  0
2914:  RETURN 0
....................  
.................... void clearBit(int *InByte, int BitNo) 
.................... {  *InByte &= ~(1<<BitNo); 
28C0:  MOVFF  2E8,03
28C4:  MOVLB  2
28C6:  MOVFF  2E7,FE9
28CA:  MOVFF  2E8,FEA
28CE:  MOVLW  01
28D0:  MOVWF  00
28D2:  MOVF   xE9,W
28D4:  MOVWF  01
28D6:  BZ    28E0
28D8:  BCF    FD8.0
28DA:  RLCF   00,F
28DC:  DECFSZ 01,F
28DE:  BRA    28D8
28E0:  MOVF   00,W
28E2:  XORLW  FF
28E4:  ANDWF  FEF,W
28E6:  MOVWF  FEF
.................... } 
28E8:  MOVLB  0
28EA:  RETURN 0
....................  
....................  
.................... void active_comm_putc(char c) { 
....................    if (gblCommChannel == COMM_SERIAL) { 
1D06:  MOVLB  2
1D08:  DECFSZ x9C,W
1D0A:  BRA    1D16
....................       putc(c); 
1D0C:  MOVF   xE2,W
1D0E:  MOVLB  0
1D10:  BRA    1C7C
....................    }else if (gblCommChannel == COMM_USB) { 
1D12:  BRA    1D24
1D14:  MOVLB  2
1D16:  MOVF   x9C,W
1D18:  SUBLW  02
1D1A:  BNZ   1D26
....................       usb_cdc_putc(c); 
1D1C:  MOVFF  2E2,2E3
1D20:  MOVLB  0
1D22:  BRA    1CF4
1D24:  MOVLB  2
....................    } 
.................... } 
1D26:  MOVLB  0
1D28:  RETURN 0
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   M O T O R   C O N T R O L 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... void TalkToMotor(int MotorBits) 
.................... { 
....................  
....................    // Each bit represents one motor. i.e 0b00010010 means motor 2 and 5 are active 
....................    gblActiveMotors = MotorBits; 
2C9A:  MOVFF  2E0,1FD
....................  
.................... //   printf("%c%c%c", ReplyHeader1, ReplyHeader2, ACK_BYTE);  // send acknowledge byte 
....................  
.................... } 
2C9E:  RETURN 0
....................  
....................  
.................... void MotorControl(int MotorCmd) 
.................... { 
....................    int i; 
....................  
....................    for (i=0;i<MotorCount;i++) 
2B1C:  MOVLB  2
2B1E:  CLRF   xE1
2B20:  MOVF   xE1,W
2B22:  SUBLW  03
2B24:  BNC   2B98
....................    { 
....................       if ((gblActiveMotors >> i) & 1 ) 
2B26:  MOVFF  1FD,00
2B2A:  MOVLB  2
2B2C:  MOVF   xE1,W
2B2E:  MOVWF  01
2B30:  BZ    2B3A
2B32:  BCF    FD8.0
2B34:  RRCF   00,F
2B36:  DECFSZ 01,F
2B38:  BRA    2B32
2B3A:  MOVF   00,W
2B3C:  ANDLW  01
2B3E:  BZ    2B94
....................       { 
....................          SetMotorMode(MOTOR_NORMAL); 
2B40:  CLRF   xE2
2B42:  MOVLB  0
2B44:  RCALL  2916
....................  
....................          switch (MotorCmd) 
....................          { 
2B46:  MOVLB  2
2B48:  MOVF   xE0,W
2B4A:  ADDLW  FA
2B4C:  BC    2B94
2B4E:  ADDLW  06
2B50:  MOVLB  0
2B52:  GOTO   2B9C
....................          case MTR_ON:   MotorON(i); 
2B56:  MOVFF  2E1,2E2
2B5A:  BRA    2980
....................                break; 
2B5C:  MOVLB  2
2B5E:  BRA    2B94
....................          case MTR_OFF: MotorOFF(i); 
2B60:  MOVFF  2E1,2E2
2B64:  BRA    29A2
....................                break; 
2B66:  MOVLB  2
2B68:  BRA    2B94
....................          case MTR_RD: MotorRD(i); 
2B6A:  MOVFF  2E1,2E2
2B6E:  BRA    2A2C
....................                break; 
2B70:  MOVLB  2
2B72:  BRA    2B94
....................          case MTR_THISWAY: MotorThisWay(i); 
2B74:  MOVFF  2E1,2E2
2B78:  BRA    2A72
....................                break; 
2B7A:  MOVLB  2
2B7C:  BRA    2B94
....................          case MTR_THATWAY: MotorThatWay(i); 
2B7E:  MOVFF  2E1,2E2
2B82:  BRA    2A88
....................                break; 
2B84:  MOVLB  2
2B86:  BRA    2B94
....................          case MTR_COAST: MotorCoast(i); 
2B88:  MOVFF  2E1,2E2
2B8C:  BRA    2AB4
....................                break; 
2B8E:  MOVLB  2
2B90:  BRA    2B94
2B92:  MOVLB  2
....................          } 
....................  
....................       } 
....................    } 
2B94:  INCF   xE1,F
2B96:  BRA    2B20
....................     
....................  
.................... } 
2B98:  MOVLB  0
2B9A:  RETURN 0
....................  
.................... ///////////////////////////////////////////////// 
.................... // Refer to the problem explained in MotorControl() if 
.................... // this function suddenly missbehave 
.................... void SetMotorPower(int Power) 
.................... { 
....................    int i; 
....................  
....................    for (i=0;i<MotorCount;i++) 
2BC2:  MOVLB  2
2BC4:  CLRF   xE3
2BC6:  MOVF   xE3,W
2BC8:  SUBLW  03
2BCA:  BNC   2C6E
....................    { 
....................       if ((gblActiveMotors >> i) & 1 ) 
2BCC:  MOVFF  1FD,00
2BD0:  MOVLB  2
2BD2:  MOVF   xE3,W
2BD4:  MOVWF  01
2BD6:  BZ    2BE0
2BD8:  BCF    FD8.0
2BDA:  RRCF   00,F
2BDC:  DECFSZ 01,F
2BDE:  BRA    2BD8
2BE0:  MOVF   00,W
2BE2:  ANDLW  01
2BE4:  BZ    2C6A
....................       { 
....................  
....................          // Starting from GoGo2.2ms5 and higher, a better implementation of 
....................          // motor PWM has been implemented. Now, the user can 
....................          // control up to 255 power levels (instead of 8).  
....................          // Note: The PWM algorithm has been improved again in GoGo 4.0 ms1 
....................          // But to keep the 
....................          // firmware backward compatible, the first 8 power levels are mapped 
....................          // out evenly between 0-255. 
....................  
....................          switch (Power) { 
2BE6:  MOVLW  01
2BE8:  SUBWF  xE2,W
2BEA:  ADDLW  F9
2BEC:  BC    2C2E
2BEE:  ADDLW  07
2BF0:  MOVLB  0
2BF2:  GOTO   2C72
.................... //            case 0: Power = 0x00; break;  // commented out because values don't change anyway 
....................             case 1: Power = 36; break; 
2BF6:  MOVLW  24
2BF8:  MOVLB  2
2BFA:  MOVWF  xE2
2BFC:  BRA    2C2E
....................             case 2: Power = 73; break; 
2BFE:  MOVLW  49
2C00:  MOVLB  2
2C02:  MOVWF  xE2
2C04:  BRA    2C2E
....................             case 3: Power = 110; break; 
2C06:  MOVLW  6E
2C08:  MOVLB  2
2C0A:  MOVWF  xE2
2C0C:  BRA    2C2E
....................             case 4: Power = 146; break; 
2C0E:  MOVLW  92
2C10:  MOVLB  2
2C12:  MOVWF  xE2
2C14:  BRA    2C2E
....................             case 5: Power = 183; break; 
2C16:  MOVLW  B7
2C18:  MOVLB  2
2C1A:  MOVWF  xE2
2C1C:  BRA    2C2E
....................             case 6: Power = 219; break; 
2C1E:  MOVLW  DB
2C20:  MOVLB  2
2C22:  MOVWF  xE2
2C24:  BRA    2C2E
....................             case 7: Power = 255; break; 
2C26:  MOVLB  2
2C28:  SETF   xE2
2C2A:  BRA    2C2E
2C2C:  MOVLB  2
....................          } 
....................  
....................          gblMtrDuty[i] = Power; 
2C2E:  CLRF   03
2C30:  MOVFF  2E3,FE9
2C34:  MOVLW  02
2C36:  ADDWF  03,W
2C38:  MOVWF  FEA
2C3A:  MOVFF  2E2,FEF
....................          if (Power != gblMtrPrevDuty[i]) { 
2C3E:  CLRF   03
2C40:  MOVF   xE3,W
2C42:  ADDLW  05
2C44:  MOVWF  FE9
2C46:  MOVLW  02
2C48:  ADDWFC 03,W
2C4A:  MOVWF  FEA
2C4C:  MOVF   FEF,W
2C4E:  SUBWF  xE2,W
2C50:  BZ    2C6A
....................             gblMtrNeedToRecreateMtrDutyVector = 1; // Notify the main loop that we need to 
2C52:  MOVLB  0
2C54:  BSF    x7F.6
....................                                                    // update the duty vector 
....................             gblMtrPrevDuty[i] = Power; 
2C56:  CLRF   03
2C58:  MOVLB  2
2C5A:  MOVF   xE3,W
2C5C:  ADDLW  05
2C5E:  MOVWF  FE9
2C60:  MOVLW  02
2C62:  ADDWFC 03,W
2C64:  MOVWF  FEA
2C66:  MOVFF  2E2,FEF
....................          } 
....................       } 
....................    } 
2C6A:  INCF   xE3,F
2C6C:  BRA    2BC6
....................     
.................... } 
2C6E:  MOVLB  0
2C70:  RETURN 0
....................  
....................  
.................... void ChangeMotorPower(int delta) { 
....................    int i; 
....................  
....................    for (i=0;i<MotorCount;i++) 
36A2:  MOVLB  2
36A4:  CLRF   xE2
36A6:  MOVF   xE2,W
36A8:  SUBLW  03
36AA:  BNC   36EE
....................    { 
....................       if ((gblActiveMotors >> i) & 1) { 
36AC:  MOVFF  1FD,00
36B0:  MOVLB  2
36B2:  MOVF   xE2,W
36B4:  MOVWF  01
36B6:  BZ    36C0
36B8:  BCF    FD8.0
36BA:  RRCF   00,F
36BC:  DECFSZ 01,F
36BE:  BRA    36B8
36C0:  MOVF   00,W
36C2:  ANDLW  01
36C4:  BZ    36EA
....................          gblMtrDuty[i] = gblMtrDuty[i] + delta; 
36C6:  CLRF   03
36C8:  MOVLW  02
36CA:  ADDWF  03,F
36CC:  MOVFF  03,2E4
36D0:  CLRF   03
36D2:  MOVFF  2E2,FE9
36D6:  MOVLW  02
36D8:  ADDWF  03,W
36DA:  MOVWF  FEA
36DC:  MOVF   xE1,W
36DE:  ADDWF  FEF,W
36E0:  MOVFF  2E4,FEA
36E4:  MOVFF  2E2,FE9
36E8:  MOVWF  FEF
....................       } 
....................    } 
36EA:  INCF   xE2,F
36EC:  BRA    36A6
....................  
....................    createPWMVectorTable(); 
36EE:  MOVLB  0
36F0:  RCALL  31E8
.................... } 
36F2:  RETURN 0
....................  
....................  
....................  
.................... // createPWMVectorTable() will create an interrupt vector table.  
.................... // 
.................... // The goal is for timer1 to interrupt at the particular time each pulse needs to  
.................... // be set low. A table will be created containing the number of ticks to the next  
.................... // interrupt. For example, here's a hypothetical situation: 
.................... // 
.................... // Motor A: PWM level = 255 (Full power) 
.................... // Motor B: PWM level = 100 
.................... // Motor C: PWM level = 50 
.................... // Motor D: PWM level = 100 
.................... // 
.................... // The vector table will look like this 
.................... // 
.................... //    int16 PWMVector[4] = [65535-(50*150), 65535-((100-50) * 150), 0, 0] 
.................... //    int PWMVectorPorts[4] = [0b0100, 0b1010, 0, 0] 
.................... //    int PWMVectorLen = 2 
.................... //    int16 PWMTerminatingVector = 65535 - (38400 - 100*150) 
.................... // 
.................... //    * The PWMVector array contains Timer1's counter value that would overflow  
.................... //      (causing an interrupt) at the desired time 
.................... //    * The PWMVectorPorts contains bits that indicate which motor ports are  
.................... //      associated with that power level. 
.................... //    * PWMVectorLen indicates how many vectors are present 
.................... //    * PWMTerminatingVector contains the number of ticks until then end of that  
.................... //      PWM period (after the last pulse). 
.................... // 
.................... // Timer1 Settings 
.................... // 
.................... //    * The PWM period is 12.8ms or approximately 78Hz. 
.................... //    * This allows 256 levels at 0.05 ms pulse resolution. 
.................... //    * When Timer1 prescale is 4, the number of ticks for a 12.8ms period is 38400.  
.................... //      Divide that by 256 pulse levels and you will get 150 ticks per level.  
.................... //      For example, if we decide to widen a pulse by 10 steps (out of 256) we will  
.................... //      need Timer1 to count 150x10 = 1500 ticks more before setting the pulse low. 
....................  
....................  
....................  
.................... void createPWMVectorTable(void) { 
31E8:  MOVLB  2
31EA:  CLRF   xE3
31EC:  CLRF   xE4
31EE:  CLRF   xE5
31F0:  SETF   xE7
31F2:  CLRF   xE8
31F4:  CLRF   xE9
....................  
....................    int portsProcessed=0;  // each bit tracks which ports have been processed 
....................    int i=0; 
....................    int vectorIndex=0; // the current item in the PWM Vector Table 
....................    int currentPowerLevel; // buffer to cache an array value (just to make exe faster) 
....................    int currentMinLevel=255; // tracks the current min power level 
....................    int portList=0; // each bit tracks the ports with the same power level 
....................    int prevMinLevel=0; // remembers the previous min power level 
....................     
....................     
....................    gblPWMVectorIndexCounter=0; // reset the PWM pulses 
31F6:  CLRF   x1A
....................  
....................    // while not all ports have been processed 
....................    while (portsProcessed != 0b1111) { 
31F8:  MOVF   xE3,W
31FA:  SUBLW  0F
31FC:  BTFSC  FD8.2
31FE:  BRA    3314
....................  
....................       for (i=0;i<MotorCount;i++) { 
3200:  CLRF   xE4
3202:  MOVF   xE4,W
3204:  SUBLW  03
3206:  BNC   329C
3208:  CLRF   19
320A:  BTFSC  FF2.7
320C:  BSF    19.7
320E:  BCF    FF2.7
....................           
....................          // skip if this port has already been processed 
....................          if (getBit(portsProcessed,i)) 
3210:  MOVFF  2E3,A4C
3214:  MOVFF  2E4,A4D
3218:  MOVLB  0
321A:  CALL   1360
321E:  BTFSC  19.7
3220:  BSF    FF2.7
3222:  MOVF   01,F
3224:  BZ    3228
....................             continue; 
3226:  BRA    3296
....................           
....................          // cache the array value in a normal variable (it's faster) 
....................          currentPowerLevel = gblMtrDuty[i];  
3228:  CLRF   03
322A:  MOVLB  2
322C:  MOVFF  2E4,FE9
3230:  MOVLW  02
3232:  ADDWF  03,W
3234:  MOVWF  FEA
3236:  MOVFF  FEF,2E6
....................     
....................          // don't create vector item for power levels 0, 255  
....................          if ((currentPowerLevel == 255) || (currentPowerLevel == 0)) { 
323A:  INCFSZ xE6,W
323C:  BRA    3240
323E:  BRA    3244
3240:  MOVF   xE6,F
3242:  BNZ   325A
....................             setBit(&portsProcessed,i); 
3244:  MOVLW  02
3246:  MOVWF  xEB
3248:  MOVLW  E3
324A:  MOVWF  xEA
324C:  MOVFF  2E4,2EC
3250:  MOVLB  0
3252:  CALL   28EC
....................             continue; 
3256:  BRA    3296
3258:  MOVLB  2
....................          } 
....................     
....................          // look for the min power level 
....................          if (currentPowerLevel < currentMinLevel) { 
325A:  MOVF   xE7,W
325C:  SUBWF  xE6,W
325E:  BC    3278
....................             currentMinLevel = currentPowerLevel; 
3260:  MOVFF  2E6,2E7
....................             portList = 1 << i;   // remember which port this is 
3264:  MOVLW  01
3266:  MOVWF  xE8
3268:  MOVF   xE4,W
326A:  MOVWF  01
326C:  BZ    3276
326E:  BCF    FD8.0
3270:  RLCF   xE8,F
3272:  DECFSZ 01,F
3274:  BRA    326E
....................            
....................          // if found another port with equal min power level 
....................          } else if (currentPowerLevel == currentMinLevel) { 
3276:  BRA    3294
3278:  MOVF   xE7,W
327A:  SUBWF  xE6,W
327C:  BNZ   3294
....................             portList |= (1 << i);  // add the port to the list 
327E:  MOVLW  01
3280:  MOVWF  00
3282:  MOVF   xE4,W
3284:  MOVWF  01
3286:  BZ    3290
3288:  BCF    FD8.0
328A:  RLCF   00,F
328C:  DECFSZ 01,F
328E:  BRA    3288
3290:  MOVF   00,W
3292:  IORWF  xE8,F
3294:  MOVLB  0
....................          }    
....................       }  
3296:  MOVLB  2
3298:  INCF   xE4,F
329A:  BRA    3202
....................  
....................       portsProcessed |= portList; // mark ports in the list as processed 
329C:  MOVF   xE8,W
329E:  IORWF  xE3,F
....................  
....................       // if an unprocessed power level was found -> add it to the vector array 
....................  
....................       if (currentMinLevel < 255) {       
32A0:  INCFSZ xE7,W
32A2:  BRA    32A6
32A4:  BRA    3312
....................          // We store the number of "Timer ticks" till the next timer interrupt 
....................          gblPWMVector[vectorIndex] = 65535 - ((int16)(currentMinLevel-prevMinLevel) * 150); 
32A6:  BCF    FD8.0
32A8:  RLCF   xE5,W
32AA:  CLRF   03
32AC:  ADDLW  0B
32AE:  MOVWF  FE9
32B0:  MOVLW  02
32B2:  ADDWFC 03,W
32B4:  MOVWF  FEA
32B6:  MOVF   xE9,W
32B8:  SUBWF  xE7,W
32BA:  CLRF   xED
32BC:  MOVWF  xEC
32BE:  CLRF   19
32C0:  BTFSC  FF2.7
32C2:  BSF    19.7
32C4:  BCF    FF2.7
32C6:  MOVFF  2ED,A5D
32CA:  MOVFF  FE8,A5C
32CE:  MOVLB  A
32D0:  CLRF   x5F
32D2:  MOVLW  96
32D4:  MOVWF  x5E
32D6:  MOVLB  0
32D8:  CALL   030A
32DC:  BTFSC  19.7
32DE:  BSF    FF2.7
32E0:  MOVFF  02,03
32E4:  MOVF   01,W
32E6:  SUBLW  FF
32E8:  MOVWF  00
32EA:  MOVLW  FF
32EC:  SUBFWB 03,F
32EE:  MOVFF  00,FEF
32F2:  MOVFF  03,FEC
....................          // identify the ports associated with this power level 
....................          gblPWMVectorPorts[vectorIndex] = portList; 
32F6:  CLRF   03
32F8:  MOVLB  2
32FA:  MOVF   xE5,W
32FC:  ADDLW  13
32FE:  MOVWF  FE9
3300:  MOVLW  02
3302:  ADDWFC 03,W
3304:  MOVWF  FEA
3306:  MOVFF  2E8,FEF
....................           
....................          // update working variables 
....................          prevMinLevel = currentMinLevel; 
330A:  MOVFF  2E7,2E9
....................          currentMinLevel = 255;   // reset the variable 
330E:  SETF   xE7
....................          vectorIndex++; 
3310:  INCF   xE5,F
....................       } 
....................            
....................    } 
3312:  BRA    31F8
....................    // Vector length 
....................    gblPWMVectorLen = vectorIndex; 
3314:  MOVFF  2E5,217
....................     
....................    if (vectorIndex > 0) 
3318:  MOVF   xE5,F
331A:  BZ    3354
....................       // Time (ticks) from the last pulse to the end of the PWM period 
....................       // equivalent to 65535 - (PWM_Period_Ticks - (prevMinLevel * 150)) 
....................       gblPWMTerminatingVector = PWM_PERIOD + ((int16)prevMinLevel*150); 
331C:  CLRF   xEB
331E:  MOVFF  2E9,2EA
3322:  CLRF   19
3324:  BTFSC  FF2.7
3326:  BSF    19.7
3328:  BCF    FF2.7
332A:  MOVFF  2EB,A5D
332E:  MOVFF  2E9,A5C
3332:  MOVLB  A
3334:  CLRF   x5F
3336:  MOVLW  96
3338:  MOVWF  x5E
333A:  MOVLB  0
333C:  CALL   030A
3340:  BTFSC  19.7
3342:  BSF    FF2.7
3344:  MOVF   01,W
3346:  ADDLW  FF
3348:  MOVLB  2
334A:  MOVWF  x18
334C:  MOVLW  69
334E:  ADDWFC 02,W
3350:  MOVWF  x19
....................    else 
3352:  BRA    335A
....................       gblPWMTerminatingVector = PWM_PERIOD; 
3354:  MOVLW  69
3356:  MOVWF  x19
3358:  SETF   x18
....................  
....................  
....................  
....................  
.................... } 
335A:  MOVLB  0
335C:  RETURN 0
....................  
....................  
.................... // Set the mode of the active motors (NORMAL or SERVO) 
.................... void SetMotorMode(int motorMode) { 
....................    int i; 
....................  
....................    for (i=0;i<MotorCount;i++) { 
2916:  MOVLB  2
2918:  CLRF   xE3
291A:  MOVF   xE3,W
291C:  SUBLW  03
291E:  BNC   2968
....................       if ((gblActiveMotors >> i) & 1) 
2920:  MOVFF  1FD,00
2924:  MOVLB  2
2926:  MOVF   xE3,W
2928:  MOVWF  01
292A:  BZ    2934
292C:  BCF    FD8.0
292E:  RRCF   00,F
2930:  DECFSZ 01,F
2932:  BRA    292C
2934:  MOVF   00,W
2936:  ANDLW  01
2938:  BZ    2964
....................          if (motorMode == MOTOR_NORMAL) 
293A:  MOVF   xE2,F
293C:  BNZ   2952
....................             clearBit(&gblMotorMode, i); 
293E:  MOVLW  01
2940:  MOVWF  xE8
2942:  MOVLW  FC
2944:  MOVWF  xE7
2946:  MOVFF  2E3,2E9
294A:  MOVLB  0
294C:  RCALL  28C0
....................          else // Servo mode 
294E:  BRA    2962
2950:  MOVLB  2
....................             setBit(&gblMotorMode, i); 
2952:  MOVLW  01
2954:  MOVWF  xEB
2956:  MOVLW  FC
2958:  MOVWF  xEA
295A:  MOVFF  2E3,2EC
295E:  MOVLB  0
2960:  RCALL  28EC
2962:  MOVLB  2
....................  
....................    } 
2964:  INCF   xE3,F
2966:  BRA    291A
.................... } 
2968:  MOVLB  0
296A:  RETURN 0
....................  
....................  
.................... // Sets "both" the EN pins of a h-bridge chip 
.................... void ENHigh(int groupNo) { 
....................    groupNo<<=1; 
296C:  BCF    FD8.0
296E:  MOVLB  2
2970:  RLCF   xE8,F
....................  
.................... //   setHigh(MotorENPins[groupNo]); 
.................... //   setHigh(MotorENPins[groupNo+1]); 
....................  
....................  
....................  
....................    // power on the motor chip 
....................    if (!groupNo) { 
2972:  MOVF   xE8,F
2974:  BNZ   297A
....................       output_high(MOTOR_AB_EN); 
2976:  BSF    F8D.6
....................    } else { 
2978:  BRA    297C
....................       output_high(MOTOR_CD_EN); 
297A:  BSF    F8A.1
....................    } 
....................  
.................... } 
297C:  MOVLB  0
297E:  RETURN 0
....................  
....................  
.................... // Clears "both" the EN pins of a h-bridge chip 
.................... // but do it only if both motors on the chip 
.................... // is in the coast state 
.................... void ENLow(int groupNo) { 
....................    groupNo<<=1; 
2A9E:  BCF    FD8.0
2AA0:  MOVLB  2
2AA2:  RLCF   xE4,F
....................  
.................... //   setLow(MotorENPins[groupNo]); 
.................... //   setLow(MotorENPins[groupNo+1]); 
....................  
....................    // power off the motor chip 
....................    if (!groupNo) { 
2AA4:  MOVF   xE4,F
2AA6:  BNZ   2AAC
....................       output_low(MOTOR_AB_EN); 
2AA8:  BCF    F8D.6
....................    } else { 
2AAA:  BRA    2AAE
....................       output_low(MOTOR_CD_EN); 
2AAC:  BCF    F8A.1
....................    } 
....................  
....................  
.................... } 
2AAE:  MOVLB  0
2AB0:  GOTO   2B14 (RETURN)
....................  
....................  
....................  
.................... void MotorON(int MotorNo) 
.................... { 
....................  
.................... // no need to directly output to pins here. the PWM routine in Timer1 
.................... // will take care of it asynchronously. Only update the ONOFF flags 
.................... // -Roger 30 June 2012. Firmware v13. 
....................  
.................... //!   IOPointer MtrCC, MtrCW; 
.................... //! 
.................... //!   MtrCW       = MotorCWPins[MotorNo]; 
.................... //!   MtrCC       = MotorCCPins[MotorNo]; 
.................... //! 
.................... //!   // if power level is 0 -> don't turn on the motor 
.................... //!   if (gblMtrDuty[MotorNo] > 0) { 
.................... //!      if (getBit(gblMotorDir,MotorNo)) 
.................... //!           {    setLow(MtrCC); setHigh(MtrCW);   } 
.................... //!      else 
.................... //!         {   setHigh(MtrCC); setLow(MtrCW);   } 
.................... //!   } 
....................     
....................    // In gogo board 2.3 and later, we have to set both the EN pins on the h-bridge 
....................    // to turn on one motor port. That is 
....................    //  Motor 1 needs EN1 and EN2 to be high 
....................    //  Motor 2 needs the same as motor 1 
....................    //  Motor 3 needs EN3 and EN4 to be high 
....................    //  Motor 4 needs the same as motor 3 
....................    // 
....................    //  ENHigh handles this. 
....................    ENHigh(MotorNo>>1); 
2980:  BCF    FD8.0
2982:  MOVLB  2
2984:  RRCF   xE2,W
2986:  MOVWF  xE3
2988:  MOVWF  xE8
298A:  MOVLB  0
298C:  RCALL  296C
....................  
....................    setBit(&gblMotorONOFF,MotorNo); 
298E:  MOVLW  01
2990:  MOVLB  2
2992:  MOVWF  xEB
2994:  SETF   xEA
2996:  MOVFF  2E2,2EC
299A:  MOVLB  0
299C:  RCALL  28EC
....................     
.................... } 
299E:  GOTO   2B5C (RETURN)
....................  
....................  
....................  
.................... void MotorOFF(int MotorNo) 
.................... { 
....................  
....................    IOPointer MtrCC, MtrCW; 
....................  
....................    MtrCW       = MotorCWPins[MotorNo]; 
29A2:  BCF    FD8.0
29A4:  MOVLB  2
29A6:  RLCF   xE2,W
29A8:  CLRF   03
29AA:  ADDLW  BA
29AC:  MOVWF  FE9
29AE:  MOVLW  01
29B0:  ADDWFC 03,W
29B2:  MOVWF  FEA
29B4:  MOVFF  FEC,2E6
29B8:  MOVF   FED,F
29BA:  MOVFF  FEF,2E5
....................    MtrCC       = MotorCCPins[MotorNo]; 
29BE:  BCF    FD8.0
29C0:  RLCF   xE2,W
29C2:  CLRF   03
29C4:  ADDLW  C2
29C6:  MOVWF  FE9
29C8:  MOVLW  01
29CA:  ADDWFC 03,W
29CC:  MOVWF  FEA
29CE:  MOVFF  FEC,2E4
29D2:  MOVF   FED,F
29D4:  MOVFF  FEF,2E3
29D8:  CLRF   19
29DA:  BTFSC  FF2.7
29DC:  BSF    19.7
29DE:  BCF    FF2.7
....................  
....................     
....................    setHigh(MtrCC); 
29E0:  MOVFF  2E4,A4F
29E4:  MOVFF  2E3,A4E
29E8:  MOVLB  0
29EA:  CALL   13D6
29EE:  BTFSC  19.7
29F0:  BSF    FF2.7
29F2:  CLRF   19
29F4:  BTFSC  FF2.7
29F6:  BSF    19.7
29F8:  BCF    FF2.7
....................    setHigh(MtrCW); 
29FA:  MOVFF  2E6,A4F
29FE:  MOVFF  2E5,A4E
2A02:  CALL   13D6
2A06:  BTFSC  19.7
2A08:  BSF    FF2.7
....................  
....................    clearBit(&gblMotorONOFF,MotorNo); 
2A0A:  MOVLW  01
2A0C:  MOVLB  2
2A0E:  MOVWF  xE8
2A10:  SETF   xE7
2A12:  MOVFF  2E2,2E9
2A16:  MOVLB  0
2A18:  RCALL  28C0
....................    ENHigh(MotorNo>>1);     // this ensures the motor breaks. Sometimes the timer_isr turns off the enable pin, which turns 'stop' into 'coast' 
2A1A:  BCF    FD8.0
2A1C:  MOVLB  2
2A1E:  RRCF   xE2,W
2A20:  MOVWF  xE7
2A22:  MOVWF  xE8
2A24:  MOVLB  0
2A26:  RCALL  296C
....................  
.................... } 
2A28:  GOTO   2B66 (RETURN)
....................  
....................  
....................  
.................... void MotorRD(int MotorNo) 
.................... { 
2A2C:  CLRF   19
2A2E:  BTFSC  FF2.7
2A30:  BSF    19.7
2A32:  BCF    FF2.7
.................... // no need to directly output to pins here. the PWM routine in Timer1 
.................... // will take care of it asynchronously. Only update the Motor direction flags 
.................... // -Roger 30 June 2012. Firmware v13. 
....................  
.................... //!   IOPointer MtrCC, MtrCW; 
.................... //! 
.................... //!    MtrCW       = MotorCWPins[MotorNo]; 
.................... //!    MtrCC       = MotorCCPins[MotorNo]; 
.................... //! 
.................... //!      if (getBit(gblMotorDir,MotorNo)) 
.................... //!      {   if (getBit(gblMotorONOFF, MotorNo)) { 
.................... //!            setLow(MtrCW); 
.................... //!            setHigh(MtrCC); 
.................... //!         } 
.................... //!         clearBit(&gblMotorDir,MotorNo); 
.................... //!      } else 
.................... //!      {   if (getBit(gblMotorONOFF, MotorNo)) { 
.................... //!            setHigh(MtrCW); 
.................... //!            setLow(MtrCC); 
.................... //!         } 
.................... //!         setBit(&gblMotorDir,MotorNo); 
.................... //!      } 
.................... //! 
....................  
....................       if (getBit(gblMotorDir,MotorNo)) 
2A34:  MOVFF  1FE,A4C
2A38:  MOVFF  2E2,A4D
2A3C:  CALL   1360
2A40:  BTFSC  19.7
2A42:  BSF    FF2.7
2A44:  MOVF   01,F
2A46:  BZ    2A5C
....................       {   clearBit(&gblMotorDir,MotorNo); 
2A48:  MOVLW  01
2A4A:  MOVLB  2
2A4C:  MOVWF  xE8
2A4E:  MOVLW  FE
2A50:  MOVWF  xE7
2A52:  MOVFF  2E2,2E9
2A56:  MOVLB  0
2A58:  RCALL  28C0
....................       } else 
2A5A:  BRA    2A6E
....................       {   setBit(&gblMotorDir,MotorNo); 
2A5C:  MOVLW  01
2A5E:  MOVLB  2
2A60:  MOVWF  xEB
2A62:  MOVLW  FE
2A64:  MOVWF  xEA
2A66:  MOVFF  2E2,2EC
2A6A:  MOVLB  0
2A6C:  RCALL  28EC
....................       } 
....................  
....................  
.................... } 
2A6E:  GOTO   2B70 (RETURN)
....................  
....................  
.................... /////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void MotorThisWay(int MotorNo) 
.................... {    
.................... // no need to directly output to pins here. the PWM routine in Timer1 
.................... // will take care of it asynchronously. Only update the Motor direction flags 
.................... // -Roger 30 June 2012. Firmware v13. 
....................  
.................... //!   IOPointer MtrCC, MtrCW; 
.................... //! 
.................... //!     MtrCW       = MotorCWPins[MotorNo]; 
.................... //!     MtrCC       = MotorCCPins[MotorNo]; 
.................... //! 
.................... //!     setBit(&gblMotorDir,MotorNo); 
.................... //! 
.................... //!      if (getBit(gblMotorONOFF, MotorNo)) { 
.................... //!          setLow(MtrCC); 
.................... //!            setHigh(MtrCW); 
.................... //!      } 
.................... //! 
....................      setBit(&gblMotorDir,MotorNo); 
2A72:  MOVLW  01
2A74:  MOVLB  2
2A76:  MOVWF  xEB
2A78:  MOVLW  FE
2A7A:  MOVWF  xEA
2A7C:  MOVFF  2E2,2EC
2A80:  MOVLB  0
2A82:  RCALL  28EC
....................  
....................  
.................... } 
2A84:  GOTO   2B7A (RETURN)
....................  
....................  
.................... void MotorThatWay(int MotorNo) 
.................... {    
.................... // no need to directly output to pins here. the PWM routine in Timer1 
.................... // will take care of it asynchronously. Only update the Motor direction flags 
.................... // -Roger 30 June 2012. Firmware v13. 
....................  
.................... //!   IOPointer MtrCC, MtrCW; 
.................... //! 
.................... //!     MtrCW       = MotorCWPins[MotorNo]; 
.................... //!     MtrCC       = MotorCCPins[MotorNo]; 
.................... //! 
.................... //!     clearBit(&gblMotorDir,MotorNo); 
.................... //! 
.................... //!      if (getBit(gblMotorONOFF, MotorNo)) { 
.................... //!         setLow(MtrCW); 
.................... //!           setHigh(MtrCC); 
.................... //!      } 
.................... //! 
....................    clearBit(&gblMotorDir,MotorNo); 
2A88:  MOVLW  01
2A8A:  MOVLB  2
2A8C:  MOVWF  xE8
2A8E:  MOVLW  FE
2A90:  MOVWF  xE7
2A92:  MOVFF  2E2,2E9
2A96:  MOVLB  0
2A98:  RCALL  28C0
....................  
.................... } 
2A9A:  GOTO   2B84 (RETURN)
....................  
....................  
.................... void MotorCoast(int MotorNo) 
.................... { 
.................... // no need to directly output to pins here. the PWM routine in Timer1 
.................... // will take care of it asynchronously. Only update the ONOFF flags 
.................... // -Roger 30 June 2012. Firmware v13. 
....................  
.................... //!   IOPointer MtrCC, MtrCW; 
.................... //! 
.................... //!     MtrCW       = MotorCWPins[MotorNo]; 
.................... //!     MtrCC       = MotorCCPins[MotorNo]; 
.................... //! 
.................... //!        clearBit(&gblMotorONOFF,MotorNo); 
.................... //! 
.................... //!      setLow(MtrCW); 
.................... //!      setLow(MtrCC); 
.................... //! 
....................  
....................    clearBit(&gblMotorONOFF,MotorNo); 
2AB4:  MOVLW  01
2AB6:  MOVLB  2
2AB8:  MOVWF  xE8
2ABA:  SETF   xE7
2ABC:  MOVFF  2E2,2E9
2AC0:  MOVLB  0
2AC2:  RCALL  28C0
....................  
....................  
....................    // if both ports on the h-bridge is off then turn off the 
....................    // EN pins 
....................    if (  !((gblMotorONOFF >> (MotorNo & 0b10)) & 1) && 
....................          !((gblMotorONOFF >> ((MotorNo & 0b10) + 1)) & 1) ) { 
2AC4:  MOVLB  2
2AC6:  MOVF   xE2,W
2AC8:  ANDLW  02
2ACA:  MOVWF  01
2ACC:  MOVLB  1
2ACE:  MOVFF  1FF,00
2AD2:  MOVF   01,F
2AD4:  BZ    2ADE
2AD6:  BCF    FD8.0
2AD8:  RRCF   00,F
2ADA:  DECFSZ 01,F
2ADC:  BRA    2AD6
2ADE:  MOVF   00,W
2AE0:  ANDLW  01
2AE2:  BNZ   2B16
2AE4:  MOVLB  2
2AE6:  MOVF   xE2,W
2AE8:  ANDLW  02
2AEA:  ADDLW  01
2AEC:  MOVWF  01
2AEE:  MOVLB  1
2AF0:  MOVFF  1FF,00
2AF4:  MOVF   01,F
2AF6:  BZ    2B00
2AF8:  BCF    FD8.0
2AFA:  RRCF   00,F
2AFC:  DECFSZ 01,F
2AFE:  BRA    2AF8
2B00:  MOVF   00,W
2B02:  ANDLW  01
2B04:  BNZ   2B16
....................             ENLow(MotorNo>>1); 
2B06:  BCF    FD8.0
2B08:  MOVLB  2
2B0A:  RRCF   xE2,W
2B0C:  MOVWF  xE3
2B0E:  MOVWF  xE4
2B10:  MOVLB  0
2B12:  BRA    2A9E
2B14:  MOVLB  1
....................          } 
.................... } 
2B16:  MOVLB  2
2B18:  GOTO   2B94 (RETURN)
....................  
.................... void DoMotorStuff() { 
....................     
....................    // Update the motor duty vector if needed. 
....................    // Do this only at the end of a PWM cycle so that we don't disrupt 
....................    // the current PWM generation process. 
....................     
....................    if (gblAtEndOfPWMCycle) { 
335E:  BTFSS  x7F.7
3360:  BRA    336A
....................       if (gblMtrNeedToRecreateMtrDutyVector) { 
3362:  BTFSS  x7F.6
3364:  BRA    336A
....................          createPWMVectorTable(); 
3366:  RCALL  31E8
....................          gblMtrNeedToRecreateMtrDutyVector = 0; 
3368:  BCF    x7F.6
....................  
....................       } 
....................    } 
....................  
.................... } 
336A:  GOTO   53DE (RETURN)
....................  
....................  
....................  
.................... /////////////////////////////////////////////////////////// 
.................... // 
.................... //    M i s c   C o n t r o l 
.................... // 
.................... /////////////////////////////////////////////////////////// 
....................  
.................... void miscControl(int cur_param, int cur_ext, int cur_ext_byte) 
.................... { 
.................... //   int16 counter; 
....................  
....................    switch (cur_param) { 
2D02:  MOVLB  2
2D04:  MOVF   xA7,W
2D06:  ADDLW  FA
2D08:  BTFSC  FD8.0
2D0A:  BRA    2DE0
2D0C:  ADDLW  06
2D0E:  MOVLB  0
2D10:  GOTO   2E08
....................       case MISC_USER_LED: 
....................          if (cur_ext == TURN_USER_LED_ON) { USER_LED_ON; } 
2D14:  MOVLB  2
2D16:  MOVF   xA8,F
2D18:  BNZ   2D1E
2D1A:  BSF    F8B.0
....................          else {USER_LED_OFF; } 
2D1C:  BRA    2D20
2D1E:  BCF    F8B.0
....................          break; 
2D20:  BRA    2DE0
....................       case MISC_BEEP: 
....................          beep(); 
2D22:  CALL   2222
....................          break; 
2D26:  MOVLB  2
2D28:  BRA    2DE0
....................       case MISC_SET_PWM: 
....................          MotorControl(MTR_ON); 
2D2A:  MOVLB  2
2D2C:  CLRF   xE0
2D2E:  MOVLB  0
2D30:  RCALL  2B1C
....................          MotorControl(MTR_THISWAY); 
2D32:  MOVLW  03
2D34:  MOVLB  2
2D36:  MOVWF  xE0
2D38:  MOVLB  0
2D3A:  RCALL  2B1C
....................          SetMotorMode(MOTOR_SERVO); 
2D3C:  MOVLW  01
2D3E:  MOVLB  2
2D40:  MOVWF  xE2
2D42:  MOVLB  0
2D44:  RCALL  2916
....................          SetMotorPower(cur_ext_byte); 
2D46:  MOVFF  2A9,2E2
2D4A:  RCALL  2BC2
....................          break; 
2D4C:  MOVLB  2
2D4E:  BRA    2DE0
....................  
.................... // we handle EEPROM upload in the main loop (urr .. ugly code) 
....................       case MISC_UPLOAD_EEPROM: 
....................  
....................          break; 
2D50:  MOVLB  2
2D52:  BRA    2DE0
....................  
....................       case MISC_I2C_SETUP: 
....................          switch (cur_ext) { 
2D54:  MOVLB  2
2D56:  MOVF   xA8,W
2D58:  ADDLW  FC
2D5A:  BC    2D90
2D5C:  ADDLW  04
2D5E:  MOVLB  0
2D60:  GOTO   2DE6
....................             case I2C_START: 
....................                gblI2CisBusy = 1;  // reserve the i2c bus 
2D64:  MOVLB  2
2D66:  BSF    x0A.7
....................                i2c_start(); 
2D68:  BSF    FC5.0
2D6A:  BTFSC  FC5.0
2D6C:  BRA    2D6A
....................                break; 
2D6E:  BRA    2D90
....................             case I2C_STOP: 
....................                i2c_stop(); 
2D70:  BSF    FC5.2
2D72:  BTFSC  FC5.2
2D74:  BRA    2D72
....................                gblI2CisBusy = 0;  // release the i2c bus 
2D76:  MOVLB  2
2D78:  BCF    x0A.7
....................                break; 
2D7A:  BRA    2D90
....................             case I2C_WRITE: 
....................                i2c_write(cur_ext_byte); 
2D7C:  MOVFF  2A9,2EC
2D80:  RCALL  2CB8
.................... //               printf("%c", cur_ext_byte); 
....................                break; 
2D82:  MOVLB  2
2D84:  BRA    2D90
....................             case I2C_READ: 
....................                i2c_read(0); 
2D86:  CLRF   00
2D88:  RCALL  2CD4
....................                break; 
2D8A:  MOVLB  2
2D8C:  BRA    2D90
2D8E:  MOVLB  2
....................             } 
....................          break; 
2D90:  BRA    2DE0
....................  
....................    case MISC_AUTORUN_CONFIG: 
....................       switch(cur_ext_byte) { 
2D92:  MOVLB  2
2D94:  MOVF   xA9,W
2D96:  XORLW  01
2D98:  MOVLB  0
2D9A:  BZ    2DA2
2D9C:  XORLW  01
2D9E:  BZ    2DC0
2DA0:  BRA    2DDA
....................          case AUTORUN_ON: 
....................              FLASHSetWordAddress(AUTORUN_STATUS_ADDRESS); 
2DA2:  MOVLW  F9
2DA4:  MOVLB  2
2DA6:  MOVWF  xE7
2DA8:  MOVLW  F2
2DAA:  MOVWF  xE6
2DAC:  MOVLB  0
2DAE:  CALL   218C
....................              FLASHWrite(AUTORUN_ON); 
2DB2:  MOVLB  2
2DB4:  CLRF   xE1
2DB6:  MOVLW  01
2DB8:  MOVWF  xE0
2DBA:  MOVLB  0
2DBC:  RCALL  2CF0
....................              break; 
2DBE:  BRA    2DDA
....................          case AUTORUN_OFF: 
....................              FLASHSetWordAddress(AUTORUN_STATUS_ADDRESS); 
2DC0:  MOVLW  F9
2DC2:  MOVLB  2
2DC4:  MOVWF  xE7
2DC6:  MOVLW  F2
2DC8:  MOVWF  xE6
2DCA:  MOVLB  0
2DCC:  CALL   218C
....................              FLASHWrite(AUTORUN_OFF); 
2DD0:  MOVLB  2
2DD2:  CLRF   xE1
2DD4:  CLRF   xE0
2DD6:  MOVLB  0
2DD8:  RCALL  2CF0
....................              break; 
....................       } 
....................       break; 
2DDA:  MOVLB  2
2DDC:  BRA    2DE0
2DDE:  MOVLB  2
....................    } 
.................... } 
2DE0:  MOVLB  1
2DE2:  GOTO   517E (RETURN)
....................  
....................  
.................... ///////////////////////// 
.................... //    User LED controls 
....................  
.................... void uLED_on() 
.................... {  output_high(USER_LED); 
.................... } 
....................  
.................... void uLED_off() 
.................... {  output_low(USER_LED); 
.................... } 
....................  
....................  
.................... /////////////////////// 
.................... //   Beep 
....................  
.................... void beep() { 
....................     set_pwm1_duty(50);        // make a beep 
2222:  MOVLW  32
2224:  MOVWF  FBC
....................     delay_ms(50); 
2226:  MOVLB  9
2228:  MOVWF  x2B
222A:  MOVLB  0
222C:  CALL   18F4
....................     set_pwm1_duty(0);        // make a beep 
2230:  CLRF   FBC
.................... } 
2232:  RETURN 0
....................  
....................  
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   P R O C E S S   S E N S O R    W H I L E    I D L E 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... void DoSensorStuff() 
.................... { 
.................... //   int i; 
....................    long SensorVal; 
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    // 
....................    //  Burst sensor data to computer 
....................  
....................    if (gblBurstModeTimerHasTicked) { 
2FFC:  BTFSS  x7F.5
2FFE:  BRA    3082
....................  
....................  
....................       // if this sensor is in Burst mode -> send value to computer 
....................       if ((gblBurstModeBits>>gblBurstModeCounter) & 1) 
3000:  MOVLB  1
3002:  MOVFF  1F9,00
3006:  MOVF   xFA,W
3008:  MOVWF  01
300A:  BZ    3014
300C:  BCF    FD8.0
300E:  RRCF   00,F
3010:  DECFSZ 01,F
3012:  BRA    300C
3014:  MOVF   00,W
3016:  ANDLW  01
3018:  BZ    3076
....................       { 
....................           SensorVal=readSensor(gblSensorPortMap[gblBurstModeCounter]); 
301A:  CLRF   03
301C:  MOVF   xFA,W
301E:  ADDLW  F1
3020:  MOVWF  FE9
3022:  MOVLW  01
3024:  ADDWFC 03,W
3026:  MOVWF  FEA
3028:  MOVFF  FEF,2A9
302C:  MOVFF  2A9,2E1
3030:  MOVLB  0
3032:  RCALL  28A2
3034:  MOVFF  02,2A8
3038:  MOVFF  01,2A7
....................           printf(active_comm_putc, "%c%c%c", 0x0c, (gblBurstModeCounter << 5) | (SensorVal >> 8), SensorVal & 0xff); 
303C:  MOVLB  1
303E:  SWAPF  xFA,W
3040:  MOVLB  2
3042:  MOVWF  xA9
3044:  RLCF   xA9,F
3046:  MOVLW  E0
3048:  ANDWF  xA9,F
304A:  MOVF   xA8,W
304C:  CLRF   03
304E:  IORWF  xA9,F
3050:  MOVFF  03,2AA
3054:  MOVFF  2A7,2AB
3058:  CLRF   xAC
305A:  MOVLW  0C
305C:  MOVWF  xE2
305E:  MOVLB  0
3060:  CALL   1D06
3064:  MOVFF  2A9,2E2
3068:  CALL   1D06
306C:  MOVFF  2AB,2E2
3070:  CALL   1D06
3074:  MOVLB  1
....................       } 
....................  
....................       // gblBurstModeCounter will circulate from 0 - 7 
....................       gblBurstModeCounter = (gblBurstModeCounter+1) % 8; 
3076:  MOVLW  01
3078:  ADDWF  xFA,W
307A:  ANDLW  07
307C:  MOVWF  xFA
....................        
....................       gblBurstModeTimerHasTicked = 0; 
307E:  MOVLB  0
3080:  BCF    x7F.5
....................     } 
....................  
....................  
....................  
....................  
.................... } 
3082:  GOTO   53D6 (RETURN)
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   S E N S O R   C O N T R O L 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void SetBurstMode(int SensorBits, int Mode) 
.................... { 
....................  
....................    gblBurstModeBits = SensorBits; 
2CA0:  MOVFF  2A7,1F9
....................     
....................    // As of gogo 4.0 there are no more slow/fast modes.  
....................    // Setting this here has no effect. 
....................    if (Mode > 0) 
2CA4:  MOVLB  2
2CA6:  MOVF   xA8,F
2CA8:  BZ    2CB0
....................       gblSlowBurstMode = 1; // switch to SLOW burst mode. 
2CAA:  MOVLB  0
2CAC:  BSF    x7F.4
....................    else 
2CAE:  BRA    2CB4
....................       gblSlowBurstMode = 0; // switch to normal (fast) burst mode. 
2CB0:  MOVLB  0
2CB2:  BCF    x7F.4
....................  
....................  
.................... } 
2CB4:  GOTO   5164 (RETURN)
....................  
....................  
.................... unsigned int16 readSensor(int sensorNo) { 
....................       if (gblCurSensorChannel != sensorNo) 
28A2:  MOVLB  2
28A4:  MOVF   xE1,W
28A6:  MOVLB  1
28A8:  SUBWF  xFB,W
28AA:  BZ    28B8
....................       {   switchAdcChannel(sensorNo); 
28AC:  MOVFF  2E1,2E2
28B0:  MOVLB  0
28B2:  BRA    283A
....................            gblCurSensorChannel=sensorNo; 
28B4:  MOVFF  2E1,1FB
....................       } 
....................       return(getSensorVal()); 
28B8:  MOVLB  0
28BA:  BRA    287A
28BC:  MOVF   02,W
.................... } 
28BE:  RETURN 0
....................  
....................  
....................  
.................... ///////////////////////////////////////////////// 
.................... long getSensorVal() 
.................... { 
....................    long sensorVal; 
....................  
....................    delay_us(channelSwitchDelay);   // wait for adc to stabilize 
287A:  MOVLW  64
287C:  MOVLB  2
287E:  MOVWF  xE4
2880:  MOVLB  0
2882:  RCALL  2854
....................                                    // Although this so often unneeded and can 
....................                                    // slow down the execution, we are playing 
....................                                    // it safe 
....................    sensorVal=read_adc(); 
2884:  BSF    FC2.1
2886:  BTFSC  FC2.1
2888:  BRA    2886
288A:  MOVFF  FC4,2E3
288E:  MOVLB  2
2890:  MOVFF  FC3,2E2
....................    //return (sensorVal >> 6);  // use this line if using PIC-C compiler version 2.x 
....................  
....................    // the PIC 16F77 ADC is only 8 bits. So, we simulate 10 bits by shifting 
....................    // left 2 bits. But why in the code we shif right 6 bits? This is because 
....................    // somehow the 8 bit sensor readings are stored in the higher byte 
....................    // of the long variable. So, we have to shift right 8 bits before shifting 
....................    // left. So, 8-2 is 6. 
....................    #IFDEF PIC16F77 
....................    sensorVal >>= 6; 
....................    #ENDIF 
....................  
....................    return (sensorVal);        // this line works with PIC-C compiler version 3.x 
2894:  MOVFF  2E2,01
2898:  MOVFF  2E3,02
....................  
.................... } 
289C:  MOVLB  0
289E:  GOTO   28BC (RETURN)
....................  
.................... ///////////////////////////////////////////////// 
.................... void switchAdcChannel(int channelNo) { 
....................    set_adc_channel(channelNo); 
283A:  MOVLB  2
283C:  RLCF   xE2,W
283E:  MOVWF  00
2840:  RLCF   00,F
2842:  MOVLW  FC
2844:  ANDWF  00,F
2846:  MOVF   FC2,W
2848:  ANDLW  C3
284A:  IORWF  00,W
284C:  MOVWF  FC2
.................... } 
284E:  MOVLB  0
2850:  GOTO   28B4 (RETURN)
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //  
.................... // Fetch a character from the serial buffer 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... byte readSerialBuffer(byte *charPtr) 
.................... { 
....................    int errorCode; 
....................     
....................    if (gblSerialBufferIsFull == TRUE) 
2108:  MOVLB  2
210A:  DECFSZ x43,W
210C:  BRA    2124
....................    { 
....................       gblSerialBufferIsFull = FALSE; 
210E:  CLRF   x43
....................       errorCode = SERIAL_OVERFLOW;    
2110:  MOVLW  02
2112:  MOVWF  xAD
....................       gblSerialBufferPutIndex = 0; 
2114:  CLRF   x41
....................       gblSerialBufferGetIndex = 0; 
2116:  CLRF   x42
....................       *charPtr = 0;       
2118:  MOVFF  2AB,FE9
211C:  MOVFF  2AC,FEA
2120:  CLRF   FEF
....................    } 
....................    else if (gblSerialBufferGetIndex == gblSerialBufferPutIndex)    
2122:  BRA    2168
2124:  MOVF   x41,W
2126:  SUBWF  x42,W
2128:  BNZ   2138
....................    { 
....................        errorCode = SERIAL_NO_DATA;       
212A:  CLRF   xAD
....................        *charPtr = 0; 
212C:  MOVFF  2AB,FE9
2130:  MOVFF  2AC,FEA
2134:  CLRF   FEF
....................    } 
....................    else 
2136:  BRA    2168
....................    { 
....................       *charPtr = gblSerialBuffer[gblSerialBufferGetIndex]; 
2138:  MOVFF  2AC,03
213C:  CLRF   03
213E:  MOVF   x42,W
2140:  ADDLW  21
2142:  MOVWF  FE9
2144:  MOVLW  02
2146:  ADDWFC 03,W
2148:  MOVWF  FEA
214A:  MOVFF  FEF,2B0
214E:  MOVFF  2AC,FEA
2152:  MOVFF  2AB,FE9
2156:  MOVFF  2B0,FEF
....................       gblSerialBufferGetIndex++; 
215A:  INCF   x42,F
....................       if (gblSerialBufferGetIndex >= SERIAL_BUFFER_SIZE) 
215C:  MOVF   x42,W
215E:  SUBLW  1F
2160:  BC    2164
....................       {  gblSerialBufferGetIndex = 0; 
2162:  CLRF   x42
....................       } 
....................       errorCode = SERIAL_SUCCESS;    
2164:  MOVLW  01
2166:  MOVWF  xAD
....................    } 
....................    return(errorCode); 
2168:  MOVFF  2AD,01
.................... } 
216C:  MOVLB  0
216E:  GOTO   2180 (RETURN)
....................  
....................  
.................... int1 serialKbhit() { 
....................    return(gblSerialBufferPutIndex != gblSerialBufferGetIndex); 
20F4:  MOVLB  2
20F6:  MOVF   x42,W
20F8:  SUBWF  x41,W
20FA:  BNZ   2100
20FC:  MOVLW  00
20FE:  BRA    2102
2100:  MOVLW  01
2102:  MOVWF  01
.................... } 
2104:  MOVLB  0
2106:  RETURN 0
....................  
.................... char serialGetChar() { 
....................    char foo; 
....................     
....................    readSerialBuffer(&foo); 
2172:  MOVLW  02
2174:  MOVLB  2
2176:  MOVWF  xAC
2178:  MOVLW  AA
217A:  MOVWF  xAB
217C:  MOVLB  0
217E:  BRA    2108
....................    return(foo); 
2180:  MOVLB  2
2182:  MOVFF  2AA,01
....................     
.................... } 
2186:  MOVLB  0
2188:  GOTO   24E2 (RETURN)
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   A D D - O N   M O D U L E S  
.................... // 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... void DoDisplayModuleStuff(void) { 
....................  
....................    // if i2c is being used 
....................    if (gblI2CisBusy) 
3198:  MOVLB  2
319A:  BTFSS  x0A.7
319C:  BRA    31A0
....................       return; 
319E:  BRA    31E2
....................        
....................    // if logo code is being downloaded 
....................    if (gblPauseI2CActivity) 
31A0:  BTFSS  x4F.4
31A2:  BRA    31A6
....................       return; 
31A4:  BRA    31E2
....................  
....................    // Auto detect a display module 
....................    // gblTimeToProbeDisplayModule increases every 0.1 sec in timer1 
....................    if ((gblTimeToProbeDisplayModule > 10) && (gblAutoDetectDisplays)) { 
31A6:  MOVF   x44,W
31A8:  SUBLW  0A
31AA:  BC    31CC
31AC:  BTFSS  x0A.6
31AE:  BRA    31CC
....................       gblDisplayAddress = displayPing(); 
31B0:  MOVLB  0
31B2:  BRA    3086
31B4:  MOVFF  01,246
....................       gblDisplayPresent = gblDisplayAddress? 1:0 ;  // gblDisplayPresent=1 if a display is found (gblDisplayAddress !=0) 
31B8:  MOVLB  2
31BA:  MOVF   x46,F
31BC:  BZ    31C2
31BE:  MOVLW  01
31C0:  BRA    31C4
31C2:  MOVLW  00
31C4:  BCF    x0A.5
31C6:  BTFSC  FE8.0
31C8:  BSF    x0A.5
....................       gblTimeToProbeDisplayModule = 0; 
31CA:  CLRF   x44
....................    } 
....................     
....................     
....................    // Send sensor values to the display module 
....................    // True if a display module is present or when manual mode is activated from the Logo code 
....................    // gblTimeToSendSensorValues is set in Timer2  
....................    if ((gblTimeToSendSensorValues > 3) && (gblDisplayPresent || !gblAutoDetectDisplays)) { 
31CC:  MOVF   x45,W
31CE:  SUBLW  03
31D0:  BC    31E2
31D2:  BTFSC  x0A.5
31D4:  BRA    31DA
31D6:  BTFSC  x0A.6
31D8:  BRA    31E2
....................       displaySendSensors(); 
31DA:  MOVLB  0
31DC:  BRA    3100
....................       gblTimeToSendSensorValues = 0; 
31DE:  MOVLB  2
31E0:  CLRF   x45
....................    } 
.................... }    
31E2:  MOVLB  0
31E4:  GOTO   53DA (RETURN)
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   M I S C 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... void init_variables() 
.................... {   
....................    gblBurstModeBits = 0; 
1F1C:  MOVLB  1
1F1E:  CLRF   xF9
....................  
....................    CMD_STATE = WAITING_FOR_FIRST_HEADER; 
1F20:  MOVLW  01
1F22:  MOVWF  xCA
....................  
....................  
....................    /////////////////////////////////// 
....................    // Logo VM variables 
....................    gblLogoIsRunning=0;         // if set, Lovo VM will start fetching opcode 
1F24:  MOVLB  2
1F26:  BCF    x0A.2
....................                      // from EEPROM and run them. 
....................    gblStkPtr=0;      // Stack pointer 
1F28:  MOVLB  0
1F2A:  CLRF   x82
....................    gblInputStkPtr=0; // Procedure input stack pointer 
1F2C:  MOVLB  1
1F2E:  CLRF   x04
....................    gblErrFlag=0;     // Error flag. Not really used. 
1F30:  MOVLB  0
1F32:  CLRF   x83
....................  
....................  
....................  
....................    // init the record pointer to the one last saved in the EEPROM 
....................    // see RECORD in evalopcode.c to see how this value is logged 
....................    #if defined(__PCM__) 
....................    gblRecordPtr = read_ext_eeprom(MEM_PTR_LOG_BASE_ADDRESS) + (read_ext_eeprom(MEM_PTR_LOG_BASE_ADDRESS+1) << 8); 
....................    #elif defined(__PCH__) 
....................    gblRecordPtr = read_program_eeprom(MEM_PTR_LOG_BASE_ADDRESS); 
1F34:  MOVFF  FF2,2A7
1F38:  BCF    FF2.7
1F3A:  CLRF   FF8
1F3C:  MOVLW  F9
1F3E:  MOVWF  FF7
1F40:  MOVLW  F0
1F42:  MOVWF  FF6
1F44:  TBLRD*+
1F46:  MOVF   FF5,W
1F48:  TBLRD*
1F4A:  MOVFF  FF5,03
1F4E:  CLRF   FF8
1F50:  MOVLB  2
1F52:  BTFSC  xA7.7
1F54:  BSF    FF2.7
1F56:  MOVLB  1
1F58:  MOVWF  xA9
1F5A:  MOVFF  03,1AA
....................     
....................    #endif 
.................... } 
1F5E:  MOVLB  0
1F60:  GOTO   507C (RETURN)
....................  
....................  
.................... void intro () 
.................... { 
....................  
....................     set_pwm1_duty(50);        // make a beep 
1FF0:  MOVLW  32
1FF2:  MOVWF  FBC
....................     output_high(RUN_LED); 
1FF4:  BSF    F8B.1
....................     delay_ms(50); 
1FF6:  MOVLB  9
1FF8:  MOVWF  x2B
1FFA:  MOVLB  0
1FFC:  RCALL  18F4
....................     set_pwm1_duty(0);         // stop the beep 
1FFE:  CLRF   FBC
....................     delay_ms(50); 
2000:  MOVLW  32
2002:  MOVLB  9
2004:  MOVWF  x2B
2006:  MOVLB  0
2008:  RCALL  18F4
....................     output_low(RUN_LED); 
200A:  BCF    F8B.1
....................  
....................     set_pwm1_duty(50);        // make a beep 
200C:  MOVLW  32
200E:  MOVWF  FBC
....................     USER_LED_ON;  
2010:  BSF    F8B.0
....................     delay_ms(50); 
2012:  MOVLB  9
2014:  MOVWF  x2B
2016:  MOVLB  0
2018:  RCALL  18F4
....................     set_pwm1_duty(0);         // stop the beep 
201A:  CLRF   FBC
....................     delay_ms(50); 
201C:  MOVLW  32
201E:  MOVLB  9
2020:  MOVWF  x2B
2022:  MOVLB  0
2024:  RCALL  18F4
....................     USER_LED_OFF;  
2026:  BCF    F8B.0
....................  
....................  
.................... } 
2028:  GOTO   20D6 (RETURN)
....................  
....................  
....................  
....................  
....................  
.................... void Halt() 
.................... {       while (1) { 
....................           output_high(RUN_LED); 
3674:  BSF    F8B.1
....................           delay_ms(50); 
3676:  MOVLW  32
3678:  MOVLB  9
367A:  MOVWF  x2B
367C:  MOVLB  0
367E:  CALL   18F4
....................           output_low(RUN_LED); 
3682:  BCF    F8B.1
....................           delay_ms(500); 
3684:  MOVLW  02
3686:  MOVLB  2
3688:  MOVWF  xE0
368A:  MOVLW  FA
368C:  MOVLB  9
368E:  MOVWF  x2B
3690:  MOVLB  0
3692:  CALL   18F4
3696:  MOVLB  2
3698:  DECFSZ xE0,F
369A:  BRA    368A
....................        } 
369C:  MOVLB  0
369E:  BRA    3674
....................  
.................... } 
36A0:  RETURN 0
....................  
....................  
.................... void clearMotors() { 
....................  
....................    int i,j; 
....................  
....................    // Disable both motor chips 
....................    output_low(MOTOR_AB_EN); 
1F64:  BCF    F8D.6
....................    output_low(MOTOR_CD_EN); 
1F66:  BCF    F8A.1
....................  
....................  
....................    // Init all motors to the coast state 
....................    for (i=0,j=0 ; i<MotorCount ; i++) 
1F68:  MOVLB  2
1F6A:  CLRF   xA9
1F6C:  CLRF   xAA
1F6E:  MOVF   xA9,W
1F70:  SUBLW  03
1F72:  BNC   1FE4
....................    {  // setLow(MotorENPins[i]);       // Mtr Enable pin 
....................       setLow(MotorCWPins[i]);   // Mtr CW pin. 
1F74:  BCF    FD8.0
1F76:  RLCF   xA9,W
1F78:  CLRF   03
1F7A:  ADDLW  BA
1F7C:  MOVWF  FE9
1F7E:  MOVLW  01
1F80:  ADDWFC 03,W
1F82:  MOVWF  FEA
1F84:  MOVFF  FEC,2AC
1F88:  MOVF   FED,F
1F8A:  MOVFF  FEF,2AB
1F8E:  CLRF   19
1F90:  BTFSC  FF2.7
1F92:  BSF    19.7
1F94:  BCF    FF2.7
1F96:  MOVFF  2AC,A4F
1F9A:  MOVFF  2AB,A4E
1F9E:  MOVLB  0
1FA0:  CALL   13C0
1FA4:  BTFSC  19.7
1FA6:  BSF    FF2.7
....................       setLow(MotorCCPins[i]);      // Mtr CCW pin 
1FA8:  BCF    FD8.0
1FAA:  MOVLB  2
1FAC:  RLCF   xA9,W
1FAE:  CLRF   03
1FB0:  ADDLW  C2
1FB2:  MOVWF  FE9
1FB4:  MOVLW  01
1FB6:  ADDWFC 03,W
1FB8:  MOVWF  FEA
1FBA:  MOVFF  FEC,2AC
1FBE:  MOVF   FED,F
1FC0:  MOVFF  FEF,2AB
1FC4:  CLRF   19
1FC6:  BTFSC  FF2.7
1FC8:  BSF    19.7
1FCA:  BCF    FF2.7
1FCC:  MOVFF  2AC,A4F
1FD0:  MOVFF  2AB,A4E
1FD4:  MOVLB  0
1FD6:  CALL   13C0
1FDA:  BTFSC  19.7
1FDC:  BSF    FF2.7
....................    } 
1FDE:  MOVLB  2
1FE0:  INCF   xA9,F
1FE2:  BRA    1F6E
....................     
.................... } 
1FE4:  MOVLB  0
1FE6:  RETURN 0
....................  
....................  
.................... void initBoard() 
.................... { 
....................    int i,j; 
....................  
....................  
....................  
....................    gblActiveMotors = 0; 
202C:  MOVLB  1
202E:  CLRF   xFD
....................  
....................    set_tris_a(PIC_TRIS_A); 
2030:  MOVLW  2F
2032:  MOVWF  F92
....................    set_tris_b(PIC_TRIS_B); 
2034:  MOVLW  01
2036:  MOVWF  F93
....................    set_tris_c(PIC_TRIS_C); 
2038:  MOVLW  90
203A:  MOVWF  F94
....................    set_tris_d(PIC_TRIS_D); 
203C:  MOVLW  00
203E:  MOVWF  F95
....................    set_tris_e(PIC_TRIS_E); 
2040:  MOVLW  80
2042:  MOVWF  F96
....................    set_tris_f(PIC_TRIS_F); 
2044:  MOVLW  7C
2046:  MOVWF  F97
....................    set_tris_g(PIC_TRIS_G); 
2048:  MOVLW  00
204A:  MOVWF  F98
....................  
....................  
....................    // Init the analog ports 
....................    setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN7|sAN10|sAN11, VSS_VDD);   // use all the 8 ADC ports. Pin names are not continguous on the 18F66J50 
204C:  BSF    FC0.4
204E:  MOVLW  60
2050:  MOVWF  FC1
2052:  BCF    FC0.4
2054:  BCF    FC2.6
2056:  BCF    FC2.7
2058:  BSF    FC0.4
205A:  MOVLW  F3
205C:  MOVWF  FC2
205E:  BCF    FC0.4
....................    setup_adc( ADC_CLOCK_DIV_64 | ADC_TAD_MUL_20 ); 
2060:  MOVF   FC1,W
2062:  ANDLW  C0
2064:  IORLW  3E
2066:  MOVWF  FC1
2068:  BSF    FC1.7
206A:  BSF    FC2.0
206C:  BSF    FC1.6
206E:  BSF    FC2.1
2070:  BTFSC  FC2.1
2072:  BRA    2070
2074:  BCF    FC1.6
.................... //   setup_adc(ADC_CLOCK_INTERNAL); 
....................  
....................    // Init default sensor port 
....................    gblCurSensorChannel=defaultPort; 
2076:  CLRF   xFB
....................    set_adc_channel( defaultPort ); 
2078:  MOVLW  00
207A:  MOVWF  01
207C:  MOVF   FC2,W
207E:  ANDLW  C3
2080:  IORWF  01,W
2082:  MOVWF  FC2
....................  
....................  
....................    clearMotors(); 
2084:  MOVLB  0
2086:  RCALL  1F64
....................  
....................  
....................    // init the serial port 
....................    //ser_init(); 
....................  
....................       // set RTCC to interrupt every 100ms 
....................       setup_timer_0( RTCC_INTERNAL| RTCC_DIV_128 ); 
2088:  MOVLW  86
208A:  MOVWF  FD5
....................       set_rtcc(T0_COUNTER); 
208C:  MOVLW  DB
208E:  MOVWF  FD7
2090:  MOVLW  61
2092:  MOVWF  FD6
....................       enable_interrupts(INT_RTCC); 
2094:  BSF    FF2.5
....................  
....................       setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_4 ); // int every (65536-T1_COUNTER) * 4 * 4 * 1/48 uSec 
2096:  MOVLW  A1
2098:  MOVWF  FCD
....................       enable_interrupts(INT_TIMER1); 
209A:  BSF    F9D.0
....................       set_timer1(0); 
209C:  CLRF   FCF
209E:  CLRF   FCE
....................                                                      
....................       //setup_timer_2(T2_DIV_BY_16,250,16); 
....................       setup_timer_2(T2_DIV_BY_16,250,8); 
20A0:  MOVLW  38
20A2:  IORLW  06
20A4:  MOVWF  FCA
20A6:  MOVLW  FA
20A8:  MOVWF  FCB
....................       enable_interrupts(INT_TIMER2); 
20AA:  BSF    F9D.1
....................          
....................       setup_timer_3( T3_INTERNAL | T3_DIV_BY_2 | T3_CCP2_TO_5); // T3 is used for the IR Capture. 0.6ms = 3600 counts (a SONY remote) 
20AC:  MOVLW  9D
20AE:  MOVWF  F79
....................       set_timer3(0); 
20B0:  CLRF   F7B
20B2:  CLRF   F7A
....................       enable_interrupts(INT_TIMER3); 
20B4:  BSF    FA0.1
....................        
....................       setup_ccp2( CCP_CAPTURE_FE ); // CCP2 is used for the IR receiver. Init to captuer a falling edge. 
20B6:  CLRF   FB6
20B8:  MOVLW  04
20BA:  MOVWF  FB6
20BC:  CLRF   FB9
20BE:  CLRF   FBA
....................       enable_interrupts(INT_CCP2);       
20C0:  BSF    FA0.0
....................  
....................       setup_ccp1(CCP_PWM);   // Configure CCP1 as a PWM (for the beeper) 
20C2:  BCF    F8B.2
20C4:  MOVLW  0C
20C6:  MOVWF  FBB
20C8:  CLRF   FBE
20CA:  CLRF   FBF
....................  
....................  
.................... //      setup_low_volt_detect( LVD_TRIGGER_BELOW | LVD_42 ); 
.................... //      enable_interrupts(INT_LOWVOLT); 
....................  
....................       enable_interrupts(INT_RDA); 
20CC:  BSF    F9D.5
....................  
....................       enable_interrupts(GLOBAL); 
20CE:  MOVLW  C0
20D0:  IORWF  FF2,F
....................  
....................  
....................    ///////////////////////////////////////////////// 
....................    // 
....................    //  Logo VM stuff 
....................    // 
....................       init_ext_eeprom(); 
20D2:  BRA    1FE8
....................  
....................  
....................     intro(); 
20D4:  BRA    1FF0
....................  
....................     delay_ms(500); // this dealy is to give the computer software time to 
20D6:  MOVLW  02
20D8:  MOVLB  2
20DA:  MOVWF  xA9
20DC:  MOVLW  FA
20DE:  MOVLB  9
20E0:  MOVWF  x2B
20E2:  MOVLB  0
20E4:  RCALL  18F4
20E6:  MOVLB  2
20E8:  DECFSZ xA9,F
20EA:  BRA    20DC
....................                      // kill any existing serial session in the case that this 
....................                      // boot is a reset. 
....................  
....................  
....................    // Initialize the USB device but does not stalls.  
....................    // usb_task() must be called periodically to check 
....................    // when a computer is connected. See usb.h for more info 
....................    usb_init_cs(); 
20EC:  MOVLB  0
20EE:  RCALL  1948
....................  
....................  
.................... } 
20F0:  GOTO   5080 (RETURN)
....................  
.................... #if defined(__PCH__) 
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   F L A S H   M E M O R Y   R O U T I N E S 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void FLASHSetWordAddress(int16 address) { 
....................  
....................       // calculate the address of the beginning of the current flash block 
....................       gblFlashBaseAddress = address; 
218C:  MOVFF  2E7,299
2190:  MOVFF  2E6,298
....................       gblFlashBaseAddress &= ((getenv("FLASH_ERASE_SIZE")-1) ^ 0xFFFF); // ^ => XOR 
2194:  MOVLB  2
2196:  CLRF   x98
2198:  MOVLW  FC
219A:  ANDWF  x99,F
....................        
....................       // calculate the position within the current flash block 
....................       gblFlashOffsetIndex = address - gblFlashBaseAddress; 
219C:  MOVF   x98,W
219E:  SUBWF  xE6,W
21A0:  MOVWF  x96
21A2:  MOVF   x99,W
21A4:  SUBWFB xE7,W
21A6:  MOVWF  x97
....................       //gblFlashOffsetIndex <<= 1; // ptr points to each byte in the buffer (not word) 
....................        
....................       gblFlashBufferCounter = 0;  // reset the buffer index 
21A8:  CLRF   x9B
21AA:  CLRF   x9A
....................        
....................  
.................... } 
21AC:  MOVLB  0
21AE:  RETURN 0
....................  
.................... void FLASHBufferedWrite(int16 InByte) { 
....................        
....................       gblFlashBuffer[gblFlashBufferCounter++] = (int)InByte; 
246A:  MOVLB  2
246C:  MOVFF  29B,03
2470:  MOVF   x9A,W
2472:  INCF   x9A,F
2474:  BTFSC  FD8.2
2476:  INCF   x9B,F
2478:  MOVWF  xE4
247A:  MOVLW  56
247C:  ADDWF  xE4,W
247E:  MOVWF  FE9
2480:  MOVLW  02
2482:  ADDWFC 03,W
2484:  MOVWF  FEA
2486:  MOVFF  2E2,FEF
....................       gblFlashBuffer[gblFlashBufferCounter++] = (int)(InByte>>8);  // each readable flash block is 2 bytes (we use only one here). 
248A:  MOVFF  29B,03
248E:  MOVF   x9A,W
2490:  INCF   x9A,F
2492:  BTFSC  FD8.2
2494:  INCF   x9B,F
2496:  MOVWF  xE4
2498:  MOVFF  03,2E5
249C:  MOVLW  56
249E:  ADDWF  xE4,W
24A0:  MOVWF  FE9
24A2:  MOVLW  02
24A4:  ADDWFC 03,W
24A6:  MOVWF  FEA
24A8:  MOVF   xE3,W
24AA:  MOVWF  FEF
....................                      
....................       // when the buffer contains FLASH_WRITE_SIZE bytes -> write to the actual flash memory 
....................       if (!(gblFlashBufferCounter < getenv("FLASH_WRITE_SIZE") )) { 
24AC:  MOVF   x9B,F
24AE:  BNZ   24B6
24B0:  MOVF   x9A,W
24B2:  SUBLW  3F
24B4:  BC    24BC
....................        
....................          FLASHFlushBuffer();          
24B6:  MOVLB  0
24B8:  RCALL  2414
24BA:  MOVLB  2
....................       } 
.................... } 
24BC:  MOVLB  0
24BE:  RETURN 0
....................  
.................... // Write directely to the Flash without buffering. This will be slow. 
....................  
.................... void FLASHWrite(int16 InByte) { 
....................        
....................       FLASHBufferedWrite(InByte); 
2CF0:  MOVFF  2E1,2E3
2CF4:  MOVFF  2E0,2E2
2CF8:  CALL   246A
....................       FLASHFlushBuffer(); 
2CFC:  CALL   2414
....................  
.................... } 
2D00:  RETURN 0
....................  
....................  
.................... void FLASHFlushBuffer() { 
....................  
....................       if (gblFlashBufferCounter > 0) { 
2414:  MOVLB  2
2416:  MOVF   x9A,F
2418:  BNZ   241E
241A:  MOVF   x9B,F
241C:  BZ    2466
....................          writeFLASH(gblFlashBaseAddress, gblFlashOffsetIndex, gblFlashBufferCounter, gblFlashBuffer); 
241E:  MOVFF  299,2E5
2422:  MOVFF  298,2E4
2426:  MOVFF  297,2E7
242A:  MOVFF  296,2E6
242E:  MOVFF  29B,2E9
2432:  MOVFF  29A,2E8
2436:  MOVLW  02
2438:  MOVWF  xEB
243A:  MOVLW  56
243C:  MOVWF  xEA
243E:  MOVLB  0
2440:  BRA    2234
....................  
....................          FLASHSetWordAddress(gblFlashBaseAddress + gblFlashOffsetIndex + gblFlashBufferCounter ); 
2442:  MOVLB  2
2444:  MOVF   x96,W
2446:  ADDWF  x98,W
2448:  MOVWF  xE4
244A:  MOVF   x97,W
244C:  ADDWFC x99,W
244E:  MOVWF  xE5
2450:  MOVF   x9A,W
2452:  ADDWF  xE4,F
2454:  MOVF   x9B,W
2456:  ADDWFC xE5,F
2458:  MOVFF  2E5,2E7
245C:  MOVFF  2E4,2E6
2460:  MOVLB  0
2462:  RCALL  218C
2464:  MOVLB  2
....................  
....................       } 
.................... } 
2466:  MOVLB  0
2468:  RETURN 0
....................  
....................  
.................... // Writes data to flash memory using block mode 
.................... // On PIC16F887, Write Size = 8 Words (16 Bytes), Erase size = 16 Words (32 Bytes) 
.................... // On PIC18F458, Write Size = 8 Bytes, Erase size = 64 Bytes 
.................... // - Whenever we write to the beginning of an erase block, the entire block (16 words) will be 
.................... //   automatically erased (set to 0x3FFF).  
.................... // - So, whenever we want to write some bytes to the flash memory, we need to read the entire 
.................... //   erase block into a buffer, modify that buffer, then write it back to the flash memory. 
....................  
....................  
....................  
.................... void writeFLASH(int16 memoryBlockAddress, int16 positionInMemoryBlock, int16 len, int *Buffer) { 
2234:  MOVLB  2
2236:  BSF    xF2.0
....................  
....................    int writeBuffer[getenv("FLASH_ERASE_SIZE")]; 
....................    int16 i, counter; 
....................    int16 writeLenInThisBlock; 
....................    int1 notDone = 1; 
....................  
....................    // prevent flash write to the firmware area 
....................    if (memoryBlockAddress < RECORD_BASE_ADDRESS) { 
2238:  MOVF   xE5,W
223A:  SUBLW  57
223C:  BNC   225C
....................       while (1) { beep(); delay_ms(1000); }   
223E:  MOVLB  0
2240:  RCALL  2222
2242:  MOVLW  04
2244:  MOVLB  2
2246:  MOVWF  xF3
2248:  MOVLW  FA
224A:  MOVLB  9
224C:  MOVWF  x2B
224E:  MOVLB  0
2250:  CALL   18F4
2254:  MOVLB  2
2256:  DECFSZ xF3,F
2258:  BRA    2248
225A:  BRA    223E
....................    } 
....................  
....................  
....................    do { 
....................     
....................       // read the entire erase block to memory 
....................       read_program_memory(memoryBlockAddress, writeBuffer, getenv("FLASH_ERASE_SIZE")); 
225C:  CLRF   FF8
225E:  MOVFF  2E5,FF7
2262:  MOVFF  2E4,FF6
2266:  MOVLW  05
2268:  MOVWF  FEA
226A:  MOVLW  23
226C:  MOVWF  FE9
226E:  MOVLW  04
2270:  MOVLB  9
2272:  MOVWF  x2B
2274:  CLRF   x2A
2276:  MOVLB  0
2278:  CALL   1A40
....................       usb_task(); 
227C:  CALL   1972
....................        
....................       // if write len is longer than the current memory block -> trim it 
....................       if ( len > (getenv("FLASH_ERASE_SIZE") - positionInMemoryBlock)) { 
2280:  MOVLW  00
2282:  BSF    FD8.0
2284:  MOVLB  2
2286:  SUBFWB xE6,W
2288:  MOVWF  00
228A:  MOVLW  04
228C:  SUBFWB xE7,W
228E:  MOVWF  03
2290:  MOVFF  00,01
2294:  MOVF   03,W
2296:  SUBWF  xE9,W
2298:  BNC   22B2
229A:  BNZ   22A2
229C:  MOVF   xE8,W
229E:  SUBWF  01,W
22A0:  BC    22B2
....................          writeLenInThisBlock = getenv("FLASH_ERASE_SIZE") - positionInMemoryBlock; 
22A2:  MOVLW  00
22A4:  BSF    FD8.0
22A6:  SUBFWB xE6,W
22A8:  MOVWF  xF0
22AA:  MOVLW  04
22AC:  SUBFWB xE7,W
22AE:  MOVWF  xF1
....................       } else { 
22B0:  BRA    22BA
....................          writeLenInThisBlock = len; 
22B2:  MOVFF  2E9,2F1
22B6:  MOVFF  2E8,2F0
....................       } 
....................        
....................       // modify parts of the block with the new data 
....................       for (i=positionInMemoryBlock, counter=0; counter<writeLenInThisBlock; i++, counter++) { 
22BA:  MOVFF  2E7,2ED
22BE:  MOVFF  2E6,2EC
22C2:  CLRF   xEF
22C4:  CLRF   xEE
22C6:  MOVF   xEF,W
22C8:  SUBWF  xF1,W
22CA:  BNC   2318
22CC:  BNZ   22D4
22CE:  MOVF   xF0,W
22D0:  SUBWF  xEE,W
22D2:  BC    2318
....................          writeBuffer[i] = *(Buffer+counter); 
22D4:  MOVLW  23
22D6:  ADDWF  xEC,W
22D8:  MOVWF  01
22DA:  MOVLW  05
22DC:  ADDWFC xED,W
22DE:  MOVFF  01,2F3
22E2:  MOVWF  xF4
22E4:  MOVF   xEE,W
22E6:  ADDWF  xEA,W
22E8:  MOVWF  01
22EA:  MOVF   xEF,W
22EC:  ADDWFC xEB,W
22EE:  MOVFF  01,FE9
22F2:  MOVWF  FEA
22F4:  MOVFF  FEF,2F5
22F8:  MOVFF  2F4,FEA
22FC:  MOVFF  2F3,FE9
2300:  MOVFF  2F5,FEF
....................       } 
2304:  MOVFF  2ED,03
2308:  MOVF   xEC,W
230A:  INCF   xEC,F
230C:  BTFSC  FD8.2
230E:  INCF   xED,F
2310:  INCF   xEE,F
2312:  BTFSC  FD8.2
2314:  INCF   xEF,F
2316:  BRA    22C6
....................       usb_task(); 
2318:  MOVLB  0
231A:  CALL   1972
....................        
....................       // write the block back to the flash memory.  
....................       for (i=0 ; i< getenv("FLASH_ERASE_SIZE") / getenv("FLASH_WRITE_SIZE"); i++) { 
231E:  MOVLB  2
2320:  CLRF   xED
2322:  CLRF   xEC
2324:  MOVF   xED,F
2326:  BNZ   23B0
2328:  MOVF   xEC,W
232A:  SUBLW  0F
232C:  BNC   23B0
....................          write_program_memory( memoryBlockAddress + i * getenv("FLASH_WRITE_SIZE") , 
....................                                writeBuffer + i * getenv("FLASH_WRITE_SIZE"),  
....................                                getenv("FLASH_WRITE_SIZE")); 
232E:  RLCF   xEC,W
2330:  MOVWF  02
2332:  RLCF   xED,W
2334:  MOVWF  03
2336:  RLCF   02,F
2338:  RLCF   03,F
233A:  RLCF   02,F
233C:  RLCF   03,F
233E:  RLCF   02,F
2340:  RLCF   03,F
2342:  RLCF   02,F
2344:  RLCF   03,F
2346:  RLCF   02,F
2348:  RLCF   03,F
234A:  MOVLW  C0
234C:  ANDWF  02,F
234E:  MOVF   02,W
2350:  ADDWF  xE4,W
2352:  MOVWF  xF3
2354:  MOVF   03,W
2356:  ADDWFC xE5,W
2358:  MOVWF  xF4
235A:  RLCF   xEC,W
235C:  MOVWF  02
235E:  RLCF   xED,W
2360:  MOVWF  03
2362:  RLCF   02,F
2364:  RLCF   03,F
2366:  RLCF   02,F
2368:  RLCF   03,F
236A:  RLCF   02,F
236C:  RLCF   03,F
236E:  RLCF   02,F
2370:  RLCF   03,F
2372:  RLCF   02,F
2374:  RLCF   03,F
2376:  MOVLW  C0
2378:  ANDWF  02,F
237A:  MOVF   02,W
237C:  ADDLW  23
237E:  MOVWF  xF5
2380:  MOVLW  05
2382:  ADDWFC 03,W
2384:  MOVWF  xF6
2386:  CLRF   FF8
2388:  MOVFF  2F4,FF7
238C:  MOVFF  2F3,FF6
2390:  MOVWF  FEA
2392:  MOVFF  2F5,FE9
2396:  MOVLW  40
2398:  MOVLB  9
239A:  MOVWF  x2E
239C:  MOVLB  0
239E:  CALL   1A7C
....................          usb_task(); 
23A2:  CALL   1972
....................       } 
23A6:  MOVLB  2
23A8:  INCF   xEC,F
23AA:  BTFSC  FD8.2
23AC:  INCF   xED,F
23AE:  BRA    2324
....................        
....................       // if write-data overlaps between memory blocks -> update variables and 
....................       // loop to write the next block 
....................       if ((positionInMemoryBlock + len) > getenv("FLASH_ERASE_SIZE")) { 
23B0:  MOVF   xE8,W
23B2:  ADDWF  xE6,W
23B4:  MOVWF  xF3
23B6:  MOVF   xE9,W
23B8:  ADDWFC xE7,W
23BA:  MOVWF  xF4
23BC:  SUBLW  03
23BE:  BC    2400
23C0:  XORLW  FF
23C2:  BNZ   23CA
23C4:  MOVF   xF3,W
23C6:  SUBLW  00
23C8:  BC    2400
....................          memoryBlockAddress += getenv("FLASH_ERASE_SIZE"); 
23CA:  MOVLW  04
23CC:  ADDWF  xE5,F
....................          len -= getenv("FLASH_ERASE_SIZE") - positionInMemoryBlock; 
23CE:  MOVLW  00
23D0:  BSF    FD8.0
23D2:  SUBFWB xE6,W
23D4:  MOVWF  00
23D6:  MOVLW  04
23D8:  SUBFWB xE7,W
23DA:  MOVWF  03
23DC:  MOVF   00,W
23DE:  SUBWF  xE8,F
23E0:  MOVF   03,W
23E2:  SUBWFB xE9,F
....................          Buffer += getenv("FLASH_ERASE_SIZE") - positionInMemoryBlock; 
23E4:  MOVLW  00
23E6:  BSF    FD8.0
23E8:  SUBFWB xE6,W
23EA:  MOVWF  00
23EC:  MOVLW  04
23EE:  SUBFWB xE7,W
23F0:  MOVWF  03
23F2:  MOVF   00,W
23F4:  ADDWF  xEA,F
23F6:  MOVF   03,W
23F8:  ADDWFC xEB,F
....................          positionInMemoryBlock = 0; 
23FA:  CLRF   xE7
23FC:  CLRF   xE6
....................  
....................       } else { 
23FE:  BRA    2402
....................          notDone = 0; 
2400:  BCF    xF2.0
....................       } 
....................       usb_task(); 
2402:  MOVLB  0
2404:  CALL   1972
....................     
....................    } while (notDone); 
2408:  MOVLB  2
240A:  BTFSC  xF2.0
240C:  BRA    225C
.................... } 
240E:  MOVLB  0
2410:  GOTO   2442 (RETURN)
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   S E R I A L    D A T A    H A N D L E R 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void ProcessInput() 
.................... {   byte InByte; 
24C0:  MOVLB  2
24C2:  BSF    xA8.0
....................    int1 doNotStopRunningProcedure=1;   // if set means we've got a Logo cmd. We need to echo back. 
....................    int i; 
....................     
....................     
....................    //while ((buff_status = readSerialBuffer(&InByte)) == SERIAL_SUCCESS)  // fetch character 
....................    while ( usb_cdc_kbhit() || serialKbhit())  
....................    {         
24C4:  MOVLB  0
24C6:  BTFSC  x7C.0
24C8:  BRA    24D2
24CA:  RCALL  20F4
24CC:  MOVF   01,F
24CE:  BTFSC  FD8.2
24D0:  BRA    2834
....................             
....................             if (serialKbhit()) { 
24D2:  RCALL  20F4
24D4:  MOVF   01,F
24D6:  BZ    24EA
....................                gblCommChannel = COMM_SERIAL;  
24D8:  MOVLW  01
24DA:  MOVLB  2
24DC:  MOVWF  x9C
....................                InByte = serialGetChar(); 
24DE:  MOVLB  0
24E0:  BRA    2172
24E2:  MOVFF  01,2A7
....................                output_toggle(USER_LED); 
24E6:  BTG    F8B.0
....................              
....................             } else if (usb_cdc_kbhit()) { 
24E8:  BRA    24FE
24EA:  BTFSS  x7C.0
24EC:  BRA    24FE
....................                gblCommChannel = COMM_USB; 
24EE:  MOVLW  02
24F0:  MOVLB  2
24F2:  MOVWF  x9C
....................                InByte = usb_cdc_getc(); 
24F4:  MOVLB  0
24F6:  CALL   19A6
24FA:  MOVFF  01,2A7
....................             } 
....................              
....................             // reset the command timeout counter 
....................             gblCmdTimeOut = 0 ; 
24FE:  MOVLB  2
2500:  CLRF   x20
....................  
....................             // this is for the SERIAL? command in the Logo VM 
....................             // No matter what the input bytes are for, we 
....................             // make it available to the Logo VM. 
....................             gblMostRecentlyReceivedByte = InByte; 
2502:  MOVFF  2A7,21B
....................             gblNewByteHasArrivedFlag = 1; 
2506:  BSF    x0A.1
....................  
....................  
....................             // always send an echo byte back to the PC. 
....................             printf(active_comm_putc, "%c",InByte); 
2508:  MOVFF  2A7,2E2
250C:  MOVLB  0
250E:  CALL   1D06
....................  
....................  
....................             switch (CMD_STATE) { 
2512:  MOVLB  1
2514:  MOVF   xCA,W
2516:  XORLW  01
2518:  MOVLB  0
251A:  BZ    2572
251C:  XORLW  03
251E:  BTFSC  FD8.2
2520:  BRA    260C
2522:  XORLW  01
2524:  BTFSC  FD8.2
2526:  BRA    261E
2528:  XORLW  07
252A:  BTFSC  FD8.2
252C:  BRA    267C
252E:  XORLW  01
2530:  BTFSC  FD8.2
2532:  BRA    268A
2534:  XORLW  03
2536:  BTFSC  FD8.2
2538:  BRA    268E
253A:  XORLW  01
253C:  BTFSC  FD8.2
253E:  BRA    269E
2540:  XORLW  87
2542:  BTFSC  FD8.2
2544:  BRA    26CE
2546:  XORLW  01
2548:  BTFSC  FD8.2
254A:  BRA    26E2
254C:  XORLW  03
254E:  BTFSC  FD8.2
2550:  BRA    276C
2552:  XORLW  01
2554:  BTFSC  FD8.2
2556:  BRA    277C
2558:  XORLW  07
255A:  BTFSC  FD8.2
255C:  BRA    27AA
255E:  XORLW  01
2560:  BTFSC  FD8.2
2562:  BRA    27BA
2564:  XORLW  03
2566:  BTFSC  FD8.2
2568:  BRA    27CA
256A:  XORLW  01
256C:  BTFSC  FD8.2
256E:  BRA    2806
2570:  BRA    281C
....................  
....................  
....................             /////////////////////////////////////////////////////// 
....................             // 
....................             //  if the board is idle, we need to distinguish which 
....................             //  mode we are running, GoGo or Cricket Logo 
....................             case WAITING_FOR_FIRST_HEADER: 
....................                   switch (InByte) { 
2572:  MOVLB  2
2574:  MOVF   xA7,W
2576:  XORLW  54
2578:  MOVLB  0
257A:  BZ    2592
257C:  XORLW  D7
257E:  BZ    259C
2580:  XORLW  07
2582:  BZ    25AC
2584:  XORLW  01
2586:  BZ    25BA
2588:  XORLW  03
258A:  BZ    25C8
258C:  XORLW  01
258E:  BZ    25E2
2590:  BRA    25EE
....................                     //////////////////////////////////// 
....................                     // this is a GoGo header 
....................                     case InHeader1: 
....................                           CMD_STATE = WAITING_FOR_SECOND_HEADER; 
2592:  MOVLW  02
2594:  MOVLB  1
2596:  MOVWF  xCA
....................                           //doNotStopRunningProcedure = 1; 
....................                           break; 
2598:  MOVLB  0
259A:  BRA    25EE
....................                     //////////////////////////////////// 
....................                     // the rest are Cricket Logo headers 
....................                     case SET_PTR:   // set-pointer 
....................                           CMD_STATE = SET_PTR_HI_BYTE; 
259C:  MOVLW  80
259E:  MOVLB  1
25A0:  MOVWF  xCA
....................                           doNotStopRunningProcedure=0; 
25A2:  MOVLB  2
25A4:  BCF    xA8.0
....................                           output_toggle(USER_LED); 
25A6:  BTG    F8B.0
....................                           break; 
25A8:  MOVLB  0
25AA:  BRA    25EE
....................                     case READ_BYTES:   // read-bytes 
....................                           CMD_STATE = READ_BYTES_COUNT_HI; 
25AC:  MOVLW  82
25AE:  MOVLB  1
25B0:  MOVWF  xCA
....................                           doNotStopRunningProcedure=0; 
25B2:  MOVLB  2
25B4:  BCF    xA8.0
....................                           break; 
25B6:  MOVLB  0
25B8:  BRA    25EE
....................                     case WRITE_BYTES:   // write-bytes 
....................                           CMD_STATE = WRITE_BYTES_COUNT_HI; 
25BA:  MOVLW  84
25BC:  MOVLB  1
25BE:  MOVWF  xCA
....................                           doNotStopRunningProcedure=0; 
25C0:  MOVLB  2
25C2:  BCF    xA8.0
....................                           break; 
25C4:  MOVLB  0
25C6:  BRA    25EE
....................                     case RUN:   // run 
....................                           //doNotStopRunningProcedure = 1; 
....................  
....................                           /////////////////////////////////// 
....................                           // start runing logo 
....................                           output_high(RUN_LED); 
25C8:  BSF    F8B.1
....................                           gblWaitCounter = 0;  // reset wait command (so any running Logo wait code 
25CA:  MOVLB  2
25CC:  CLRF   x1D
25CE:  CLRF   x1C
....................                                                // stops immediately). 
....................                           gblONFORNeedsToFinish = 0; // in case an onfor is running. 
25D0:  MOVLB  0
25D2:  BCF    x7F.1
....................                           clearStack(); 
25D4:  CALL   1248
....................                           gblNewByteHasArrivedFlag = 0; 
25D8:  MOVLB  2
25DA:  BCF    x0A.1
....................                           gblLogoIsRunning = 1; 
25DC:  BSF    x0A.2
....................                           //////////////////////////////////// 
....................  
....................                           break; 
25DE:  MOVLB  0
25E0:  BRA    25EE
....................                     case CRICKET_CHECK:  // cricket-check 
....................                           CMD_STATE = CRICKET_NAME; 
25E2:  MOVLW  87
25E4:  MOVLB  1
25E6:  MOVWF  xCA
....................                           doNotStopRunningProcedure=0; 
25E8:  MOVLB  2
25EA:  BCF    xA8.0
....................                           break; 
25EC:  MOVLB  0
....................                   }; 
....................  
....................                     // Stop any running logo procedures unless we got a "RUN" command 
....................                     // or if we got a thethered gogo command 
....................                     // which will set doNotStopRunningProcedure to 1 
....................                     if (!doNotStopRunningProcedure) { 
25EE:  MOVLB  2
25F0:  BTFSC  xA8.0
25F2:  BRA    260A
25F4:  CLRF   19
25F6:  BTFSC  FF2.7
25F8:  BSF    19.7
25FA:  BCF    FF2.7
....................                         stopLogoProcedures();                             
25FC:  MOVLB  0
25FE:  CALL   1262
2602:  BTFSC  19.7
2604:  BSF    FF2.7
....................                         doNotStopRunningProcedure=1; 
2606:  MOVLB  2
2608:  BSF    xA8.0
....................                     } 
....................                      
....................  
....................                  break; 
260A:  BRA    2824
....................  
....................             ///////////////////////////////////////////////////////////////// 
....................             // 
....................             //   These are GoGo states 
....................             // 
....................             case WAITING_FOR_SECOND_HEADER: 
....................                 if (InByte == InHeader2) CMD_STATE = WAITING_FOR_CMD_BYTE; 
260C:  MOVLB  2
260E:  MOVF   xA7,W
2610:  SUBLW  FE
2612:  BNZ   261C
2614:  MOVLW  03
2616:  MOVLB  1
2618:  MOVWF  xCA
261A:  MOVLB  2
....................                 break; 
261C:  BRA    2824
....................             case WAITING_FOR_CMD_BYTE: 
....................                  gbl_cur_cmd    =(InByte & 0b11100000) >> 5; // bit 5,6,7 are the command bits 
261E:  MOVLB  2
2620:  MOVF   xA7,W
2622:  ANDLW  E0
2624:  MOVWF  00
2626:  SWAPF  00,W
2628:  MOVLB  1
262A:  MOVWF  xCB
262C:  RRCF   xCB,F
262E:  MOVLW  07
2630:  ANDWF  xCB,F
....................                  gbl_cur_param   =(InByte & 0b00011100) >> 2; // bit 2,3,4 are parameter bits for motors and sensors. 
2632:  MOVLB  2
2634:  MOVF   xA7,W
2636:  ANDLW  1C
2638:  MOVWF  00
263A:  RRCF   00,W
263C:  MOVLB  1
263E:  MOVWF  xCC
2640:  RRCF   xCC,F
2642:  MOVLW  3F
2644:  ANDWF  xCC,F
....................                  gbl_cur_ext      =(InByte & 0b00000011); 
2646:  MOVLB  2
2648:  MOVF   xA7,W
264A:  ANDLW  03
264C:  MOVLB  1
264E:  MOVWF  xCD
....................  
....................                gblExtCmdMode = 0;  // Turn extended command mode off by default 
2650:  MOVLB  0
2652:  BCF    x7F.3
....................                // if cmd byte is 0xff -> we switch to extended command mode 
....................                if (InByte == 0b11111111) { 
2654:  MOVLB  2
2656:  INCFSZ xA7,W
2658:  BRA    2666
....................                    CMD_STATE = WAITING_FOR_EXT_CMD_LENGTH; 
265A:  MOVLW  06
265C:  MOVLB  1
265E:  MOVWF  xCA
....................                    gblExtCmdMode = 1; // flag an extended command mode 
2660:  MOVLB  0
2662:  BSF    x7F.3
....................                } else if (gbl_cur_cmd > ONE_BYTE_CMD) 
2664:  BRA    2678
2666:  MOVLB  1
2668:  MOVF   xCB,W
266A:  SUBLW  03
266C:  BC    2674
....................                {   CMD_STATE = WAITING_FOR_SECOND_CMD_BYTE; 
266E:  MOVLW  04
2670:  MOVWF  xCA
....................                } else 
2672:  BRA    2678
....................                {   CMD_STATE = CMD_READY; 
2674:  MOVLW  05
2676:  MOVWF  xCA
....................                } 
....................                break; 
2678:  MOVLB  2
267A:  BRA    2824
....................             case WAITING_FOR_SECOND_CMD_BYTE: 
....................  
....................                 gbl_cur_ext_byte = InByte; 
267C:  MOVFF  2A7,1CE
....................                 CMD_STATE = CMD_READY; 
2680:  MOVLW  05
2682:  MOVLB  1
2684:  MOVWF  xCA
....................                 break; 
2686:  MOVLB  2
2688:  BRA    2824
....................             case CMD_READY: 
....................                
....................                break; 
268A:  MOVLB  2
268C:  BRA    2824
....................  
....................           
....................             ///////////////////////////////////////////////////////////////// 
....................             // 
....................             //   These are GoGo Extended Command States 
....................             // 
....................             ////////////////////////////////////////////////////////////// 
....................           
....................             case WAITING_FOR_EXT_CMD_LENGTH: 
....................                 gblExtCmdLen = InByte; 
268E:  MOVFF  2A7,1EF
....................                 gblExtCmdBufferIndex = 0; 
2692:  MOVLB  1
2694:  CLRF   xF0
....................                 CMD_STATE = WAITING_FOR_EXT_CMD_STREAM; 
2696:  MOVLW  07
2698:  MOVWF  xCA
....................                break; 
269A:  MOVLB  2
269C:  BRA    2824
....................  
....................             case WAITING_FOR_EXT_CMD_STREAM: 
....................                 
....................                if (gblExtCmdBufferIndex == 0) { 
269E:  MOVLB  1
26A0:  MOVF   xF0,F
26A2:  BNZ   26AA
....................                   gbl_cur_cmd    = InByte ; 
26A4:  MOVFF  2A7,1CB
....................                } else { 
26A8:  BRA    26BE
....................                   gblExtCMDBuffer[gblExtCmdBufferIndex-1] = InByte; 
26AA:  MOVLW  01
26AC:  SUBWF  xF0,W
26AE:  CLRF   03
26B0:  ADDLW  CF
26B2:  MOVWF  FE9
26B4:  MOVLW  01
26B6:  ADDWFC 03,W
26B8:  MOVWF  FEA
26BA:  MOVFF  2A7,FEF
....................                } 
....................                 
....................                gblExtCmdBufferIndex++; 
26BE:  INCF   xF0,F
....................                 
....................                // if we have received all the command bytes -> finish 
....................                if (gblExtCmdBufferIndex == gblExtCmdLen) { 
26C0:  MOVF   xEF,W
26C2:  SUBWF  xF0,W
26C4:  BNZ   26CA
....................                   CMD_STATE = CMD_READY; 
26C6:  MOVLW  05
26C8:  MOVWF  xCA
....................                } 
....................              
....................                break; 
26CA:  MOVLB  2
26CC:  BRA    2824
....................  
....................  
....................             ///////////////////////////////////////////////////////////////// 
....................             // 
....................             //   These are Cricket Logo states 
....................             // 
....................             ////////////////////////////////////////////////////////////// 
....................  
....................             //  set-pointer 
....................             case SET_PTR_HI_BYTE:  /* get addr high byte */ 
....................                // When download is in progress -> we do not allow i2c activity 
....................                // as it can interfere and cause problems. 
....................                gblPauseI2CActivity = 1; 
26CE:  MOVLB  2
26D0:  BSF    x4F.4
....................                 
....................                gblMemPtr = (unsigned int16) InByte << 8; 
26D2:  MOVFF  2A7,1AC
26D6:  MOVLB  1
26D8:  CLRF   xAB
....................                CMD_STATE = SET_PTR_LOW_BYTE; 
26DA:  MOVLW  81
26DC:  MOVWF  xCA
.................... //                     printf("%c",CMD_STATE); 
....................                break; 
26DE:  MOVLB  2
26E0:  BRA    2824
....................             case SET_PTR_LOW_BYTE:  /* get addr low byte */ 
....................  
....................                gblMemPtr = gblMemPtr | InByte; 
26E2:  MOVLB  2
26E4:  MOVF   xA7,W
26E6:  MOVLB  1
26E8:  IORWF  xAB,F
....................                CMD_STATE = WAITING_FOR_FIRST_HEADER; 
26EA:  MOVLW  01
26EC:  MOVWF  xCA
....................  
....................                gblMemPtr = gblMemPtr << 1;    // change from word addres to byte address 
26EE:  BCF    FD8.0
26F0:  RLCF   xAB,F
26F2:  RLCF   xAC,F
....................  
....................                // Since gogo stores the run button vector at a different memory location, 
....................                // we must map it correctly. 
....................                // so, any thing between 0xff0-0xfff will be mapped to the GoGo's address 
....................  
....................                // True when gblMemPtr is between 0x1FE0 -> 0x1FFF 
....................                if ((gblMemPtr>>5) == 0xff) { 
26F4:  RRCF   xAC,W
26F6:  MOVLB  2
26F8:  MOVWF  xAB
26FA:  MOVLB  1
26FC:  RRCF   xAB,W
26FE:  MOVLB  2
2700:  MOVWF  xAA
2702:  RRCF   xAB,F
2704:  RRCF   xAA,F
2706:  RRCF   xAB,F
2708:  RRCF   xAA,F
270A:  RRCF   xAB,F
270C:  RRCF   xAA,F
270E:  RRCF   xAB,F
2710:  RRCF   xAA,F
2712:  MOVLW  07
2714:  ANDWF  xAB,F
2716:  INCFSZ xAA,W
2718:  BRA    2750
271A:  MOVF   xAB,F
271C:  BNZ   2750
....................  
....................                   gblMemPtr = (RUN_BUTTON_BASE_ADDRESS + (gblMemPtr & 0xf)) - FLASH_USER_PROGRAM_BASE_ADDRESS ; 
271E:  MOVLB  1
2720:  MOVF   xAB,W
2722:  ANDLW  0F
2724:  MOVWF  00
2726:  CLRF   03
2728:  MOVF   00,W
272A:  ADDLW  E0
272C:  MOVLB  2
272E:  MOVWF  xAA
2730:  MOVLW  F9
2732:  ADDWFC 03,W
2734:  MOVWF  xAB
2736:  MOVLW  00
2738:  SUBWF  xAA,W
273A:  MOVLB  1
273C:  MOVWF  xAB
273E:  MOVLW  E8
2740:  MOVLB  2
2742:  SUBWFB xAB,W
2744:  MOVLB  1
2746:  MOVWF  xAC
....................  
....................                   //printf(usb_cdc_putc, "btn ptr = %Lu\r\n", gblMemPtr); 
....................  
....................                   // Logo code download almost complete. 
....................                   // Tells the main loop to beep.  Note. We don't beep here directly because beep() includes a 
....................                   // delay, which could cause trouble 
....................                   output_high(USER_LED); 
2748:  BSF    F8B.0
....................                   gblNeedToBeep = 1; 
274A:  MOVLB  2
274C:  BSF    x4F.3
....................                   gblPauseI2CActivity = 0; 
274E:  BCF    x4F.4
....................                   //cls_internal7Seg(); 
....................  
....................                } 
....................  
....................                 
....................           
....................  
....................                #if defined(__PCH__)  
....................                 
....................                FLASHSetWordAddress((FLASH_USER_PROGRAM_BASE_ADDRESS) + gblMemPtr); 
2750:  MOVFF  1AB,2AA
2754:  MOVLW  E8
2756:  MOVLB  1
2758:  ADDWF  xAC,W
275A:  MOVLB  2
275C:  MOVWF  xAB
275E:  MOVWF  xE7
2760:  MOVFF  1AB,2E6
2764:  MOVLB  0
2766:  RCALL  218C
....................                 
....................                
....................                #endif 
....................                 
....................                 
....................                break; 
2768:  MOVLB  2
276A:  BRA    2824
....................                 
....................  
....................             ////////////////////////////////////////////////////////////// 
....................             // read-bytes 
....................             case READ_BYTES_COUNT_HI:  /* get count high byte */ 
....................                gblRWCount = (unsigned int16) InByte << 8; 
276C:  MOVFF  2A7,1AE
2770:  MOVLB  1
2772:  CLRF   xAD
....................                CMD_STATE = READ_BYTES_COUNT_LOW; 
2774:  MOVLW  83
2776:  MOVWF  xCA
....................                break; 
2778:  MOVLB  2
277A:  BRA    2824
....................             case READ_BYTES_COUNT_LOW:  /* get count low byte */ 
....................                gblRWCount = gblRWCount | InByte; 
277C:  MOVLB  2
277E:  MOVF   xA7,W
2780:  MOVLB  1
2782:  IORWF  xAD,F
....................                sendBytes(gblMemPtr, gblRWCount); 
2784:  MOVFF  1AC,2AB
2788:  MOVFF  1AB,2AA
278C:  MOVFF  1AE,2AD
2790:  MOVFF  1AD,2AC
2794:  MOVLB  0
2796:  BRA    21B0
....................                gblMemPtr += gblRWCount;  // update the gblMemPtr 
2798:  MOVLB  1
279A:  MOVF   xAD,W
279C:  ADDWF  xAB,F
279E:  MOVF   xAE,W
27A0:  ADDWFC xAC,F
....................  
....................                CMD_STATE = WAITING_FOR_FIRST_HEADER; 
27A2:  MOVLW  01
27A4:  MOVWF  xCA
....................                break; 
27A6:  MOVLB  2
27A8:  BRA    2824
....................  
....................             ////////////////////////////////////////////////////////////// 
....................             // write-bytes 
....................             case WRITE_BYTES_COUNT_HI:  /* get count high byte */ 
....................                gblRWCount = (unsigned int16) InByte << 8; 
27AA:  MOVFF  2A7,1AE
27AE:  MOVLB  1
27B0:  CLRF   xAD
....................                CMD_STATE = WRITE_BYTES_COUNT_LOW; 
27B2:  MOVLW  85
27B4:  MOVWF  xCA
....................                break; 
27B6:  MOVLB  2
27B8:  BRA    2824
....................             case WRITE_BYTES_COUNT_LOW:  /* get count low byte */ 
....................                gblRWCount = gblRWCount | InByte; 
27BA:  MOVLB  2
27BC:  MOVF   xA7,W
27BE:  MOVLB  1
27C0:  IORWF  xAD,F
....................                CMD_STATE = WRITE_BYTES_SENDING; 
27C2:  MOVLW  86
27C4:  MOVWF  xCA
....................  
....................              
....................              
.................... //            #if defined(__PCH__) 
.................... //               // if downloading a Logo program -> must erase all the flash memory blocks used to strore the Logo programs  
.................... //               if (gblMemPtr == 0) { 
.................... //                  for (memoryBlockAddress=FLASH_USER_PROGRAM_BASE_ADDRESS ; memoryBlockAddress < FLASH_BOOTLOADER_BASE_ADDRESS ; memoryBlockAddress += (getenv("FLASH_ERASE_SIZE")>>1)) { 
.................... //                     erase_program_eeprom(memoryBlockAddress<<1 ); 
.................... //                  } 
.................... //               } 
.................... //            #endif 
....................  
....................                break; 
27C6:  MOVLB  2
27C8:  BRA    2824
....................             case WRITE_BYTES_SENDING: 
....................  
....................             // 14 bit parts (16F877) writes each memory word one by one 
....................             #if defined(__PCM__) 
....................                write_program_eeprom(FLASH_USER_PROGRAM_BASE_ADDRESS + gblMemPtr++, (unsigned int16)InByte); 
....................              
....................             // 16 bit parts (18F458) buffers the data and writes blocks of data to the falsh 
....................             #elif defined(__PCH__) 
....................                // write to the flash buffer (it automatically writes to the flash 
....................                // every time the buffer is full 
....................                FLASHBufferedWrite(InByte); 
27CA:  MOVLB  2
27CC:  CLRF   xE3
27CE:  MOVFF  2A7,2E2
27D2:  MOVLB  0
27D4:  RCALL  246A
....................                 
....................             #endif 
....................                 
....................  
....................                if (--gblRWCount < 1) {  
27D6:  MOVLB  1
27D8:  MOVF   xAD,W
27DA:  BTFSC  FD8.2
27DC:  DECF   xAE,F
27DE:  DECFSZ xAD,F
27E0:  BRA    27F0
27E2:  MOVF   xAE,F
27E4:  BNZ   27F0
....................  
....................                   #if defined(__PCH__) 
....................                      // write remaining data in the buffer to the flash 
....................                      FLASHFlushBuffer(); 
27E6:  MOVLB  0
27E8:  RCALL  2414
....................                   #endif 
....................  
....................                   CMD_STATE = WAITING_FOR_FIRST_HEADER; 
27EA:  MOVLW  01
27EC:  MOVLB  1
27EE:  MOVWF  xCA
....................                } 
....................  
....................                printf(active_comm_putc,"%c",255-InByte); 
27F0:  MOVLW  FF
27F2:  BSF    FD8.0
27F4:  MOVLB  2
27F6:  SUBFWB xA7,W
27F8:  MOVWF  xAA
27FA:  MOVWF  xE2
27FC:  MOVLB  0
27FE:  CALL   1D06
....................                 
....................                 
....................                break; 
2802:  MOVLB  2
2804:  BRA    2824
....................  
....................             ////////////////////////////////////////////////////////////// 
....................             // cricket-check. Assumes we only ping all crickets (InByte = 0) 
....................             // Named crickets are not supported. 
....................             case CRICKET_NAME: 
....................                printf(active_comm_putc,"%c",0x37); 
2806:  MOVLW  37
2808:  MOVLB  2
280A:  MOVWF  xE2
280C:  MOVLB  0
280E:  CALL   1D06
....................                CMD_STATE = WAITING_FOR_FIRST_HEADER; 
2812:  MOVLW  01
2814:  MOVLB  1
2816:  MOVWF  xCA
....................                break; 
2818:  MOVLB  2
281A:  BRA    2824
....................  
....................  
....................  
....................             default: 
....................                 CMD_STATE = WAITING_FOR_FIRST_HEADER; 
281C:  MOVLW  01
281E:  MOVLB  1
2820:  MOVWF  xCA
....................                break; 
2822:  MOVLB  2
....................          } 
....................          if (CMD_STATE == CMD_READY)  break; 
2824:  MOVLB  1
2826:  MOVF   xCA,W
2828:  SUBLW  05
282A:  BNZ   2830
282C:  MOVLB  0
282E:  BRA    2834
....................  
....................  
....................    } 
2830:  MOVLB  2
2832:  BRA    24C4
2834:  MOVLB  0
....................  
....................      
....................  
....................  
....................  
....................    // else assume no data in serial buffer 
.................... } 
2836:  GOTO   50CA (RETURN)
....................  
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //   M A I N 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void main() { 
4E8A:  CLRF   FF8
4E8C:  BCF    FD0.7
4E8E:  BSF    07.7
4E90:  BSF    F94.3
4E92:  BSF    F94.4
4E94:  MOVLW  77
4E96:  MOVWF  FC8
4E98:  MOVLW  28
4E9A:  MOVWF  FC6
4E9C:  BSF    FC7.7
4E9E:  BCF    FC7.6
4EA0:  BSF    F7E.3
4EA2:  MOVLW  E1
4EA4:  MOVWF  FB0
4EA6:  MOVLW  04
4EA8:  MOVWF  F7F
4EAA:  MOVLW  A6
4EAC:  MOVWF  FAD
4EAE:  MOVLW  90
4EB0:  MOVWF  FAC
4EB2:  MOVLB  1
4EB4:  CLRF   x86
4EB6:  CLRF   x85
4EB8:  CLRF   x88
4EBA:  CLRF   x87
4EBC:  MOVLB  0
4EBE:  BCF    x7F.1
4EC0:  BSF    x7F.2
4EC2:  MOVLB  1
4EC4:  CLRF   xB5
4EC6:  CLRF   xB6
4EC8:  CLRF   xB7
4ECA:  CLRF   xB8
4ECC:  CLRF   xB9
4ECE:  MOVLB  0
4ED0:  BCF    x7F.3
4ED2:  MOVLB  1
4ED4:  CLRF   xFA
4ED6:  MOVLB  0
4ED8:  BCF    x7F.4
4EDA:  BCF    x7F.5
4EDC:  MOVLB  1
4EDE:  CLRF   xFC
4EE0:  CLRF   xFE
4EE2:  CLRF   xFF
4EE4:  MOVLB  0
4EE6:  BCF    x7F.6
4EE8:  BCF    x7F.7
4EEA:  MOVLB  2
4EEC:  BCF    x0A.0
4EEE:  CLRF   x17
4EF0:  MOVLW  69
4EF2:  MOVWF  x19
4EF4:  SETF   x18
4EF6:  CLRF   x1A
4EF8:  BCF    x0A.1
4EFA:  BCF    x0A.2
4EFC:  BCF    x0A.3
4EFE:  BCF    x0A.4
4F00:  CLRF   x1D
4F02:  CLRF   x1C
4F04:  CLRF   x1F
4F06:  CLRF   x1E
4F08:  CLRF   x20
4F0A:  CLRF   x41
4F0C:  CLRF   x42
4F0E:  CLRF   x43
4F10:  CLRF   x44
4F12:  BCF    x0A.5
4F14:  CLRF   x45
4F16:  CLRF   x46
4F18:  BSF    x0A.6
4F1A:  BCF    x0A.7
4F1C:  CLRF   x4C
4F1E:  CLRF   x4B
4F20:  CLRF   x4E
4F22:  CLRF   x4D
4F24:  BSF    x4F.0
4F26:  CLRF   x51
4F28:  CLRF   x50
4F2A:  CLRF   x52
4F2C:  BSF    x4F.1
4F2E:  CLRF   x55
4F30:  BCF    x4F.2
4F32:  BCF    x4F.3
4F34:  BCF    x4F.4
4F36:  CLRF   x97
4F38:  CLRF   x96
4F3A:  CLRF   x9B
4F3C:  CLRF   x9A
4F3E:  MOVLW  02
4F40:  MOVWF  x9C
4F42:  CLRF   x9D
4F44:  BSF    FC0.4
4F46:  MOVLW  FF
4F48:  MOVWF  FC1
4F4A:  BCF    FC0.4
4F4C:  BCF    FC2.6
4F4E:  BCF    FC2.7
4F50:  BSF    FC0.4
4F52:  MOVWF  FC2
4F54:  BCF    FC0.4
4F56:  CLRF   FD2
4F58:  CLRF   FD1
4F5A:  CLRF   1E
4F5C:  MOVLW  04
4F5E:  MOVWF  1F
4F60:  MOVLW  0C
4F62:  MOVWF  20
4F64:  MOVLB  1
4F66:  CLRF   x89
4F68:  CLRF   x8A
4F6A:  CLRF   x8B
4F6C:  CLRF   x8C
4F6E:  CLRF   x8D
4F70:  CLRF   x8E
4F72:  CLRF   x8F
4F74:  CLRF   x90
4F76:  CLRF   x91
4F78:  CLRF   x92
4F7A:  CLRF   x93
4F7C:  CLRF   x94
4F7E:  CLRF   x95
4F80:  CLRF   x96
4F82:  CLRF   x97
4F84:  CLRF   x98
4F86:  CLRF   x99
4F88:  CLRF   x9A
4F8A:  CLRF   x9B
4F8C:  CLRF   x9C
4F8E:  CLRF   x9D
4F90:  CLRF   x9E
4F92:  CLRF   x9F
4F94:  CLRF   xA0
4F96:  CLRF   xA1
4F98:  CLRF   xA2
4F9A:  CLRF   xA3
4F9C:  CLRF   xA4
4F9E:  CLRF   xA5
4FA0:  CLRF   xA6
4FA2:  CLRF   xA7
4FA4:  CLRF   xA8
4FA6:  CLRF   xAF
4FA8:  CLRF   xB0
4FAA:  MOVLW  18
4FAC:  MOVWF  xBA
4FAE:  MOVLW  7C
4FB0:  MOVWF  xBB
4FB2:  MOVLW  1A
4FB4:  MOVWF  xBC
4FB6:  MOVLW  7C
4FB8:  MOVWF  xBD
4FBA:  MOVLW  0A
4FBC:  MOVWF  xBE
4FBE:  MOVLW  7C
4FC0:  MOVWF  xBF
4FC2:  MOVLW  0D
4FC4:  MOVWF  xC0
4FC6:  MOVLW  7C
4FC8:  MOVWF  xC1
4FCA:  MOVLW  19
4FCC:  MOVWF  xC2
4FCE:  MOVLW  7C
4FD0:  MOVWF  xC3
4FD2:  MOVLW  1B
4FD4:  MOVWF  xC4
4FD6:  MOVLW  7C
4FD8:  MOVWF  xC5
4FDA:  MOVLW  0B
4FDC:  MOVWF  xC6
4FDE:  MOVLW  7C
4FE0:  MOVWF  xC7
4FE2:  MOVLW  0C
4FE4:  MOVWF  xC8
4FE6:  MOVLW  7C
4FE8:  MOVWF  xC9
4FEA:  MOVLW  0B
4FEC:  MOVWF  xF1
4FEE:  MOVLW  0A
4FF0:  MOVWF  xF2
4FF2:  MOVLW  07
4FF4:  MOVWF  xF3
4FF6:  MOVLW  03
4FF8:  MOVWF  xF4
4FFA:  MOVLW  02
4FFC:  MOVWF  xF5
4FFE:  MOVLW  01
5000:  MOVWF  xF6
5002:  CLRF   xF7
5004:  MOVLW  04
5006:  MOVWF  xF8
5008:  MOVLB  2
500A:  SETF   x00
500C:  SETF   x01
500E:  SETF   x02
5010:  SETF   x03
5012:  SETF   x04
5014:  SETF   x05
5016:  SETF   x06
5018:  SETF   x07
501A:  SETF   x08
501C:  SETF   x09
501E:  CLRF   x0B
5020:  CLRF   x0C
5022:  CLRF   x0D
5024:  CLRF   x0E
5026:  CLRF   x0F
5028:  CLRF   x10
502A:  CLRF   x11
502C:  CLRF   x12
502E:  CLRF   x13
5030:  CLRF   x14
5032:  CLRF   x15
5034:  CLRF   x16
5036:  MOVLW  B0
5038:  MOVWF  x47
503A:  MOVLW  B2
503C:  MOVWF  x48
503E:  MOVLW  B4
5040:  MOVWF  x49
5042:  MOVLW  B6
5044:  MOVWF  x4A
....................  
....................  
.................... int16 SensorVal; 
.................... int16 uploadLen,counter; 
....................  
....................  
.................... int16 foo; 
....................  
.................... int i; 
....................  
....................    RBPU = 0;   // enable port b internal pull-up. 
5046:  BCF    FF1.7
....................    PLLEN=TRUE;  // enable the PLL  
5048:  BSF    F9B.6
....................    delay_ms(1); 
504A:  MOVLW  01
504C:  MOVLB  9
504E:  MOVWF  x2B
5050:  MOVLB  0
5052:  CALL   18F4
....................  
.................... if (input(RUN_BUTTON) == 0) { 
5056:  BTFSC  F81.0
5058:  BRA    5078
....................  
....................    set_tris_a(PIC_TRIS_A); 
505A:  MOVLW  2F
505C:  MOVWF  F92
....................    set_tris_b(PIC_TRIS_B); 
505E:  MOVLW  01
5060:  MOVWF  F93
....................    set_tris_c(PIC_TRIS_C); 
5062:  MOVLW  90
5064:  MOVWF  F94
....................    set_tris_d(PIC_TRIS_D); 
5066:  MOVLW  00
5068:  MOVWF  F95
....................    set_tris_e(PIC_TRIS_E); 
506A:  MOVLW  80
506C:  MOVWF  F96
....................  
....................    output_high(USER_LED); 
506E:  BSF    F8B.0
....................    output_high(RUN_LED); 
5070:  BSF    F8B.1
....................    output_low(PIEZO); // make sure the buzzer is silent 
5072:  BCF    F8B.2
....................  
....................    downloadBootloader(); 
5074:  GOTO   1D2A
.................... } 
....................  
....................  
.................... init_variables(); 
5078:  GOTO   1F1C
.................... initBoard(); 
507C:  GOTO   202C
....................  
.................... //!while (1) { 
.................... //!   printf("Hello\r\n"); 
.................... //!   delay_ms(500); 
.................... //!   output_toggle(USER_LED); 
.................... //! 
.................... //!} 
....................  
.................... //  If autorun is set -> run logo procedures 
.................... if (read_program_eeprom(AUTORUN_STATUS_ADDRESS)==AUTORUN_ON) { 
5080:  MOVFF  FF2,2A7
5084:  BCF    FF2.7
5086:  CLRF   FF8
5088:  MOVLW  F9
508A:  MOVWF  FF7
508C:  MOVLW  F2
508E:  MOVWF  FF6
5090:  TBLRD*+
5092:  MOVF   FF5,W
5094:  TBLRD*
5096:  MOVFF  FF5,03
509A:  CLRF   FF8
509C:  MOVLB  2
509E:  BTFSC  xA7.7
50A0:  BSF    FF2.7
50A2:  MOVWF  xA7
50A4:  MOVFF  03,2A8
50A8:  DECFSZ xA7,W
50AA:  BRA    50C4
50AC:  MOVF   xA8,F
50AE:  BNZ   50C4
50B0:  CLRF   19
50B2:  BTFSC  FF2.7
50B4:  BSF    19.7
50B6:  BCF    FF2.7
....................    startStopLogoProcedures();       
50B8:  MOVLB  0
50BA:  CALL   127A
50BE:  BTFSC  19.7
50C0:  BSF    FF2.7
50C2:  MOVLB  2
.................... } 
....................  
....................  
....................  
.................... while (1) { 
....................  
....................  
....................    ProcessInput(); 
50C4:  MOVLB  0
50C6:  GOTO   24C0
....................      
....................  
....................    if ((CMD_STATE == CMD_READY) && (gblExtCmdMode==0))  { 
50CA:  MOVLB  1
50CC:  MOVF   xCA,W
50CE:  SUBLW  05
50D0:  BTFSS  FD8.2
50D2:  BRA    532E
50D4:  MOVLB  0
50D6:  BTFSS  x7F.3
50D8:  BRA    50DE
50DA:  MOVLB  1
50DC:  BRA    532E
....................  
....................  
....................          switch (gbl_cur_cmd)  { 
50DE:  MOVLB  1
50E0:  MOVF   xCB,W
50E2:  ADDLW  F9
50E4:  BC    517E
50E6:  ADDLW  07
50E8:  MOVLB  0
50EA:  GOTO   543E
....................             case CMD_PING: 
....................                   // do nothing, just send back ACK 
....................                   break; 
50EE:  MOVLB  1
50F0:  BRA    517E
....................  
....................             case CMD_READ_SENSOR: 
....................                   // if ext bits = 0b11 -> it is a read IR command 
....................                   if (gbl_cur_ext == 0b11){ 
50F2:  MOVLB  1
50F4:  MOVF   xCD,W
50F6:  SUBLW  03
50F8:  BNZ   510C
....................                      SensorVal = gblIRCode; 
50FA:  MOVFF  24C,29F
50FE:  MOVFF  24B,29E
....................                      gblIRCode = 0;   // reset the IR Code 
5102:  MOVLB  2
5104:  CLRF   x4C
5106:  CLRF   x4B
....................                   } else { 
5108:  BRA    5130
510A:  MOVLB  1
....................                      // the sensor number is mapped to the actual analog 
....................                      // port on the processor 
....................                      SensorVal = readSensor(gblSensorPortMap[gbl_cur_param]); 
510C:  CLRF   03
510E:  MOVF   xCC,W
5110:  ADDLW  F1
5112:  MOVWF  FE9
5114:  MOVLW  01
5116:  ADDWFC 03,W
5118:  MOVWF  FEA
511A:  MOVFF  FEF,2A7
511E:  MOVFF  2A7,2E1
5122:  MOVLB  0
5124:  CALL   28A2
5128:  MOVFF  02,29F
512C:  MOVFF  01,29E
....................                   } 
....................                   break; 
5130:  MOVLB  1
5132:  BRA    517E
....................  
....................             case CMD_MOTOR_CONTROL: 
....................                   MotorControl(gbl_cur_param); 
5134:  MOVFF  1CC,2E0
5138:  CALL   2B1C
....................                   break; 
513C:  MOVLB  1
513E:  BRA    517E
....................  
....................             case CMD_MOTOR_POWER: 
....................                   SetMotorPower(gbl_cur_param); 
5140:  MOVFF  1CC,2E2
5144:  CALL   2BC2
....................                   break; 
5148:  MOVLB  1
514A:  BRA    517E
....................  
....................             case CMD_TALK_TO_MOTOR: 
....................                   TalkToMotor(gbl_cur_ext_byte); 
514C:  MOVFF  1CE,2E0
5150:  CALL   2C9A
....................                   break; 
5154:  MOVLB  1
5156:  BRA    517E
....................  
....................             case CMD_BURST_MODE: 
....................                   SetBurstMode(gbl_cur_ext_byte, gbl_cur_ext); 
5158:  MOVFF  1CE,2A7
515C:  MOVFF  1CD,2A8
5160:  GOTO   2CA0
....................                   break; 
5164:  MOVLB  1
5166:  BRA    517E
....................  
....................             case CMD_MISC_CONTROL: 
....................                   miscControl(gbl_cur_param, gbl_cur_ext, gbl_cur_ext_byte); 
5168:  MOVFF  1CC,2A7
516C:  MOVFF  1CD,2A8
5170:  MOVFF  1CE,2A9
5174:  GOTO   2D02
....................                   break; 
5178:  MOVLB  1
517A:  BRA    517E
517C:  MOVLB  1
....................             } 
....................  
....................  
....................        
....................       // send the appropriate response back to the computer 
....................       if (gbl_cur_cmd == CMD_READ_SENSOR) 
517E:  DECFSZ xCB,W
5180:  BRA    51B8
....................          printf(active_comm_putc,"%c%c%c%c",ReplyHeader1, ReplyHeader2, SensorVal >> 8, SensorVal & 0xff); 
5182:  MOVFF  29F,2A7
5186:  MOVLB  2
5188:  CLRF   xA8
518A:  MOVFF  29E,2A9
518E:  CLRF   xAA
5190:  MOVLW  55
5192:  MOVWF  xE2
5194:  MOVLB  0
5196:  CALL   1D06
519A:  MOVLB  2
519C:  SETF   xE2
519E:  MOVLB  0
51A0:  CALL   1D06
51A4:  MOVFF  2A7,2E2
51A8:  CALL   1D06
51AC:  MOVFF  2A9,2E2
51B0:  CALL   1D06
....................       else { 
51B4:  BRA    5204
51B6:  MOVLB  1
....................          printf(active_comm_putc,"%c%c%c", ReplyHeader1, ReplyHeader2, ACK_BYTE);  // send acknowledge byte 
51B8:  MOVLW  55
51BA:  MOVLB  2
51BC:  MOVWF  xE2
51BE:  MOVLB  0
51C0:  CALL   1D06
51C4:  MOVLB  2
51C6:  SETF   xE2
51C8:  MOVLB  0
51CA:  CALL   1D06
51CE:  MOVLW  AA
51D0:  MOVLB  2
51D2:  MOVWF  xE2
51D4:  MOVLB  0
51D6:  CALL   1D06
....................          if (gbl_cur_cmd == CMD_PING)  // if PING -> also send firmware version  
51DA:  MOVLB  1
51DC:  MOVF   xCB,F
51DE:  BNZ   5206
....................             printf(active_comm_putc, "%c%c%c", HARDWARE_ID1, HARDWARE_ID2, FIRMWARE_ID); 
51E0:  MOVLW  01
51E2:  MOVLB  2
51E4:  MOVWF  xE2
51E6:  MOVLB  0
51E8:  CALL   1D06
51EC:  MOVLW  10
51EE:  MOVLB  2
51F0:  MOVWF  xE2
51F2:  MOVLB  0
51F4:  CALL   1D06
51F8:  MOVLW  01
51FA:  MOVLB  2
51FC:  MOVWF  xE2
51FE:  MOVLB  0
5200:  CALL   1D06
5204:  MOVLB  1
....................       } 
....................           
....................  
....................       /////////////////////////////////////////////////////////// 
....................       // 
....................       //  Handle EEPROM uploads here (urrr ... ugly coding) 
....................  
....................       /// cur_ext (2 bits) and cur_ext_byte (8 bits) combinds to form a 10 bit counter. 
....................       /// But to cover all the 32K EEPROM address range we must multiply this count by 32 (shift left 5 bits) 
....................       /// Therefore, one unit of the cur_ext|cur_ext_byte represents 32 EEPROM bytes (16 sensor values) 
....................       /// This basically means we have 16 values increments. 
....................  
....................       if ((gbl_cur_cmd == CMD_MISC_CONTROL) && (gbl_cur_param == MISC_UPLOAD_EEPROM)) { 
5206:  MOVF   xCB,W
5208:  SUBLW  06
520A:  BTFSS  FD8.2
520C:  BRA    5328
520E:  MOVF   xCC,W
5210:  SUBLW  03
5212:  BTFSS  FD8.2
5214:  BRA    5328
....................  
....................  
....................          uploadLen = ((((int16)gbl_cur_ext<<8) + gbl_cur_ext_byte)<<5);  // number of bytes to upload 
5216:  MOVLB  2
5218:  CLRF   xA8
521A:  MOVFF  1CD,2A7
521E:  MOVFF  1CD,2A8
5222:  CLRF   xA7
5224:  MOVLB  1
5226:  MOVF   xCE,W
5228:  MOVLB  2
522A:  ADDWF  xA7,F
522C:  MOVLW  00
522E:  ADDWFC xA8,F
5230:  RLCF   xA7,W
5232:  MOVWF  xA0
5234:  RLCF   xA8,W
5236:  MOVWF  xA1
5238:  RLCF   xA0,F
523A:  RLCF   xA1,F
523C:  RLCF   xA0,F
523E:  RLCF   xA1,F
5240:  RLCF   xA0,F
5242:  RLCF   xA1,F
5244:  RLCF   xA0,F
5246:  RLCF   xA1,F
5248:  MOVLW  E0
524A:  ANDWF  xA0,F
....................  
....................          #if defined(__PCM__) 
....................           
....................  
....................          // if uploadlen is 0 -> use automatic upload. In this case upload len becomes the last EEPROM location 
....................          // referenced by the 'record' command. This value is stored in the 'internal' EEPROM of 
....................          // the PIC. 
....................          if (uploadLen == 0) { 
....................             uploadLen = read_ext_eeprom(MEM_PTR_LOG_BASE_ADDRESS) + ((int16)read_ext_eeprom(MEM_PTR_LOG_BASE_ADDRESS+1) << 8); 
....................          } 
....................  
....................          // send EEPROM upload header bytes + number of bytes to send 
....................          printf(active_comm_putc, "%c%c%c%c", EEPROMuploadHeader1, EEPROMuploadHeader2, uploadLen & 0xff, uploadLen >> 8); 
....................  
....................          for (counter = 0 ; counter < uploadLen ; counter++ ) 
....................             printf(active_comm_putc, "%c", read_ext_eeprom(RECORD_BASE_ADDRESS + counter)); 
....................        
....................  
....................          #elif defined(__PCH__) 
....................        
....................          // if uploadlen is 0 -> use automatic upload. In this case upload len becomes the last EEPROM location 
....................          // referenced by the 'record' command. This value is stored in the 'internal' EEPROM of 
....................          // the PIC. 
....................          if (uploadLen == 0) { 
524C:  MOVF   xA0,F
524E:  BNZ   527A
5250:  MOVF   xA1,F
5252:  BNZ   527A
....................             uploadLen = read_program_eeprom(MEM_PTR_LOG_BASE_ADDRESS); 
5254:  MOVFF  FF2,2A7
5258:  BCF    FF2.7
525A:  CLRF   FF8
525C:  MOVLW  F9
525E:  MOVWF  FF7
5260:  MOVLW  F0
5262:  MOVWF  FF6
5264:  TBLRD*+
5266:  MOVF   FF5,W
5268:  TBLRD*
526A:  MOVFF  FF5,03
526E:  CLRF   FF8
5270:  BTFSC  xA7.7
5272:  BSF    FF2.7
5274:  MOVWF  xA0
5276:  MOVFF  03,2A1
....................          } 
....................  
....................          // number of bytes to send to the PC is twice the number of words to upload 
....................          uploadLen<<=1; 
527A:  BCF    FD8.0
527C:  RLCF   xA0,F
527E:  RLCF   xA1,F
....................           
....................          // send EEPROM upload header bytes + number of bytes to send 
....................          printf(active_comm_putc, "%c%c%c%c", EEPROMuploadHeader1, EEPROMuploadHeader2, uploadLen & 0xff, uploadLen >> 8); 
5280:  MOVFF  2A0,2A7
5284:  CLRF   xA8
5286:  MOVFF  2A1,2A9
528A:  CLRF   xAA
528C:  MOVLW  EE
528E:  MOVWF  xE2
5290:  MOVLB  0
5292:  CALL   1D06
5296:  MOVLW  11
5298:  MOVLB  2
529A:  MOVWF  xE2
529C:  MOVLB  0
529E:  CALL   1D06
52A2:  MOVFF  2A7,2E2
52A6:  CALL   1D06
52AA:  MOVFF  2A9,2E2
52AE:  CALL   1D06
....................           
....................          // shift back becuase the nubmer of words read is half the number of bytes 
....................          uploadLen>>=1; 
52B2:  BCF    FD8.0
52B4:  MOVLB  2
52B6:  RRCF   xA1,F
52B8:  RRCF   xA0,F
....................           
....................          for (counter = 0 ; counter < uploadLen ; counter++ ) { 
52BA:  CLRF   xA3
52BC:  CLRF   xA2
52BE:  MOVF   xA3,W
52C0:  SUBWF  xA1,W
52C2:  BNC   5326
52C4:  BNZ   52CC
52C6:  MOVF   xA0,W
52C8:  SUBWF  xA2,W
52CA:  BC    5326
....................             foo = read_program_eeprom((RECORD_BASE_ADDRESS + (counter<<1))); 
52CC:  BCF    FD8.0
52CE:  RLCF   xA2,W
52D0:  MOVWF  02
52D2:  RLCF   xA3,W
52D4:  MOVWF  03
52D6:  MOVLW  58
52D8:  ADDWF  03,W
52DA:  MOVFF  FF2,2A9
52DE:  BCF    FF2.7
52E0:  CLRF   FF8
52E2:  MOVWF  FF7
52E4:  MOVFF  02,FF6
52E8:  TBLRD*+
52EA:  MOVF   FF5,W
52EC:  TBLRD*
52EE:  MOVFF  FF5,03
52F2:  CLRF   FF8
52F4:  BTFSC  xA9.7
52F6:  BSF    FF2.7
52F8:  MOVWF  xA4
52FA:  MOVFF  03,2A5
....................             printf(active_comm_putc, "%c%c", foo&0xff, foo>>8 ); 
52FE:  MOVFF  2A4,2A7
5302:  CLRF   xA8
5304:  MOVFF  2A5,2A9
5308:  CLRF   xAA
530A:  MOVFF  2A4,2E2
530E:  MOVLB  0
5310:  CALL   1D06
5314:  MOVFF  2A9,2E2
5318:  CALL   1D06
....................          } 
531C:  MOVLB  2
531E:  INCF   xA2,F
5320:  BTFSC  FD8.2
5322:  INCF   xA3,F
5324:  BRA    52BE
5326:  MOVLB  1
....................              
....................        
....................       #endif 
....................  
....................       } 
....................  
....................       CMD_STATE = WAITING_FOR_FIRST_HEADER; 
5328:  MOVLW  01
532A:  MOVWF  xCA
....................  
....................    }  
....................     
....................    ///////////////////////////////////////////////////////////////////////////// 
....................    // if cmd is ready and in an extended command mode 
....................    else if ((CMD_STATE == CMD_READY) && (gblExtCmdMode==1))  { 
532C:  BRA    53DE
532E:  MOVF   xCA,W
5330:  SUBLW  05
5332:  BNZ   53D0
5334:  MOVLB  0
5336:  BTFSC  x7F.3
5338:  BRA    533E
533A:  MOVLB  1
533C:  BRA    53D0
....................  
....................       printf(active_comm_putc, "%c%c", ReplyHeader1, ReplyHeader2); 
533E:  MOVLW  55
5340:  MOVLB  2
5342:  MOVWF  xE2
5344:  MOVLB  0
5346:  CALL   1D06
534A:  MOVLB  2
534C:  SETF   xE2
534E:  MOVLB  0
5350:  CALL   1D06
....................        
....................       // ================================================================= 
....................       // cmd = send a Real time clock stream to the computer 
....................       if (gbl_cur_cmd == 0b00000000) { 
5354:  MOVLB  1
5356:  MOVF   xCB,F
5358:  BNZ   5384
....................          for (i=0;i<7;i++) { 
535A:  MOVLB  2
535C:  CLRF   xA6
535E:  MOVF   xA6,W
5360:  SUBLW  06
5362:  BNC   5380
....................             printf(active_comm_putc, "%c", rtcGetItem(i)); 
5364:  MOVFF  2A6,2E2
5368:  MOVLB  0
536A:  CALL   2EC0
536E:  MOVFF  01,2A7
5372:  MOVFF  01,2E2
5376:  CALL   1D06
....................          } 
537A:  MOVLB  2
537C:  INCF   xA6,F
537E:  BRA    535E
....................  
....................       // ================================================================= 
....................       // cmd = recieve a real time clock stream from a computer and update 
....................       // the RTC module based on the stream. 
....................       } else if (gbl_cur_cmd == 0b00000001) { 
5380:  BRA    53C8
5382:  MOVLB  1
5384:  DECFSZ xCB,W
5386:  BRA    53C8
....................          rtcInit(); 
5388:  MOVLB  0
538A:  CALL   2F22
....................           
....................          for (i=0;i<7;i++) { 
538E:  MOVLB  2
5390:  CLRF   xA6
5392:  MOVF   xA6,W
5394:  SUBLW  06
5396:  BNC   53BE
....................             rtcSetItem(i, gblExtCMDBuffer[i]); 
5398:  CLRF   03
539A:  MOVF   xA6,W
539C:  ADDLW  CF
539E:  MOVWF  FE9
53A0:  MOVLW  01
53A2:  ADDWFC 03,W
53A4:  MOVWF  FEA
53A6:  MOVFF  FEF,2A7
53AA:  MOVFF  2A6,2A8
53AE:  MOVFF  2A7,2A9
53B2:  MOVLB  0
53B4:  GOTO   2FDC
....................          } 
53B8:  MOVLB  2
53BA:  INCF   xA6,F
53BC:  BRA    5392
....................          printf(active_comm_putc, "%c", ACK_BYTE); 
53BE:  MOVLW  AA
53C0:  MOVWF  xE2
53C2:  MOVLB  0
53C4:  CALL   1D06
....................       } 
....................        
....................       CMD_STATE = WAITING_FOR_FIRST_HEADER; 
53C8:  MOVLW  01
53CA:  MOVLB  1
53CC:  MOVWF  xCA
....................  
....................  
....................    } else   // NO_CMD 
53CE:  BRA    53DE
....................    { 
....................       DoSensorStuff(); 
53D0:  MOVLB  0
53D2:  GOTO   2FFC
....................       DoDisplayModuleStuff(); 
53D6:  GOTO   3198
....................       DoMotorStuff(); 
53DA:  GOTO   335E
....................        
....................  
....................       
....................    } 
....................  
....................     
....................    // if Logo is running 
....................   if (gblLogoIsRunning) 
53DE:  MOVLB  2
53E0:  BTFSS  x0A.2
53E2:  BRA    5400
....................    { 
....................             // if wait command is not in progress -> run next code 
....................             if (!gblWaitCounter) { 
53E4:  MOVF   x1C,W
53E6:  IORWF  x1D,W
53E8:  BNZ   53FE
....................                 
....................                evalOpcode(fetchNextOpcode()); 
53EA:  MOVLB  0
53EC:  CALL   336E
53F0:  MOVFF  01,2A7
53F4:  MOVFF  01,2A8
53F8:  GOTO   437A
53FC:  MOVLB  2
....................             } 
....................    } else if (flgNeedToTurnOffAllMotors) { 
53FE:  BRA    5412
5400:  BTFSS  x0A.0
5402:  BRA    5412
....................          gblMotorONOFF=0;  // turn off all motors by clearing the on,off flag bits 
5404:  MOVLB  1
5406:  CLRF   xFF
....................          //ENLow(0); ENLow(1); // turn off all the motor EN pins    
....................          clearMotors(); // turn off all motors 
5408:  MOVLB  0
540A:  CALL   1F64
....................          flgNeedToTurnOffAllMotors=0; 
540E:  MOVLB  2
5410:  BCF    x0A.0
....................    } 
....................  
....................    /////////////////////////////////////////////////////////////// 
....................    // make sure the CMD_STATE is not stuck somewhere for too long 
....................  
....................    // gblCmdTimeOut is incremented in Timer1's ISR every 0.1 sec 
....................    if (gblCmdTimeOut > CMD_TIMEOUT_PERIOD) { 
5412:  MOVF   x20,W
5414:  SUBLW  04
5416:  BC    5422
....................       CMD_STATE = WAITING_FOR_FIRST_HEADER; 
5418:  MOVLW  01
541A:  MOVLB  1
541C:  MOVWF  xCA
....................       gblCmdTimeOut = 0; 
541E:  MOVLB  2
5420:  CLRF   x20
....................        
....................    } 
....................  
....................    /////////////////////////////////////////////////////////////// 
....................    // Do USB Stuff 
....................    // Most importantly -> check for USB connection with a computer 
....................  
....................    usb_task(); 
5422:  MOVLB  0
5424:  CALL   1972
....................  
....................  
....................    /////////////////////////////////////////////////////////////// 
....................    // Beep when notified by this flag 
....................    // It is currently set by the Logo downloader when Logo download 
....................    // is finished 
....................    if (gblNeedToBeep) { 
5428:  MOVLB  2
542A:  BTFSS  x4F.3
542C:  BRA    543A
....................       beep(); 
542E:  MOVLB  0
5430:  CALL   2222
....................       output_low(USER_LED); // we output high when logo code was downloaded 
5434:  BCF    F8B.0
....................       gblNeedToBeep = 0; 
5436:  MOVLB  2
5438:  BCF    x4F.3
....................    } 
....................  
....................  
.................... } 
543A:  BRA    50C4
....................  
.................... } 
....................  
....................  
.................... #include <logovm.c> 
.................... // 
.................... // logovm.c - Logo compiler support routines 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
....................  
.................... ///////////////////////////////////////////////////// 
.................... // 
.................... //  Logo Virtual Machine 
.................... // 
.................... //  Written by Arnan (Roger) Sipitakiat 
.................... // 
.................... //  Logo running on the GoGo Board was created based 
.................... //  on the Cricket Logo. 
.................... // 
.................... //  Cricket Logo creators include: 
.................... //    Fred G. Martin 
.................... //    Brian Silverman 
.................... //    Mitchel Resnick 
.................... //    Robbie Berg 
.................... // 
.................... ///////////////////////////////////////////////////// 
....................  
....................  
.................... #include <evalOpcode.c>      // This is the Opcode evaluator 
.................... // 
.................... // evalopcode.c - Contains the Logo Operations 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
....................  
.................... ///////////////////////////////////////////////////// 
.................... // 
.................... //  Logo Virtual Machine 
.................... // 
.................... //  Written by Arnan (Roger) Sipitakiat 
.................... // 
.................... //  Logo running on the GoGo Board was created based 
.................... //  on the Cricket Logo. 
.................... // 
.................... //  Cricket Logo creators include: 
.................... //    Fred Martin 
.................... //    Brian Silverman 
.................... //    Mitchel Resnick 
.................... //    Robbie Berg 
.................... // 
.................... ///////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... void evalOpcode(unsigned char opcode) { 
437A:  MOVLB  2
437C:  CLRF   xB1
437E:  CLRF   xB0
....................  
543C:  SLEEP 
.................... int i; 
.................... int16 opr1, opr2, opr3; 
.................... unsigned int16 genPurpose=0; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... /// if opcode is a prcedure call (msb is 1) 
....................  
.................... if (opcode & 0b10000000) { 
4380:  BTFSS  xA8.7
4382:  BRA    4470
....................  
....................  
....................    genPurpose=gblMemPtr+1;  // this is the return address 
4384:  MOVLW  01
4386:  MOVLB  1
4388:  ADDWF  xAB,W
438A:  MOVLB  2
438C:  MOVWF  xB0
438E:  MOVLW  00
4390:  MOVLB  1
4392:  ADDWFC xAC,W
4394:  MOVLB  2
4396:  MOVWF  xB1
....................  
....................    // update the mem pointer to point at the procedure 
....................    gblMemPtr = (((unsigned int16)opcode & 0b00111111) << 8) + fetchNextOpcode(); 
4398:  CLRF   xB3
439A:  MOVFF  2A8,2B2
439E:  MOVLW  3F
43A0:  ANDWF  xB2,F
43A2:  CLRF   xB3
43A4:  MOVFF  2B2,2B3
43A8:  CLRF   xB2
43AA:  MOVLB  0
43AC:  CALL   336E
43B0:  MOVF   01,W
43B2:  MOVLB  2
43B4:  ADDWF  xB2,W
43B6:  MOVLB  1
43B8:  MOVWF  xAB
43BA:  MOVLW  00
43BC:  MOVLB  2
43BE:  ADDWFC xB3,W
43C0:  MOVLB  1
43C2:  MOVWF  xAC
....................  
....................    // then fetch the new opcode 
....................  
....................    // The first opcode in a procedure is the number of parameters. 
....................    opr1 = fetchNextOpcode(); 
43C4:  MOVLB  0
43C6:  CALL   336E
43CA:  MOVLB  2
43CC:  CLRF   xAB
43CE:  MOVFF  01,2AA
....................  
....................    /// if the second msb is set -> tail recursion 
....................    if (opcode & 0b01000000) { 
43D2:  BTFSS  xA8.6
43D4:  BRA    43FC
....................       // - Because this is tail recursion, we have to overwrite preveous procedure inputs 
....................       //   with the new ones. This loop removes the old inputs. 
....................       // - In addition to the procedure input we have three extra entries: the data stack pointer , 
....................       //   the procedure return address, and the procedure input base address in the input stack. 
....................       for (i=0 ; i < (opr1+3) ; i++) { 
43D6:  CLRF   xA9
43D8:  MOVLW  03
43DA:  ADDWF  xAA,W
43DC:  MOVWF  01
43DE:  MOVLW  00
43E0:  ADDWFC xAB,W
43E2:  MOVWF  03
43E4:  MOVF   01,W
43E6:  MOVF   03,F
43E8:  BNZ   43F0
43EA:  MOVF   01,W
43EC:  SUBWF  xA9,W
43EE:  BC    43FC
....................          inputPop(); 
43F0:  MOVLB  0
43F2:  CALL   33CC
....................       } 
43F6:  MOVLB  2
43F8:  INCF   xA9,F
43FA:  BRA    43D8
....................    } 
....................  
....................    // Pop the procedure inputs from the main data stack and move them 
....................    // to the input stack 
....................    for (i=0 ; i<opr1 ; i++) { 
43FC:  CLRF   xA9
43FE:  MOVF   xAB,F
4400:  BNZ   4408
4402:  MOVF   xAA,W
4404:  SUBWF  xA9,W
4406:  BC    4428
....................       inputPush(stkPop()); 
4408:  MOVLB  0
440A:  CALL   3434
440E:  MOVFF  02,2B3
4412:  MOVFF  01,2B2
4416:  MOVFF  02,2B5
441A:  MOVFF  01,2B4
441E:  CALL   3488
....................    } 
4422:  MOVLB  2
4424:  INCF   xA9,F
4426:  BRA    43FE
....................    inputPush(gblStkPtr);   // save the data stack pointer (we use this with STOP opcode to clear the 
4428:  CLRF   xB5
442A:  MOVFF  82,2B4
442E:  MOVLB  0
4430:  CALL   3488
....................                      // data stack of the current procedure. 
....................    inputPush(genPurpose);  // save the return address 
4434:  MOVFF  2B1,2B5
4438:  MOVFF  2B0,2B4
443C:  CALL   3488
....................  
....................    inputPush(gblInputStkPtr - (opr1+2));   // pushes a proc input base address index. 
4440:  MOVLW  02
4442:  MOVLB  2
4444:  ADDWF  xAA,W
4446:  MOVWF  01
4448:  MOVLW  00
444A:  ADDWFC xAB,W
444C:  MOVWF  03
444E:  MOVF   01,W
4450:  MOVLB  1
4452:  SUBWF  x04,W
4454:  MOVLB  2
4456:  MOVWF  xB2
4458:  MOVLW  00
445A:  SUBFWB 03,W
445C:  MOVWF  xB3
445E:  MOVWF  xB5
4460:  MOVFF  2B2,2B4
4464:  MOVLB  0
4466:  CALL   3488
....................                                   // you'll need to read the documentation 
....................                                   // to fully understand why. Meanwhile, see how it 
....................                                   // is used in case LTHING 
....................                                   // - we add 2 because we also keep the data stack pointer and 
....................                                   //   the return address in this stack. 
....................  
....................  
....................    //printf("pushed loop adr = %LX, repeat count = %LX\r\n", gblLoopAddress, gblRepeatCount); 
....................  
....................  
....................    return; 
446A:  GOTO   4E52
446E:  MOVLB  2
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////////////// 
....................  
....................    switch (opcode) { 
4470:  MOVF   xA8,W
4472:  XORLW  00
4474:  MOVLB  0
4476:  BTFSC  FD8.2
4478:  BRA    4598
447A:  XORLW  01
447C:  BTFSC  FD8.2
447E:  BRA    45AC
4480:  XORLW  03
4482:  BTFSC  FD8.2
4484:  BRA    45C8
4486:  XORLW  01
4488:  BTFSC  FD8.2
448A:  BRA    45FE
448C:  XORLW  07
448E:  BTFSC  FD8.2
4490:  BRA    4630
4492:  XORLW  01
4494:  BTFSC  FD8.2
4496:  BRA    46C2
4498:  XORLW  03
449A:  BTFSC  FD8.2
449C:  BRA    4708
449E:  XORLW  01
44A0:  BTFSC  FD8.2
44A2:  BRA    476E
44A4:  XORLW  0F
44A6:  BTFSC  FD8.2
44A8:  BRA    476E
44AA:  XORLW  01
44AC:  BTFSC  FD8.2
44AE:  BRA    47F4
44B0:  XORLW  03
44B2:  BTFSC  FD8.2
44B4:  BRA    486E
44B6:  XORLW  01
44B8:  BTFSC  FD8.2
44BA:  BRA    48A8
44BC:  XORLW  07
44BE:  BTFSC  FD8.2
44C0:  BRA    48F6
44C2:  XORLW  01
44C4:  BTFSC  FD8.2
44C6:  BRA    48FE
44C8:  XORLW  03
44CA:  BTFSC  FD8.2
44CC:  BRA    4902
44CE:  XORLW  01
44D0:  BTFSC  FD8.2
44D2:  BRA    4932
44D4:  XORLW  1F
44D6:  BTFSC  FD8.2
44D8:  BRA    4968
44DA:  XORLW  01
44DC:  BTFSC  FD8.2
44DE:  BRA    4978
44E0:  XORLW  03
44E2:  BTFSC  FD8.2
44E4:  BRA    4988
44E6:  XORLW  01
44E8:  BTFSC  FD8.2
44EA:  BRA    4992
44EC:  XORLW  07
44EE:  BTFSC  FD8.2
44F0:  BRA    49C2
44F2:  XORLW  01
44F4:  BTFSC  FD8.2
44F6:  BRA    49F0
44F8:  XORLW  4A
44FA:  BTFSC  FD8.2
44FC:  BRA    4A08
44FE:  XORLW  3F
4500:  BTFSC  FD8.2
4502:  BRA    4A3C
4504:  XORLW  76
4506:  BTFSC  FD8.2
4508:  BRA    4A54
450A:  XORLW  01
450C:  BTFSC  FD8.2
450E:  BRA    4A70
4510:  XORLW  0F
4512:  BTFSC  FD8.2
4514:  BRA    4A70
4516:  XORLW  01
4518:  BTFSC  FD8.2
451A:  BRA    4A70
451C:  XORLW  03
451E:  BTFSC  FD8.2
4520:  BRA    4A70
4522:  XORLW  01
4524:  BTFSC  FD8.2
4526:  BRA    4A70
4528:  XORLW  07
452A:  BTFSC  FD8.2
452C:  BRA    4A70
452E:  XORLW  01
4530:  BTFSC  FD8.2
4532:  BRA    4A70
4534:  XORLW  03
4536:  BTFSC  FD8.2
4538:  BRA    4A70
453A:  XORLW  01
453C:  BTFSC  FD8.2
453E:  BRA    4A70
4540:  XORLW  3F
4542:  BTFSC  FD8.2
4544:  BRA    4A70
4546:  XORLW  01
4548:  BTFSC  FD8.2
454A:  BRA    4A70
454C:  XORLW  03
454E:  BTFSC  FD8.2
4550:  BRA    4BC6
4552:  XORLW  01
4554:  BTFSC  FD8.2
4556:  BRA    4BE6
4558:  XORLW  07
455A:  BTFSC  FD8.2
455C:  BRA    4C20
455E:  XORLW  01
4560:  BTFSC  FD8.2
4562:  BRA    4C5C
4564:  XORLW  03
4566:  BTFSC  FD8.2
4568:  GOTO   4CBA
456C:  XORLW  01
456E:  BTFSC  FD8.2
4570:  GOTO   4D1C
4574:  XORLW  0F
4576:  BTFSC  FD8.2
4578:  GOTO   4D8A
457C:  XORLW  01
457E:  BTFSC  FD8.2
4580:  GOTO   4DDA
4584:  XORLW  03
4586:  BTFSC  FD8.2
4588:  GOTO   4DE2
458C:  XORLW  01
458E:  BTFSC  FD8.2
4590:  GOTO   4DF2
4594:  GOTO   4E4A
....................       case  CODE_END: 
....................        gblLogoIsRunning = 0; 
4598:  MOVLB  2
459A:  BCF    x0A.2
....................        output_low(RUN_LED); 
459C:  BCF    F8B.1
....................  
....................        // clear thes variables just in case. 
....................         gblLoopAddress = 0; 
459E:  MOVLB  1
45A0:  CLRF   x86
45A2:  CLRF   x85
....................        gblRepeatCount = 0; 
45A4:  CLRF   x88
45A6:  CLRF   x87
....................        break; 
45A8:  GOTO   4E54
....................       case  NUM8: 
....................        stkPush(fetchNextOpcode()); 
45AC:  CALL   336E
45B0:  MOVFF  01,2B2
45B4:  MOVLB  2
45B6:  CLRF   xE3
45B8:  MOVFF  01,2E2
45BC:  MOVLB  0
45BE:  CALL   34F4
....................        break; 
45C2:  MOVLB  1
45C4:  GOTO   4E54
....................       case  NUM16: 
....................        stkPush(((unsigned int16)fetchNextOpcode() << 8) + fetchNextOpcode()); 
45C8:  CALL   336E
45CC:  MOVLB  2
45CE:  CLRF   xB3
45D0:  MOVFF  01,2B2
45D4:  MOVFF  01,2B3
45D8:  CLRF   xB2
45DA:  MOVLB  0
45DC:  CALL   336E
45E0:  MOVF   01,W
45E2:  MOVLB  2
45E4:  ADDWF  xB2,F
45E6:  MOVLW  00
45E8:  ADDWFC xB3,F
45EA:  MOVFF  2B3,2E3
45EE:  MOVFF  2B2,2E2
45F2:  MOVLB  0
45F4:  CALL   34F4
....................        break; 
45F8:  MOVLB  1
45FA:  GOTO   4E54
....................       case  LIST: 
....................           stkPush(gblMemPtr+1); 
45FE:  MOVLW  01
4600:  MOVLB  1
4602:  ADDWF  xAB,W
4604:  MOVLB  2
4606:  MOVWF  xB2
4608:  MOVLW  00
460A:  MOVLB  1
460C:  ADDWFC xAC,W
460E:  MOVLB  2
4610:  MOVWF  xB3
4612:  MOVWF  xE3
4614:  MOVFF  2B2,2E2
4618:  MOVLB  0
461A:  CALL   34F4
....................           gblMemPtr += fetchNextOpcode(); 
461E:  CALL   336E
4622:  MOVF   01,W
4624:  MOVLB  1
4626:  ADDWF  xAB,F
4628:  MOVLW  00
462A:  ADDWFC xAC,F
....................           //printf("LIST new gblMemPtr = %LX\r\n", gblMemPtr); 
....................        break; 
462C:  GOTO   4E54
....................       case  EOL: 
....................        genPurpose = stkPop(); 
4630:  CALL   3434
4634:  MOVFF  02,2B1
4638:  MOVFF  01,2B0
....................        if (genPurpose > gblMemPtr) { 
463C:  MOVLB  1
463E:  MOVF   xAC,W
4640:  MOVLB  2
4642:  SUBWF  xB1,W
4644:  BNC   4662
4646:  BNZ   4658
4648:  MOVF   xB0,W
464A:  MOVLB  1
464C:  SUBWF  xAB,W
464E:  BTFSS  FD8.0
4650:  BRA    4656
4652:  MOVLB  2
4654:  BRA    4662
4656:  MOVLB  2
....................           gblMemPtr = genPurpose; 
4658:  MOVFF  2B1,1AC
465C:  MOVFF  2B0,1AB
....................         } else { 
4660:  BRA    46B0
....................           gblMemPtr = genPurpose; 
4662:  MOVFF  2B1,1AC
4666:  MOVFF  2B0,1AB
....................           gblRepeatCount = stkPop();   // repeat count 
466A:  MOVLB  0
466C:  CALL   3434
4670:  MOVFF  02,188
4674:  MOVFF  01,187
....................           if (gblRepeatCount > 1) { gblRepeatCount--; } 
4678:  MOVLB  1
467A:  MOVF   x88,F
467C:  BNZ   4684
467E:  MOVF   x87,W
4680:  SUBLW  01
4682:  BC    468C
4684:  MOVF   x87,W
4686:  BTFSC  FD8.2
4688:  DECF   x88,F
468A:  DECF   x87,F
....................           if (gblRepeatCount != 1) { 
468C:  DECFSZ x87,W
468E:  BRA    4694
4690:  MOVF   x88,F
4692:  BZ    46B0
....................              stkPush(gblRepeatCount); 
4694:  MOVFF  188,2E3
4698:  MOVFF  187,2E2
469C:  MOVLB  0
469E:  CALL   34F4
....................              stkPush(gblMemPtr); 
46A2:  MOVFF  1AC,2E3
46A6:  MOVFF  1AB,2E2
46AA:  CALL   34F4
46AE:  MOVLB  1
....................            } 
....................         } 
....................         delay_ms(10); // add a delay at then end of each loop. 
46B0:  MOVLW  0A
46B2:  MOVLB  9
46B4:  MOVWF  x2B
46B6:  MOVLB  0
46B8:  CALL   18F4
....................                       // this increases the stability. 
....................          
....................        //printf("EOL return address = %LX, loop address = %LX\r\n",gblMemPtr, gblLoopAddress); 
....................        break; 
46BC:  MOVLB  1
46BE:  GOTO   4E54
....................       case  EOLR: 
....................        if(stkPop()) {    // if condition is true 
46C2:  CALL   3434
46C6:  MOVF   01,W
46C8:  IORWF  02,W
46CA:  BZ    46DE
....................          stkPop();        // throw away the loop address 
46CC:  CALL   3434
....................          gblMemPtr = stkPop(); // fetch the next command address 
46D0:  CALL   3434
46D4:  MOVFF  02,1AC
46D8:  MOVFF  01,1AB
....................          } else { // if condition if false -> keep on looping. 
46DC:  BRA    4702
....................           gblMemPtr = stkPop(); 
46DE:  CALL   3434
46E2:  MOVFF  02,1AC
46E6:  MOVFF  01,1AB
....................           stkPush(gblMemPtr); 
46EA:  MOVFF  1AC,2E3
46EE:  MOVFF  1AB,2E2
46F2:  CALL   34F4
....................           delay_ms(10);  // this prevents the waituntil loop to execute too rapidly 
46F6:  MOVLW  0A
46F8:  MOVLB  9
46FA:  MOVWF  x2B
46FC:  MOVLB  0
46FE:  CALL   18F4
....................                          // which has proven to cause some problems when reading 
....................                          // sensor values. 
....................                   
.................... //          while (1) {output_high(USER_LED); delay_ms(50); output_low(USER_LED); delay_ms(50);} 
....................                         
....................        } 
....................  
....................        break; 
4702:  MOVLB  1
4704:  GOTO   4E54
....................  
....................      ///////////////////////////////////////////////////////////// 
....................      // retrieve procedure input 
....................       case  LTHING: 
....................           genPurpose = fetchNextOpcode();  // index of the input variable 
4708:  CALL   336E
470C:  MOVLB  2
470E:  CLRF   xB1
4710:  MOVFF  01,2B0
....................           opr1 = inputPop();  // base address in the input stack 
4714:  MOVLB  0
4716:  CALL   33CC
471A:  MOVFF  02,2AB
471E:  MOVFF  01,2AA
....................           inputPush(opr1);    // push the base address back to the stack. 
4722:  MOVFF  2AB,2B5
4726:  MOVFF  2AA,2B4
472A:  CALL   3488
....................           stkPush(gblInputStack[opr1 + genPurpose]); 
472E:  MOVLB  2
4730:  MOVF   xB0,W
4732:  ADDWF  xAA,W
4734:  MOVWF  xB2
4736:  MOVF   xB1,W
4738:  ADDWFC xAB,W
473A:  MOVWF  xB3
473C:  BCF    FD8.0
473E:  RLCF   xB2,W
4740:  MOVWF  02
4742:  RLCF   xB3,W
4744:  MOVWF  03
4746:  MOVF   02,W
4748:  ADDLW  05
474A:  MOVWF  FE9
474C:  MOVLW  01
474E:  ADDWFC 03,W
4750:  MOVWF  FEA
4752:  MOVFF  FEC,2B3
4756:  MOVF   FED,F
4758:  MOVFF  FEF,2B2
475C:  MOVFF  2B3,2E3
4760:  MOVFF  2B2,2E2
4764:  MOVLB  0
4766:  CALL   34F4
....................        break; 
476A:  MOVLB  1
476C:  BRA    4E54
....................  
....................      ///////////////////////////////////////////////////////////// 
....................      // return to the parent procedure 
....................       case   STOP: 
....................       case OUTPUT: 
....................  
....................  
....................           if (opcode == OUTPUT) { genPurpose = stkPop(); } // this is the output value 
476E:  MOVLB  2
4770:  MOVF   xA8,W
4772:  SUBLW  08
4774:  BNZ   4784
4776:  MOVLB  0
4778:  CALL   3434
477C:  MOVFF  02,2B1
4780:  MOVFF  01,2B0
....................  
....................        opr1 = inputPop();  // this is the proc-input stack base address 
4784:  MOVLB  0
4786:  CALL   33CC
478A:  MOVFF  02,2AB
478E:  MOVFF  01,2AA
....................         gblMemPtr = inputPop(); // this is the return address 
4792:  CALL   33CC
4796:  MOVFF  02,1AC
479A:  MOVFF  01,1AB
....................        opr2 = inputPop();  // this is the data stack index; 
479E:  CALL   33CC
47A2:  MOVFF  02,2AD
47A6:  MOVFF  01,2AC
....................  
....................  
....................  
....................  
....................        //printf( "poped loop adr = %LX, repeat count = %LX\r\n", gblLoopAddress, gblRepeatCount); 
....................  
....................        // remove any remaining data that belongs to the current procedure from the data stack 
....................        // Usually this is important for the STOP opcode. 
....................        while (gblStkPtr > opr2) { stkPop(); } 
47AA:  MOVLB  2
47AC:  MOVF   xAD,F
47AE:  BNZ   47C4
47B0:  MOVLB  0
47B2:  MOVF   x82,W
47B4:  MOVLB  2
47B6:  SUBWF  xAC,W
47B8:  BC    47C4
47BA:  MOVLB  0
47BC:  CALL   3434
47C0:  BRA    47AA
47C2:  MOVLB  2
....................  
....................        // remove the procedure inputs from the input stack 
....................        while (gblInputStkPtr > opr1) { inputPop(); } 
47C4:  MOVF   xAB,F
47C6:  BNZ   47DC
47C8:  MOVLB  1
47CA:  MOVF   x04,W
47CC:  MOVLB  2
47CE:  SUBWF  xAA,W
47D0:  BC    47DC
47D2:  MOVLB  0
47D4:  CALL   33CC
47D8:  MOVLB  2
47DA:  BRA    47C4
....................  
....................           // Output will push the output to the stack 
....................           if (opcode == OUTPUT) { stkPush(genPurpose); } 
47DC:  MOVF   xA8,W
47DE:  SUBLW  08
47E0:  BNZ   47F0
47E2:  MOVFF  2B1,2E3
47E6:  MOVFF  2B0,2E2
47EA:  MOVLB  0
47EC:  CALL   34F4
....................  
....................        break; 
47F0:  MOVLB  1
47F2:  BRA    4E54
....................  
....................  
....................  
....................       case  REPEAT: 
....................           gblLoopAddress = stkPop(); 
47F4:  CALL   3434
47F8:  MOVFF  02,186
47FC:  MOVFF  01,185
....................           gblRepeatCount = stkPop(); 
4800:  CALL   3434
4804:  MOVFF  02,188
4808:  MOVFF  01,187
....................  
....................        // these will be poped by EOL 
....................        stkPush(gblMemPtr);  // address after repeat is complete 
480C:  MOVFF  1AC,2E3
4810:  MOVFF  1AB,2E2
4814:  CALL   34F4
....................  
....................           if (gblRepeatCount > 1) { 
4818:  MOVLB  1
481A:  MOVF   x88,F
481C:  BNZ   4824
481E:  MOVF   x87,W
4820:  SUBLW  01
4822:  BC    484A
....................              stkPush(gblRepeatCount); 
4824:  MOVFF  188,2E3
4828:  MOVFF  187,2E2
482C:  MOVLB  0
482E:  CALL   34F4
....................              stkPush(gblLoopAddress); // address while still repeating 
4832:  MOVFF  186,2E3
4836:  MOVFF  185,2E2
483A:  CALL   34F4
....................              gblMemPtr = gblLoopAddress; 
483E:  MOVFF  186,1AC
4842:  MOVFF  185,1AB
....................         } else if (gblRepeatCount == 1) { 
4846:  BRA    486A
4848:  MOVLB  1
484A:  DECFSZ x87,W
484C:  BRA    485C
484E:  MOVF   x88,F
4850:  BNZ   485C
....................            gblMemPtr = gblLoopAddress; 
4852:  MOVFF  186,1AC
4856:  MOVFF  185,1AB
....................         } else {  // if loop count = 0 
485A:  BRA    486C
....................              gblMemPtr = stkPop(); 
485C:  MOVLB  0
485E:  CALL   3434
4862:  MOVFF  02,1AC
4866:  MOVFF  01,1AB
486A:  MOVLB  1
....................         } 
....................        break; 
486C:  BRA    4E54
....................       case  COND_IF: 
....................          opr1=stkPop();  // if true pointer address 
486E:  CALL   3434
4872:  MOVFF  02,2AB
4876:  MOVFF  01,2AA
....................          opr2=stkPop();  // condition 
487A:  CALL   3434
487E:  MOVFF  02,2AD
4882:  MOVFF  01,2AC
....................         //printf("if %LX goto %LX\r\n", opr2,opr1); 
....................          if (opr2) { 
4886:  MOVLB  2
4888:  MOVF   xAC,W
488A:  IORWF  xAD,W
488C:  BZ    48A4
....................             stkPush(gblMemPtr); 
488E:  MOVFF  1AC,2E3
4892:  MOVFF  1AB,2E2
4896:  MOVLB  0
4898:  CALL   34F4
....................             gblMemPtr=opr1; 
489C:  MOVFF  2AB,1AC
48A0:  MOVFF  2AA,1AB
....................          } 
....................          break; 
48A4:  MOVLB  1
48A6:  BRA    4E54
....................       case  COND_IFELSE: 
....................          opr1=stkPop(); // if false pointer address 
48A8:  CALL   3434
48AC:  MOVFF  02,2AB
48B0:  MOVFF  01,2AA
....................          opr2=stkPop(); // if true pointer address 
48B4:  CALL   3434
48B8:  MOVFF  02,2AD
48BC:  MOVFF  01,2AC
....................          opr3=stkPop(); // condition 
48C0:  CALL   3434
48C4:  MOVFF  02,2AF
48C8:  MOVFF  01,2AE
....................          stkPush(gblMemPtr); 
48CC:  MOVFF  1AC,2E3
48D0:  MOVFF  1AB,2E2
48D4:  CALL   34F4
....................          if (opr3) { 
48D8:  MOVLB  2
48DA:  MOVF   xAE,W
48DC:  IORWF  xAF,W
48DE:  BZ    48EA
....................             gblMemPtr=opr2; 
48E0:  MOVFF  2AD,1AC
48E4:  MOVFF  2AC,1AB
....................          } else { 
48E8:  BRA    48F2
....................             gblMemPtr=opr1; 
48EA:  MOVFF  2AB,1AC
48EE:  MOVFF  2AA,1AB
....................          } 
....................  
....................        break; 
48F2:  MOVLB  1
48F4:  BRA    4E54
....................       case  BEEP: 
....................           beep(); 
48F6:  CALL   2222
....................        break; 
48FA:  MOVLB  1
48FC:  BRA    4E54
....................       case  NOTE: 
....................        break; 
48FE:  MOVLB  1
4900:  BRA    4E54
....................       case  WAITUNTIL: 
....................           gblLoopAddress = stkPop(); 
4902:  CALL   3434
4906:  MOVFF  02,186
490A:  MOVFF  01,185
....................  
....................        // these will be poped by EOLR 
....................        stkPush(gblMemPtr);  // address after repeat is complete 
490E:  MOVFF  1AC,2E3
4912:  MOVFF  1AB,2E2
4916:  CALL   34F4
....................           stkPush(gblLoopAddress); // address while still repeating 
491A:  MOVFF  186,2E3
491E:  MOVFF  185,2E2
4922:  CALL   34F4
....................           gblMemPtr = gblLoopAddress; 
4926:  MOVFF  186,1AC
492A:  MOVFF  185,1AB
....................  
....................        break; 
492E:  MOVLB  1
4930:  BRA    4E54
....................       case  LOOP: 
....................          gblLoopAddress = stkPop(); // the begining of loop 
4932:  CALL   3434
4936:  MOVFF  02,186
493A:  MOVFF  01,185
....................          gblRepeatCount = 0; // disable this counter (loop forever) 
493E:  MOVLB  1
4940:  CLRF   x88
4942:  CLRF   x87
....................         stkPush(0);   // this distinguishes LOOP from Repeat. (see EOL) 
4944:  MOVLB  2
4946:  CLRF   xE3
4948:  CLRF   xE2
494A:  MOVLB  0
494C:  CALL   34F4
....................          stkPush(gblLoopAddress); // push loop address back into the stack 
4950:  MOVFF  186,2E3
4954:  MOVFF  185,2E2
4958:  CALL   34F4
....................                            // so that EOL will loop 
....................            gblMemPtr = gblLoopAddress; 
495C:  MOVFF  186,1AC
4960:  MOVFF  185,1AB
....................        //printf("LOOP loopaddress = %LX\r\n", gblLoopAddress); 
....................        break; 
4964:  MOVLB  1
4966:  BRA    4E54
....................       case  WAIT: 
....................           gblWaitCounter = stkPop();// the main() loop will pause until 
4968:  CALL   3434
496C:  MOVFF  02,21D
4970:  MOVFF  01,21C
....................                            // gblWaitCounter is 0. Timer1 ISR 
....................                             // subtracts its value every 0.1 sec. 
....................        break; 
4974:  MOVLB  1
4976:  BRA    4E54
....................  
....................  
....................       case  TIMER: 
....................          stkPush(gblTimer); // gblTimer increases every 1ms. See in RTCC interrupt 
4978:  MOVFF  21F,2E3
497C:  MOVFF  21E,2E2
4980:  CALL   34F4
....................        break; 
4984:  MOVLB  1
4986:  BRA    4E54
....................       case  RESETT: 
....................          gblTimer = 0; 
4988:  MOVLB  2
498A:  CLRF   x1F
498C:  CLRF   x1E
....................        break; 
498E:  MOVLB  1
4990:  BRA    4E54
....................  
....................       // Send will transmit a 16 bit value via the serial port  
....................       case  SEND: 
....................          genPurpose = stkPop(); 
4992:  CALL   3434
4996:  MOVFF  02,2B1
499A:  MOVFF  01,2B0
....................          printf(active_comm_putc, "%c%c", genPurpose>>8, genPurpose & 0xff); 
499E:  MOVFF  2B1,2B2
49A2:  MOVLB  2
49A4:  CLRF   xB3
49A6:  MOVFF  2B0,2B4
49AA:  CLRF   xB5
49AC:  MOVFF  2B1,2E2
49B0:  MOVLB  0
49B2:  CALL   1D06
49B6:  MOVFF  2B4,2E2
49BA:  CALL   1D06
....................        break; 
49BE:  MOVLB  1
49C0:  BRA    4E54
....................       
....................      // IR on the gogo USB receives commands from a SONY remote control. It 
....................      // does not use the IR to communicate with a computer like the Cricket. 
....................      case   IR: 
....................        // wait for the new IR code to arrive 
....................        while(!gblNewIRCodeHasArrivedFlag && gblLogoIsRunning) { delay_ms(1); } 
49C2:  MOVLB  2
49C4:  BTFSC  x4F.2
49C6:  BRA    49DA
49C8:  BTFSS  x0A.2
49CA:  BRA    49DA
49CC:  MOVLW  01
49CE:  MOVLB  9
49D0:  MOVWF  x2B
49D2:  MOVLB  0
49D4:  CALL   18F4
49D8:  BRA    49C2
....................        stkPush(gblIRCode); 
49DA:  MOVFF  24C,2E3
49DE:  MOVFF  24B,2E2
49E2:  MOVLB  0
49E4:  CALL   34F4
....................        gblNewIRCodeHasArrivedFlag = 0; 
49E8:  MOVLB  2
49EA:  BCF    x4F.2
....................        break; 
49EC:  MOVLB  1
49EE:  BRA    4E54
....................      case   NEWIR: 
....................        stkPush(gblNewIRCodeHasArrivedFlag); 
49F0:  MOVLW  00
49F2:  MOVLB  2
49F4:  BTFSC  x4F.2
49F6:  MOVLW  01
49F8:  MOVWF  xB2
49FA:  CLRF   xE3
49FC:  MOVWF  xE2
49FE:  MOVLB  0
4A00:  CALL   34F4
....................        break; 
4A04:  MOVLB  1
4A06:  BRA    4E54
....................  
....................      case   SERIAL: 
....................        // wait for a new Serial byte to arrive 
....................        while(!gblMostRecentlyReceivedByte && gblLogoIsRunning) { delay_us(500); } 
4A08:  MOVLB  2
4A0A:  MOVF   x1B,F
4A0C:  BNZ   4A28
4A0E:  BTFSS  x0A.2
4A10:  BRA    4A28
4A12:  MOVLW  02
4A14:  MOVWF  xB2
4A16:  MOVLW  FA
4A18:  MOVWF  xE4
4A1A:  MOVLB  0
4A1C:  CALL   2854
4A20:  MOVLB  2
4A22:  DECFSZ xB2,F
4A24:  BRA    4A16
4A26:  BRA    4A0A
....................        stkPush(gblMostRecentlyReceivedByte); 
4A28:  CLRF   xE3
4A2A:  MOVFF  21B,2E2
4A2E:  MOVLB  0
4A30:  CALL   34F4
....................        gblNewByteHasArrivedFlag = 0; 
4A34:  MOVLB  2
4A36:  BCF    x0A.1
....................        break; 
4A38:  MOVLB  1
4A3A:  BRA    4E54
....................      case   NEWSERIAL: 
....................        stkPush(gblNewByteHasArrivedFlag); 
4A3C:  MOVLW  00
4A3E:  MOVLB  2
4A40:  BTFSC  x0A.1
4A42:  MOVLW  01
4A44:  MOVWF  xB2
4A46:  CLRF   xE3
4A48:  MOVWF  xE2
4A4A:  MOVLB  0
4A4C:  CALL   34F4
....................        break; 
4A50:  MOVLB  1
4A52:  BRA    4E54
....................  
....................  
....................      case  RANDOM: 
....................           stkPush(rand()); 
4A54:  GOTO   35F2
4A58:  MOVFF  02,2B3
4A5C:  MOVFF  01,2B2
4A60:  MOVFF  02,2E3
4A64:  MOVFF  01,2E2
4A68:  CALL   34F4
....................        break; 
4A6C:  MOVLB  1
4A6E:  BRA    4E54
....................  
....................       case  OP_PLUS: 
....................       case  OP_MINUS: 
....................       case  OP_MULTIPLY: 
....................       case  OP_DIVISION: 
....................       case  OP_REMAINDER: 
....................       case  OP_EQUAL: 
....................       case  OP_GREATER: 
....................       case  OP_LESS: 
....................       case  OP_AND: 
....................       case  OP_OR: 
....................       case  OP_XOR: 
....................  
....................          opr2=stkPop();  // second operand 
4A70:  CALL   3434
4A74:  MOVFF  02,2AD
4A78:  MOVFF  01,2AC
....................          opr1=stkPop();  // first operand 
4A7C:  CALL   3434
4A80:  MOVFF  02,2AB
4A84:  MOVFF  01,2AA
....................          //printf("op1=%LX\r\n",opr1); 
....................          //printf("op2=%LX\r\n",opr2); 
....................          switch (opcode) { 
4A88:  MOVLW  17
4A8A:  MOVLB  2
4A8C:  SUBWF  xA8,W
4A8E:  ADDLW  F5
4A90:  BTFSC  FD8.0
4A92:  BRA    4BB4
4A94:  ADDLW  0B
4A96:  MOVLB  0
4A98:  GOTO   4E5A
....................             case  OP_PLUS: 
....................                opr1+=opr2; 
4A9C:  MOVLB  2
4A9E:  MOVF   xAC,W
4AA0:  ADDWF  xAA,F
4AA2:  MOVF   xAD,W
4AA4:  ADDWFC xAB,F
....................                break; 
4AA6:  BRA    4BB4
....................             case  OP_MINUS: 
....................                opr1-=opr2; 
4AA8:  MOVLB  2
4AAA:  MOVF   xAC,W
4AAC:  SUBWF  xAA,F
4AAE:  MOVF   xAD,W
4AB0:  SUBWFB xAB,F
....................                break; 
4AB2:  BRA    4BB4
....................             case  OP_MULTIPLY: 
4AB4:  CLRF   19
4AB6:  BTFSC  FF2.7
4AB8:  BSF    19.7
4ABA:  BCF    FF2.7
....................                opr1*=opr2; 
4ABC:  MOVFF  2AB,A5D
4AC0:  MOVFF  2AA,A5C
4AC4:  MOVFF  2AD,A5F
4AC8:  MOVFF  2AC,A5E
4ACC:  CALL   030A
4AD0:  BTFSC  19.7
4AD2:  BSF    FF2.7
4AD4:  MOVFF  02,2AB
4AD8:  MOVFF  01,2AA
....................                break; 
4ADC:  MOVLB  2
4ADE:  BRA    4BB4
....................             case  OP_DIVISION: 
....................                opr1/=opr2; 
4AE0:  MOVFF  2AB,2E6
4AE4:  MOVFF  2AA,2E5
4AE8:  MOVFF  2AD,2E8
4AEC:  MOVFF  2AC,2E7
4AF0:  CALL   35AC
4AF4:  MOVFF  02,2AB
4AF8:  MOVFF  01,2AA
....................                break; 
4AFC:  MOVLB  2
4AFE:  BRA    4BB4
....................             case  OP_REMAINDER: 
....................                opr1%=opr2; 
4B00:  MOVFF  2AB,2E6
4B04:  MOVFF  2AA,2E5
4B08:  MOVFF  2AD,2E8
4B0C:  MOVFF  2AC,2E7
4B10:  CALL   35AC
4B14:  MOVFF  00,2AA
4B18:  MOVLB  2
4B1A:  MOVFF  03,2AB
....................                break; 
4B1E:  BRA    4BB4
....................             case  OP_EQUAL: 
....................                opr1=(opr1==opr2); 
4B20:  MOVLB  2
4B22:  MOVF   xAC,W
4B24:  SUBWF  xAA,W
4B26:  BNZ   4B2E
4B28:  MOVF   xAD,W
4B2A:  SUBWF  xAB,W
4B2C:  BZ    4B32
4B2E:  MOVLW  00
4B30:  BRA    4B34
4B32:  MOVLW  01
4B34:  CLRF   xAB
4B36:  MOVWF  xAA
....................                break; 
4B38:  BRA    4BB4
....................             case  OP_GREATER: 
....................                opr1=(opr1>opr2); 
4B3A:  MOVLB  2
4B3C:  MOVF   xAD,W
4B3E:  SUBWF  xAB,W
4B40:  BNC   4B4A
4B42:  BNZ   4B4E
4B44:  MOVF   xAA,W
4B46:  SUBWF  xAC,W
4B48:  BNC   4B4E
4B4A:  MOVLW  00
4B4C:  BRA    4B50
4B4E:  MOVLW  01
4B50:  CLRF   xAB
4B52:  MOVWF  xAA
....................                break; 
4B54:  BRA    4BB4
....................             case  OP_LESS: 
....................                opr1=(opr1<opr2); 
4B56:  MOVLB  2
4B58:  MOVF   xAB,W
4B5A:  SUBWF  xAD,W
4B5C:  BNC   4B66
4B5E:  BNZ   4B6A
4B60:  MOVF   xAC,W
4B62:  SUBWF  xAA,W
4B64:  BNC   4B6A
4B66:  MOVLW  00
4B68:  BRA    4B6C
4B6A:  MOVLW  01
4B6C:  CLRF   xAB
4B6E:  MOVWF  xAA
....................                break; 
4B70:  BRA    4BB4
....................             case  OP_AND: 
....................                opr1=(opr1&&opr2); 
4B72:  MOVLB  2
4B74:  MOVF   xAA,W
4B76:  IORWF  xAB,W
4B78:  BZ    4B80
4B7A:  MOVF   xAC,W
4B7C:  IORWF  xAD,W
4B7E:  BNZ   4B84
4B80:  MOVLW  00
4B82:  BRA    4B86
4B84:  MOVLW  01
4B86:  CLRF   xAB
4B88:  MOVWF  xAA
....................                break; 
4B8A:  BRA    4BB4
....................             case  OP_OR: 
....................                opr1=(opr1||opr2); 
4B8C:  MOVLB  2
4B8E:  MOVF   xAA,W
4B90:  IORWF  xAB,W
4B92:  BNZ   4B9E
4B94:  MOVF   xAC,W
4B96:  IORWF  xAD,W
4B98:  BNZ   4B9E
4B9A:  MOVLW  00
4B9C:  BRA    4BA0
4B9E:  MOVLW  01
4BA0:  CLRF   xAB
4BA2:  MOVWF  xAA
....................                break; 
4BA4:  BRA    4BB4
....................             case  OP_XOR: 
....................                opr1=(opr1^opr2); 
4BA6:  MOVLB  2
4BA8:  MOVF   xAC,W
4BAA:  XORWF  xAA,F
4BAC:  MOVF   xAD,W
4BAE:  XORWF  xAB,F
....................                break; 
4BB0:  BRA    4BB4
4BB2:  MOVLB  2
....................             }; 
....................        //printf("result=%LX\r\n", opr1); 
....................        stkPush(opr1); 
4BB4:  MOVFF  2AB,2E3
4BB8:  MOVFF  2AA,2E2
4BBC:  MOVLB  0
4BBE:  CALL   34F4
....................        break; 
4BC2:  MOVLB  1
4BC4:  BRA    4E54
....................  
....................       case  OP_NOT: 
....................        stkPush(!stkPop()); 
4BC6:  CALL   3434
4BCA:  MOVF   01,W
4BCC:  IORWF  02,W
4BCE:  MOVLW  00
4BD0:  BTFSC  FD8.2
4BD2:  MOVLW  01
4BD4:  MOVLB  2
4BD6:  MOVWF  xB2
4BD8:  CLRF   xE3
4BDA:  MOVWF  xE2
4BDC:  MOVLB  0
4BDE:  CALL   34F4
....................        break; 
4BE2:  MOVLB  1
4BE4:  BRA    4E54
....................  
....................  
....................      /////////////////////////////////////////////////////////////////////// 
....................      // Global variables 
....................       case  SETGLOBAL: 
....................           genPurpose = stkPop();  // this is the value 
4BE6:  CALL   3434
4BEA:  MOVFF  02,2B1
4BEE:  MOVFF  01,2B0
....................           globalVariables[stkPop()] = genPurpose; 
4BF2:  CALL   3434
4BF6:  MOVFF  02,2B3
4BFA:  BCF    FD8.0
4BFC:  MOVLB  2
4BFE:  RLCF   01,W
4C00:  MOVWF  02
4C02:  RLCF   xB3,W
4C04:  MOVWF  03
4C06:  MOVF   02,W
4C08:  ADDLW  89
4C0A:  MOVWF  FE9
4C0C:  MOVLW  01
4C0E:  ADDWFC 03,W
4C10:  MOVWF  FEA
4C12:  MOVFF  2B1,FEC
4C16:  MOVF   FED,F
4C18:  MOVFF  2B0,FEF
....................        break; 
4C1C:  MOVLB  1
4C1E:  BRA    4E54
....................       case  GETGLOBAL: 
....................          stkPush(globalVariables[stkPop()]); 
4C20:  CALL   3434
4C24:  MOVFF  02,2B3
4C28:  BCF    FD8.0
4C2A:  MOVLB  2
4C2C:  RLCF   01,W
4C2E:  MOVWF  02
4C30:  RLCF   xB3,W
4C32:  MOVWF  03
4C34:  MOVF   02,W
4C36:  ADDLW  89
4C38:  MOVWF  FE9
4C3A:  MOVLW  01
4C3C:  ADDWFC 03,W
4C3E:  MOVWF  FEA
4C40:  MOVFF  FEC,2B3
4C44:  MOVF   FED,F
4C46:  MOVFF  FEF,2B2
4C4A:  MOVFF  2B3,2E3
4C4E:  MOVFF  2B2,2E2
4C52:  MOVLB  0
4C54:  CALL   34F4
....................        break; 
4C58:  MOVLB  1
4C5A:  BRA    4E54
....................  
....................       /////////////////////////////////////////////////////////////////////// 
....................       //  Global Array 
....................  
....................       case  ASET: 
....................           opr2 = stkPop();      // this is the value to be stored 
4C5C:  CALL   3434
4C60:  MOVFF  02,2AD
4C64:  MOVFF  01,2AC
....................           opr1 = stkPop() * 2;   // this is the array index. Each entry is two bytes wide. 
4C68:  CALL   3434
4C6C:  BCF    FD8.0
4C6E:  MOVLB  2
4C70:  RLCF   01,W
4C72:  MOVWF  xAA
4C74:  RLCF   02,W
4C76:  MOVWF  xAB
....................           genPurpose = ARRAY_BASE_ADDRESS + stkPop();  // this is the base address of the array. 
4C78:  MOVLB  0
4C7A:  CALL   3434
4C7E:  MOVFF  01,2B0
4C82:  MOVLB  2
4C84:  MOVLW  E4
4C86:  ADDWF  02,W
4C88:  MOVWF  xB1
....................  
....................          #if defined(__PCM__) 
....................  
....................           write_ext_eeprom(genPurpose + opr1, opr2 & 0xff); // low byte 
....................           write_ext_eeprom(genPurpose + opr1 + 1, opr2 >> 8); // high byte 
....................  
....................          #elif defined(__PCH__) 
....................           
....................           FLASHSetWordAddress( (genPurpose + opr1)<<1); 
4C8A:  MOVF   xAA,W
4C8C:  ADDWF  xB0,W
4C8E:  MOVWF  xB2
4C90:  MOVF   xAB,W
4C92:  ADDWFC xB1,W
4C94:  MOVWF  xB3
4C96:  BCF    FD8.0
4C98:  RLCF   xB2,F
4C9A:  RLCF   xB3,F
4C9C:  MOVFF  2B3,2E7
4CA0:  MOVFF  2B2,2E6
4CA4:  MOVLB  0
4CA6:  CALL   218C
....................           FLASHWrite(opr2); 
4CAA:  MOVFF  2AD,2E1
4CAE:  MOVFF  2AC,2E0
4CB2:  CALL   2CF0
....................           
....................          #endif 
....................  
....................        break; 
4CB6:  MOVLB  1
4CB8:  BRA    4E54
....................       case  AGET: 
....................           opr1 = stkPop() * 2;   // this is the array index. Each entry is two bytes wide. 
4CBA:  CALL   3434
4CBE:  BCF    FD8.0
4CC0:  MOVLB  2
4CC2:  RLCF   01,W
4CC4:  MOVWF  xAA
4CC6:  RLCF   02,W
4CC8:  MOVWF  xAB
....................           genPurpose = ARRAY_BASE_ADDRESS + stkPop();  // this is the base address of the array. 
4CCA:  MOVLB  0
4CCC:  CALL   3434
4CD0:  MOVFF  01,2B0
4CD4:  MOVLB  2
4CD6:  MOVLW  E4
4CD8:  ADDWF  02,W
4CDA:  MOVWF  xB1
....................  
....................           #if defined(__PCM__) 
....................            
....................           opr2 = read_ext_eeprom(genPurpose + opr1); 
....................           opr2 |= (int16)read_ext_eeprom(genPurpose + opr1 + 1) << 8; 
....................  
....................           #elif defined(__PCH__) 
....................            
....................           opr2 = read_program_eeprom(genPurpose + opr1);  
4CDC:  MOVF   xAA,W
4CDE:  ADDWF  xB0,W
4CE0:  MOVWF  xB2
4CE2:  MOVF   xAB,W
4CE4:  ADDWFC xB1,W
4CE6:  MOVFF  FF2,2B4
4CEA:  BCF    FF2.7
4CEC:  CLRF   FF8
4CEE:  MOVWF  FF7
4CF0:  MOVFF  2B2,FF6
4CF4:  TBLRD*+
4CF6:  MOVF   FF5,W
4CF8:  TBLRD*
4CFA:  MOVFF  FF5,03
4CFE:  CLRF   FF8
4D00:  BTFSC  xB4.7
4D02:  BSF    FF2.7
4D04:  MOVWF  xAC
4D06:  MOVFF  03,2AD
....................            
....................           #endif 
....................  
....................           stkPush(opr2); 
4D0A:  MOVFF  2AD,2E3
4D0E:  MOVFF  2AC,2E2
4D12:  MOVLB  0
4D14:  CALL   34F4
....................  
....................  
....................        break; 
4D18:  MOVLB  1
4D1A:  BRA    4E54
....................  
....................       ///////////////////////////////////////////////////////////////////////// 
....................       //  Data collection commands 
....................  
....................       case  RECORD: 
....................           genPurpose = stkPop(); 
4D1C:  CALL   3434
4D20:  MOVFF  02,2B1
4D24:  MOVFF  01,2B0
....................  
....................           // PCM parts (14 bit PICs like the 16F877) uses an external EEPROM 
....................           // for data Logging storage 
....................           #if defined(__PCM__) 
....................           
....................           // record the data 
....................           write_ext_eeprom(RECORD_BASE_ADDRESS + gblRecordPtr++, genPurpose & 0xff); // low byte 
....................           write_ext_eeprom(RECORD_BASE_ADDRESS + gblRecordPtr++, genPurpose >> 8); // high byte 
....................  
....................           // save current record pointer location to the internal EEPROM 
....................           // we use this for the automatic data upload to the PC 
....................           write_ext_eeprom(MEM_PTR_LOG_BASE_ADDRESS, gblRecordPtr & 0xff); 
....................           write_ext_eeprom(MEM_PTR_LOG_BASE_ADDRESS + 1, gblRecordPtr >> 8); 
....................            
....................            
....................           // PCH parts (16 bit PICs like the 18F458) uses the internal flash 
....................           #elif defined(__PCH__) 
....................            
....................           // record the data 
....................           FLASHSetWordAddress(RECORD_BASE_ADDRESS + ((gblRecordPtr++)<<1)); 
4D28:  MOVLB  1
4D2A:  MOVFF  1AA,03
4D2E:  MOVF   xA9,W
4D30:  INCF   xA9,F
4D32:  BTFSC  FD8.2
4D34:  INCF   xAA,F
4D36:  MOVLB  2
4D38:  MOVWF  xB2
4D3A:  MOVFF  03,2B3
4D3E:  BCF    FD8.0
4D40:  RLCF   xB2,W
4D42:  MOVWF  02
4D44:  RLCF   03,W
4D46:  MOVWF  03
4D48:  MOVFF  02,2B2
4D4C:  MOVLW  58
4D4E:  ADDWF  03,W
4D50:  MOVWF  xB3
4D52:  MOVWF  xE7
4D54:  MOVFF  02,2E6
4D58:  MOVLB  0
4D5A:  CALL   218C
....................           FLASHWrite(genPurpose); 
4D5E:  MOVFF  2B1,2E1
4D62:  MOVFF  2B0,2E0
4D66:  CALL   2CF0
....................            
....................           // save current record pointer location  
....................           FLASHSetWordAddress(MEM_PTR_LOG_BASE_ADDRESS); 
4D6A:  MOVLW  F9
4D6C:  MOVLB  2
4D6E:  MOVWF  xE7
4D70:  MOVLW  F0
4D72:  MOVWF  xE6
4D74:  MOVLB  0
4D76:  CALL   218C
....................           FLASHWrite(gblRecordPtr);           
4D7A:  MOVFF  1AA,2E1
4D7E:  MOVFF  1A9,2E0
4D82:  CALL   2CF0
....................            
....................           #endif 
....................  
....................  
....................        break; 
4D86:  MOVLB  1
4D88:  BRA    4E54
....................  
....................       case  RECALL: 
....................  
....................           #if defined(__PCM__) 
....................  
....................           genPurpose = read_ext_eeprom(RECORD_BASE_ADDRESS + gblRecordPtr++); 
....................           genPurpose |= ((int16)read_ext_eeprom(RECORD_BASE_ADDRESS + gblRecordPtr++) << 8); 
....................  
....................          #elif defined (__PCH__) 
....................           
....................          genPurpose = read_program_eeprom(RECORD_BASE_ADDRESS + (gblRecordPtr<<1) ); 
4D8A:  BCF    FD8.0
4D8C:  MOVLB  1
4D8E:  RLCF   xA9,W
4D90:  MOVWF  02
4D92:  RLCF   xAA,W
4D94:  MOVWF  03
4D96:  MOVLB  2
4D98:  MOVLW  58
4D9A:  ADDWF  03,W
4D9C:  MOVFF  FF2,2B4
4DA0:  BCF    FF2.7
4DA2:  CLRF   FF8
4DA4:  MOVWF  FF7
4DA6:  MOVFF  02,FF6
4DAA:  TBLRD*+
4DAC:  MOVF   FF5,W
4DAE:  TBLRD*
4DB0:  MOVFF  FF5,03
4DB4:  CLRF   FF8
4DB6:  BTFSC  xB4.7
4DB8:  BSF    FF2.7
4DBA:  MOVWF  xB0
4DBC:  MOVFF  03,2B1
....................          gblRecordPtr++; 
4DC0:  MOVLB  1
4DC2:  INCF   xA9,F
4DC4:  BTFSC  FD8.2
4DC6:  INCF   xAA,F
....................                 //foo = read_program_eeprom(RECORD_BASE_ADDRESS + (counter<<1)); 
....................  
....................          #endif 
....................           
....................           stkPush(genPurpose); 
4DC8:  MOVFF  2B1,2E3
4DCC:  MOVFF  2B0,2E2
4DD0:  MOVLB  0
4DD2:  CALL   34F4
....................        break; 
4DD6:  MOVLB  1
4DD8:  BRA    4E54
....................         
....................       case  RESETDP: 
....................        gblRecordPtr = 0; 
4DDA:  MOVLB  1
4DDC:  CLRF   xAA
4DDE:  CLRF   xA9
....................        break; 
4DE0:  BRA    4E54
....................        
....................       case  SETDP: 
....................        gblRecordPtr = stkPop(); 
4DE2:  CALL   3434
4DE6:  MOVFF  02,1AA
4DEA:  MOVFF  01,1A9
....................        break; 
4DEE:  MOVLB  1
4DF0:  BRA    4E54
....................        
....................       case  ERASE: 
....................           opr1 = stkPop() * 2; 
4DF2:  CALL   3434
4DF6:  BCF    FD8.0
4DF8:  MOVLB  2
4DFA:  RLCF   01,W
4DFC:  MOVWF  xAA
4DFE:  RLCF   02,W
4E00:  MOVWF  xAB
....................           for (genPurpose=0 ; genPurpose<opr1 ; genPurpose++) { 
4E02:  CLRF   xB1
4E04:  CLRF   xB0
4E06:  MOVF   xB1,W
4E08:  SUBWF  xAB,W
4E0A:  BNC   4E40
4E0C:  BNZ   4E14
4E0E:  MOVF   xAA,W
4E10:  SUBWF  xB0,W
4E12:  BC    4E40
....................  
....................              #if defined(__PCM__) 
....................              write_ext_eeprom(RECORD_BASE_ADDRESS + genPurpose, 0); 
....................  
....................              #elif defined(__PCH__) 
....................              FLASHSetWordAddress(RECORD_BASE_ADDRESS + genPurpose); 
4E14:  MOVFF  2B0,2B2
4E18:  MOVLW  58
4E1A:  ADDWF  xB1,W
4E1C:  MOVWF  xB3
4E1E:  MOVWF  xE7
4E20:  MOVFF  2B0,2E6
4E24:  MOVLB  0
4E26:  CALL   218C
....................              FLASHWrite(0);              
4E2A:  MOVLB  2
4E2C:  CLRF   xE1
4E2E:  CLRF   xE0
4E30:  MOVLB  0
4E32:  CALL   2CF0
....................  
....................              #endif 
....................  
....................  
....................         } 
4E36:  MOVLB  2
4E38:  INCF   xB0,F
4E3A:  BTFSC  FD8.2
4E3C:  INCF   xB1,F
4E3E:  BRA    4E06
....................         gblRecordPtr = 0; 
4E40:  MOVLB  1
4E42:  CLRF   xAA
4E44:  CLRF   xA9
....................        break; 
4E46:  BRA    4E54
4E48:  MOVLB  0
....................  
....................  
....................  
....................  
....................      ///////////////////////////////////////////////////////////////// 
....................      //  Due to the PIC's memory architecture, we need to split this 
....................      //  procedure so that it isn't too big to fit one memory segment. 
....................       default:  evalOpcode2(opcode); 
4E4A:  MOVFF  2A8,2B2
4E4E:  GOTO   3D84
4E52:  MOVLB  1
....................       }; 
.................... } 
4E54:  MOVLB  0
4E56:  GOTO   53FC (RETURN)
....................  
....................  
....................  
.................... #separate void evalOpcode2(unsigned char opcode) { 
3D84:  MOVLB  2
3D86:  CLRF   xB3
3D88:  CLRF   xBB
3D8A:  CLRF   xBA
....................  
.................... int i=0; 
.................... int16 opr1, opr2, opr3; 
.................... unsigned int16 genPurpose=0; 
.................... char *strPtr;  // used with the show long string command 
.................... int strLen;    //  used with the show long string command 
.................... char displayModuleBuffer[33]; // 16x2 LCD display buffer. The 33 location is for the null terminating char 
....................  
....................    switch (opcode) { 
3D8C:  MOVF   xB2,W
3D8E:  XORLW  2C
3D90:  MOVLB  0
3D92:  BTFSC  FD8.2
3D94:  BRA    3EFA
3D96:  XORLW  01
3D98:  BTFSC  FD8.2
3D9A:  BRA    3EFC
3D9C:  XORLW  03
3D9E:  BTFSC  FD8.2
3DA0:  BRA    3EFE
3DA2:  XORLW  01
3DA4:  BTFSC  FD8.2
3DA6:  BRA    3F08
3DA8:  XORLW  1F
3DAA:  BTFSC  FD8.2
3DAC:  BRA    3F12
3DAE:  XORLW  03
3DB0:  BTFSC  FD8.2
3DB2:  BRA    3F1C
3DB4:  XORLW  06
3DB6:  BTFSC  FD8.2
3DB8:  BRA    3F22
3DBA:  XORLW  01
3DBC:  BTFSC  FD8.2
3DBE:  BRA    3F28
3DC0:  XORLW  02
3DC2:  BTFSC  FD8.2
3DC4:  BRA    3F2E
3DC6:  XORLW  0A
3DC8:  BTFSC  FD8.2
3DCA:  BRA    3F34
3DCC:  XORLW  0D
3DCE:  BTFSC  FD8.2
3DD0:  BRA    3F3A
3DD2:  XORLW  03
3DD4:  BTFSC  FD8.2
3DD6:  BRA    3F3A
3DD8:  XORLW  09
3DDA:  BTFSC  FD8.2
3DDC:  BRA    3F5E
3DDE:  XORLW  06
3DE0:  BTFSC  FD8.2
3DE2:  BRA    3F74
3DE4:  XORLW  03
3DE6:  BTFSC  FD8.2
3DE8:  BRA    3F74
3DEA:  XORLW  01
3DEC:  BTFSC  FD8.2
3DEE:  BRA    3F7A
3DF0:  XORLW  7F
3DF2:  BTFSC  FD8.2
3DF4:  BRA    3F84
3DF6:  XORLW  01
3DF8:  BTFSC  FD8.2
3DFA:  BRA    3F8E
3DFC:  XORLW  03
3DFE:  BTFSC  FD8.2
3E00:  BRA    3F98
3E02:  XORLW  06
3E04:  BTFSC  FD8.2
3E06:  BRA    3FA2
3E08:  XORLW  01
3E0A:  BTFSC  FD8.2
3E0C:  BRA    3FAC
3E0E:  XORLW  03
3E10:  BTFSC  FD8.2
3E12:  BRA    3FE6
3E14:  XORLW  01
3E16:  BTFSC  FD8.2
3E18:  BRA    4018
3E1A:  XORLW  0F
3E1C:  BTFSC  FD8.2
3E1E:  BRA    4038
3E20:  XORLW  7F
3E22:  BTFSC  FD8.2
3E24:  BRA    4058
3E26:  XORLW  0F
3E28:  BTFSC  FD8.2
3E2A:  BRA    4058
3E2C:  XORLW  71
3E2E:  BTFSC  FD8.2
3E30:  BRA    4058
3E32:  XORLW  03
3E34:  BTFSC  FD8.2
3E36:  BRA    4058
3E38:  XORLW  01
3E3A:  BTFSC  FD8.2
3E3C:  BRA    4058
3E3E:  XORLW  07
3E40:  BTFSC  FD8.2
3E42:  BRA    4058
3E44:  XORLW  01
3E46:  BTFSC  FD8.2
3E48:  BRA    4058
3E4A:  XORLW  03
3E4C:  BTFSC  FD8.2
3E4E:  BRA    4058
3E50:  XORLW  77
3E52:  BTFSC  FD8.2
3E54:  BRA    40A2
3E56:  XORLW  03
3E58:  BTFSC  FD8.2
3E5A:  BRA    40A2
3E5C:  XORLW  75
3E5E:  BTFSC  FD8.2
3E60:  BRA    40A2
3E62:  XORLW  1F
3E64:  BTFSC  FD8.2
3E66:  BRA    40A2
3E68:  XORLW  01
3E6A:  BTFSC  FD8.2
3E6C:  BRA    40A2
3E6E:  XORLW  03
3E70:  BTFSC  FD8.2
3E72:  BRA    40A2
3E74:  XORLW  01
3E76:  BTFSC  FD8.2
3E78:  BRA    40A2
3E7A:  XORLW  07
3E7C:  BTFSC  FD8.2
3E7E:  BRA    40A2
3E80:  XORLW  01
3E82:  BTFSC  FD8.2
3E84:  BRA    40FA
3E86:  XORLW  03
3E88:  BTFSC  FD8.2
3E8A:  BRA    40FE
3E8C:  XORLW  01
3E8E:  BTFSC  FD8.2
3E90:  BRA    4102
3E92:  XORLW  0F
3E94:  BTFSC  FD8.2
3E96:  BRA    4102
3E98:  XORLW  01
3E9A:  BTFSC  FD8.2
3E9C:  BRA    4102
3E9E:  XORLW  03
3EA0:  BTFSC  FD8.2
3EA2:  BRA    4170
3EA4:  XORLW  01
3EA6:  BTFSC  FD8.2
3EA8:  BRA    4186
3EAA:  XORLW  07
3EAC:  BTFSC  FD8.2
3EAE:  BRA    4194
3EB0:  XORLW  01
3EB2:  BTFSC  FD8.2
3EB4:  BRA    41A2
3EB6:  XORLW  03
3EB8:  BTFSC  FD8.2
3EBA:  BRA    41B8
3EBC:  XORLW  3F
3EBE:  BTFSC  FD8.2
3EC0:  BRA    41E0
3EC2:  XORLW  03
3EC4:  BTFSC  FD8.2
3EC6:  BRA    41E6
3EC8:  XORLW  01
3ECA:  BTFSC  FD8.2
3ECC:  BRA    420E
3ECE:  XORLW  07
3ED0:  BTFSC  FD8.2
3ED2:  BRA    4314
3ED4:  XORLW  01
3ED6:  BTFSC  FD8.2
3ED8:  BRA    4318
3EDA:  XORLW  03
3EDC:  BTFSC  FD8.2
3EDE:  BRA    432E
3EE0:  XORLW  01
3EE2:  BTFSC  FD8.2
3EE4:  BRA    4342
3EE6:  XORLW  0F
3EE8:  BTFSC  FD8.2
3EEA:  BRA    434E
3EEC:  XORLW  01
3EEE:  BTFSC  FD8.2
3EF0:  BRA    435A
3EF2:  XORLW  03
3EF4:  BTFSC  FD8.2
3EF6:  BRA    4366
3EF8:  BRA    4372
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................       case  WHEN: 
....................        break; 
3EFA:  BRA    4376
....................       case  WHENOFF: 
....................        break; 
3EFC:  BRA    4376
....................       case  M_A: 
....................           gblActiveMotors = 0b00000001;  // set bit 0 
3EFE:  MOVLW  01
3F00:  MOVLB  1
3F02:  MOVWF  xFD
....................        break; 
3F04:  MOVLB  0
3F06:  BRA    4376
....................       case  M_B: 
....................           gblActiveMotors = 0b00000010;  // set bit 1 
3F08:  MOVLW  02
3F0A:  MOVLB  1
3F0C:  MOVWF  xFD
....................        break; 
3F0E:  MOVLB  0
3F10:  BRA    4376
....................       case  M_AB: 
....................           gblActiveMotors = 0b00000011; 
3F12:  MOVLW  03
3F14:  MOVLB  1
3F16:  MOVWF  xFD
....................        break; 
3F18:  MOVLB  0
3F1A:  BRA    4376
....................  
....................       ////////////////////////////////////////////////////// 
....................  
....................      // Look at how M_ON, M_ONFOR, and M_OFF work carefully. 
....................      // - M_ON, M_ONFOR starts by turning motors on. 
....................      // - M_ON breaks right after while M_ONFOR continues. 
....................  
....................  
....................  
....................       case  M_OFF:         i++; 
3F1C:  MOVLB  2
3F1E:  INCF   xB3,F
3F20:  MOVLB  0
....................       case  M_THATWAY:     i++; 
3F22:  MOVLB  2
3F24:  INCF   xB3,F
3F26:  MOVLB  0
....................       case  M_THISWAY:     i++; 
3F28:  MOVLB  2
3F2A:  INCF   xB3,F
3F2C:  MOVLB  0
....................       case  M_RD:          i++; 
3F2E:  MOVLB  2
3F30:  INCF   xB3,F
3F32:  MOVLB  0
....................       case  BRAKE:         i++; 
3F34:  MOVLB  2
3F36:  INCF   xB3,F
3F38:  MOVLB  0
....................       case  M_ON: 
....................       case  M_ONFOR: 
....................  
.................... // Moved to motorCortol() instead 
.................... //         SetMotorMode(MOTOR_NORMAL); 
....................          MotorControl(i); 
3F3A:  MOVFF  2B3,2E0
3F3E:  CALL   2B1C
....................  
....................          if (opcode == M_ONFOR) { 
3F42:  MOVLB  2
3F44:  MOVF   xB2,W
3F46:  SUBLW  32
3F48:  BNZ   3F5A
....................            gblWaitCounter = stkPop(); // the main() loop will pause until 
3F4A:  MOVLB  0
3F4C:  CALL   3434
3F50:  MOVFF  02,21D
3F54:  MOVFF  01,21C
....................                                // gblWaitCounter is 0. Timer1 ISR 
....................                                // subtracts its value every 0.1 sec. 
....................  
....................             gblONFORNeedsToFinish = 1; // this will cause fetchNextOpcode() 
3F58:  BSF    x7F.1
....................          } 
....................  
....................  //        printf( "i=%d\r\n",i); 
....................  
....................          break; 
3F5A:  MOVLB  0
3F5C:  BRA    4376
....................  
....................  
....................      //////////////////////////////////////////////////// 
....................  
....................       case  SETPOWER: 
....................        SetMotorPower(stkPop()); 
3F5E:  CALL   3434
3F62:  MOVFF  02,2E1
3F66:  MOVFF  01,2E0
3F6A:  MOVFF  01,2E2
3F6E:  CALL   2BC2
....................        break; 
3F72:  BRA    4376
....................  
....................       case  BSEND: 
....................       case  BSR: 
....................          // These two opcodes are not supported. 
....................          // So, halt the board if they are used. 
....................       Halt(); 
3F74:  CALL   3674
....................       break; 
3F78:  BRA    4376
....................       case  M_C: 
....................           gblActiveMotors = 0b00000100;  // set bit 2 
3F7A:  MOVLW  04
3F7C:  MOVLB  1
3F7E:  MOVWF  xFD
....................        break; 
3F80:  MOVLB  0
3F82:  BRA    4376
....................       case  M_D: 
....................           gblActiveMotors = 0b00001000;  // set bit 3 
3F84:  MOVLW  08
3F86:  MOVLB  1
3F88:  MOVWF  xFD
....................        break; 
3F8A:  MOVLB  0
3F8C:  BRA    4376
....................       case  M_CD: 
....................           gblActiveMotors = 0b00001100; 
3F8E:  MOVLW  0C
3F90:  MOVLB  1
3F92:  MOVWF  xFD
....................        break; 
3F94:  MOVLB  0
3F96:  BRA    4376
....................       case  M_ABCD: 
....................        gblActiveMotors = 0b00001111; 
3F98:  MOVLW  0F
3F9A:  MOVLB  1
3F9C:  MOVWF  xFD
....................        break; 
3F9E:  MOVLB  0
3FA0:  BRA    4376
.................... //      case  FASTSEND: 
.................... //       break; 
....................  
....................       case  REALLY_STOP: 
....................        gblLogoIsRunning = 0; 
3FA2:  MOVLB  2
3FA4:  BCF    x0A.2
....................        output_low(RUN_LED); 
3FA6:  BCF    F8B.1
....................        break; 
3FA8:  MOVLB  0
3FAA:  BRA    4376
....................  
....................       case  EB:  // reads byte from memory 
....................            #if defined(__PCM__) 
....................               stkPush(read_ext_eeprom(stkPop())); 
....................            #elif defined(__PCH__) 
....................               stkPush(read_program_eeprom(stkPop())); 
3FAC:  CALL   3434
3FB0:  MOVFF  FF2,2E2
3FB4:  BCF    FF2.7
3FB6:  CLRF   FF8
3FB8:  MOVFF  02,FF7
3FBC:  MOVFF  01,FF6
3FC0:  TBLRD*+
3FC2:  MOVF   FF5,W
3FC4:  TBLRD*
3FC6:  MOVFF  FF5,03
3FCA:  CLRF   FF8
3FCC:  MOVLB  2
3FCE:  BTFSC  xE2.7
3FD0:  BSF    FF2.7
3FD2:  MOVWF  xE0
3FD4:  MOVFF  03,2E1
3FD8:  MOVFF  03,2E3
3FDC:  MOVWF  xE2
3FDE:  MOVLB  0
3FE0:  CALL   34F4
....................            #endif 
....................        break; 
3FE4:  BRA    4376
....................  
....................       case  DB:  // deposit byte to memory 
....................            /// Note: I have checked this code. I might have swapped opr1 and opr2 
....................            opr1 = stkPop(); // value to write 
3FE6:  CALL   3434
3FEA:  MOVFF  02,2B5
3FEE:  MOVFF  01,2B4
....................            opr2 = stkPop(); // memory address 
3FF2:  CALL   3434
3FF6:  MOVFF  02,2B7
3FFA:  MOVFF  01,2B6
....................             
....................           #if defined(__PCM__) 
....................              write_ext_eeprom(opr2,opr1); 
....................  
....................           #elif defined(__PCH__) 
....................              FLASHSetWordAddress(opr2); 
3FFE:  MOVFF  2B7,2E7
4002:  MOVFF  2B6,2E6
4006:  CALL   218C
....................              FLASHWrite(opr1);              
400A:  MOVFF  2B5,2E1
400E:  MOVFF  2B4,2E0
4012:  CALL   2CF0
....................  
....................           #endif            
....................          
....................           // write_ext_eeprom(opr2,opr1); 
....................        break; 
4016:  BRA    4376
....................  
....................       case  LOW_BYTE:  // returns low byte 
....................            stkPush(stkPop() & 0xff); 
4018:  CALL   3434
401C:  MOVFF  02,2E1
4020:  MOVFF  01,2E0
4024:  MOVLB  2
4026:  CLRF   xE1
4028:  MOVFF  2E1,2E3
402C:  MOVFF  01,2E2
4030:  MOVLB  0
4032:  CALL   34F4
....................        break; 
4036:  BRA    4376
....................       case  HIGH_BYTE:  // returns high byte 
....................            stkPush(stkPop() >> 8); 
4038:  CALL   3434
403C:  MOVFF  02,2E1
4040:  MOVFF  02,2E0
4044:  MOVLB  2
4046:  CLRF   xE1
4048:  MOVFF  2E1,2E3
404C:  MOVFF  02,2E2
4050:  MOVLB  0
4052:  CALL   34F4
....................        break; 
4056:  BRA    4376
....................  
....................  
....................    /////////////////////////////////////////////////// 
....................    //  The following code are unique to the GoGo board 
....................  
....................       /// read sensor 
....................       case  SENSOR1: 
....................       case  SENSOR2: 
....................       case  SENSOR3: 
....................       case  SENSOR4: 
....................       case  SENSOR5: 
....................       case  SENSOR6: 
....................       case  SENSOR7: 
....................       case  SENSOR8: 
....................  
....................        // we need the following IF because the opcode for sensor1&2 are separate from the rest. 
....................        // If this wasn't the case we could have just done .. i = opcode - SENSOR1; 
....................        if (opcode < SENSOR3) { i = opcode - SENSOR1; } 
4058:  MOVLB  2
405A:  MOVF   xB2,W
405C:  SUBLW  48
405E:  BNC   4068
4060:  MOVLW  37
4062:  SUBWF  xB2,W
4064:  MOVWF  xB3
....................        else { i = opcode - SENSOR3 + 2; } 
4066:  BRA    4070
4068:  MOVLW  49
406A:  SUBWF  xB2,W
406C:  ADDLW  02
406E:  MOVWF  xB3
....................  
....................          stkPush(readSensor( gblSensorPortMap[i] ));  // map sensor number to the actual analog port on the processor 
4070:  CLRF   03
4072:  MOVF   xB3,W
4074:  ADDLW  F1
4076:  MOVWF  FE9
4078:  MOVLW  01
407A:  ADDWFC 03,W
407C:  MOVWF  FEA
407E:  MOVFF  FEF,2E0
4082:  MOVFF  2E0,2E1
4086:  MOVLB  0
4088:  CALL   28A2
408C:  MOVFF  02,2E1
4090:  MOVFF  01,2E0
4094:  MOVFF  02,2E3
4098:  MOVFF  01,2E2
409C:  CALL   34F4
....................        break; 
40A0:  BRA    4376
....................  
....................       // read sensor and treat it as a on-off switch (0 or 1) 
....................       case  SWITCH1: 
....................       case  SWITCH2: 
....................       case  SWITCH3: 
....................       case  SWITCH4: 
....................       case  SWITCH5: 
....................       case  SWITCH6: 
....................       case  SWITCH7: 
....................       case  SWITCH8: 
....................  
....................        if (opcode < SWITCH3) { i = opcode - SWITCH1; } 
40A2:  MOVLB  2
40A4:  MOVF   xB2,W
40A6:  SUBLW  4E
40A8:  BNC   40B2
40AA:  MOVLW  39
40AC:  SUBWF  xB2,W
40AE:  MOVWF  xB3
....................        else { i = opcode - SWITCH3 + 2; } 
40B0:  BRA    40BA
40B2:  MOVLW  4F
40B4:  SUBWF  xB2,W
40B6:  ADDLW  02
40B8:  MOVWF  xB3
....................  
....................          stkPush(!(readSensor(gblSensorPortMap[i])>>9)); 
40BA:  CLRF   03
40BC:  MOVF   xB3,W
40BE:  ADDLW  F1
40C0:  MOVWF  FE9
40C2:  MOVLW  01
40C4:  ADDWFC 03,W
40C6:  MOVWF  FEA
40C8:  MOVFF  FEF,2E0
40CC:  MOVFF  2E0,2E1
40D0:  MOVLB  0
40D2:  CALL   28A2
40D6:  MOVFF  02,2E1
40DA:  BCF    FD8.0
40DC:  CLRF   03
40DE:  MOVLB  2
40E0:  RRCF   02,W
40E2:  MOVWF  02
40E4:  IORWF  03,W
40E6:  MOVLW  00
40E8:  BTFSC  FD8.2
40EA:  MOVLW  01
40EC:  MOVWF  xE0
40EE:  CLRF   xE3
40F0:  MOVWF  xE2
40F2:  MOVLB  0
40F4:  CALL   34F4
....................        break; 
40F8:  BRA    4376
....................  
....................  
....................      ///////////////////////////////////////////////////////////// 
....................      //  user LED control 
....................      case ULED_ON: 
....................          USER_LED_ON; 
40FA:  BSF    F8B.0
....................          break; 
40FC:  BRA    4376
....................      case ULED_OFF: 
....................          USER_LED_OFF; 
40FE:  BCF    F8B.0
....................          break; 
4100:  BRA    4376
....................  
....................  
....................      ///////////////////////////////////////////////////////////// 
....................      //  Servo controls 
....................  
....................      case SERVO_SET_H: 
....................      case SERVO_LT: 
....................      case SERVO_RT: 
....................  
....................  
....................          // Caution: SetMotorMode() must be called AFTER the 
....................          // MotorControl() commands 
....................  
....................          MotorControl(MTR_ON); 
4102:  MOVLB  2
4104:  CLRF   xE0
4106:  MOVLB  0
4108:  CALL   2B1C
....................          MotorControl(MTR_THISWAY); 
410C:  MOVLW  03
410E:  MOVLB  2
4110:  MOVWF  xE0
4112:  MOVLB  0
4114:  CALL   2B1C
....................          SetMotorMode(MOTOR_SERVO); 
4118:  MOVLW  01
411A:  MOVLB  2
411C:  MOVWF  xE2
411E:  MOVLB  0
4120:  CALL   2916
....................  
....................          i = stkPop(); 
4124:  CALL   3434
4128:  MOVFF  01,2B3
....................  
....................          if (opcode == SERVO_SET_H) { 
412C:  MOVLB  2
412E:  MOVF   xB2,W
4130:  SUBLW  57
4132:  BNZ   4142
....................             SetMotorPower(i); 
4134:  MOVFF  2B3,2E2
4138:  MOVLB  0
413A:  CALL   2BC2
....................          } else if (opcode == SERVO_LT) 
413E:  BRA    416E
4140:  MOVLB  2
4142:  MOVF   xB2,W
4144:  SUBLW  58
4146:  BNZ   4156
....................             ChangeMotorPower(i); 
4148:  MOVFF  2B3,2E1
414C:  MOVLB  0
414E:  CALL   36A2
....................          else 
4152:  BRA    416E
4154:  MOVLB  2
....................             ChangeMotorPower(-1*i); 
4156:  SETF   xE0
4158:  MOVFF  2B3,2E1
415C:  MOVLB  0
415E:  GOTO   36F4
4162:  MOVFF  01,2E0
4166:  MOVFF  01,2E1
416A:  CALL   36A2
....................  
....................          break; 
416E:  BRA    4376
....................  
....................       case TALK_TO_MOTOR: 
....................          opr1 = stkPop(); // this is the motor bits 
4170:  CALL   3434
4174:  MOVFF  02,2B5
4178:  MOVFF  01,2B4
....................          TalkToMotor (opr1); 
417C:  MOVFF  2B4,2E0
4180:  CALL   2C9A
....................          break; 
4184:  BRA    4376
....................  
....................  
....................       /////////////////////////////////////////////////////////// 
....................       // 
....................       //  I2C  Commands 
....................       // 
....................  
....................       case CL_I2C_START: 
....................          gblI2CisBusy = 1;  // reserve the i2c bus 
4186:  MOVLB  2
4188:  BSF    x0A.7
....................          i2c_start(); 
418A:  BSF    FC5.0
418C:  BTFSC  FC5.0
418E:  BRA    418C
....................          break; 
4190:  MOVLB  0
4192:  BRA    4376
....................  
....................       case CL_I2C_STOP: 
....................          i2c_stop(); 
4194:  BSF    FC5.2
4196:  BTFSC  FC5.2
4198:  BRA    4196
....................          gblI2CisBusy = 0;  // releases the i2c bus 
419A:  MOVLB  2
419C:  BCF    x0A.7
....................          break; 
419E:  MOVLB  0
41A0:  BRA    4376
....................  
....................       case CL_I2C_WRITE: 
....................          i2c_write(stkPop()); 
41A2:  CALL   3434
41A6:  MOVFF  02,2E1
41AA:  MOVFF  01,2E0
41AE:  MOVFF  01,2EC
41B2:  CALL   2CB8
....................          break; 
41B6:  BRA    4376
....................  
....................       case CL_I2C_READ: 
....................          stkPush(i2c_read(stkPop())); 
41B8:  CALL   3434
41BC:  MOVFF  02,2E1
41C0:  MOVFF  01,2E0
41C4:  MOVFF  01,00
41C8:  CALL   2CD4
41CC:  MOVFF  01,2E0
41D0:  MOVLB  2
41D2:  CLRF   xE3
41D4:  MOVFF  01,2E2
41D8:  MOVLB  0
41DA:  CALL   34F4
....................          break; 
41DE:  BRA    4376
....................  
....................       /////////////////////////////////////////////////////////// 
....................       // Initialize the RTC clock as follows: 
....................       // - enable the clock. This needs to be cone every time the  
....................       //   RTC module looses power 
....................       // - set time to 24 hrs mode (as opposed to the AM/PM mode) 
....................       // - enable the square wave output on the RTC chip at 1Hz 
....................        
....................       case RTC_INIT: 
....................          rtcInit();          
41E0:  CALL   2F22
....................          break; 
41E4:  BRA    4376
....................        
....................       // Get one byte from the RTC clock 
....................        
....................       case RTC_GET_ITEM: 
....................          stkPush(rtcGetItem(stkPop())); 
41E6:  CALL   3434
41EA:  MOVFF  02,2E1
41EE:  MOVFF  01,2E0
41F2:  MOVFF  01,2E2
41F6:  CALL   2EC0
41FA:  MOVFF  01,2E0
41FE:  MOVLB  2
4200:  CLRF   xE3
4202:  MOVFF  01,2E2
4206:  MOVLB  0
4208:  CALL   34F4
....................       
....................          break; 
420C:  BRA    4376
....................           
....................      //////////////////////////////////////////////////////////// 
....................      // Display Module show command 
....................      // Works with both the 7-Segment and 16x2 LCD modules 
....................       
....................       case DISPLAY_SHOW: 
....................          opr1 = stkPop(); // this tells us what to do 
420E:  CALL   3434
4212:  MOVFF  02,2B5
4216:  MOVFF  01,2B4
....................          if (opr1 == DISPLAY_CMD_SEND_VALUE) { // send a 16-bit value 
421A:  MOVLB  2
421C:  MOVF   xB4,W
421E:  SUBLW  02
4220:  BNZ   4258
4222:  MOVF   xB5,F
4224:  BNZ   4258
....................             displayValue(stkPop()); 
4226:  MOVLB  0
4228:  CALL   3434
422C:  MOVFF  02,2E1
4230:  MOVFF  01,2E0
4234:  MOVFF  02,2E3
4238:  MOVFF  01,2E2
423C:  GOTO   39D4
....................             delay_us(300);   // must delay to allow the display to process the input value 
4240:  MOVLW  02
4242:  MOVLB  2
4244:  MOVWF  xE0
4246:  MOVLW  96
4248:  MOVWF  xE4
424A:  MOVLB  0
424C:  CALL   2854
4250:  MOVLB  2
4252:  DECFSZ xE0,F
4254:  BRA    4246
....................                              // before sending any further i2c commands. This display module 
....................                              // has to convert this number into a string and copy it to the 
....................                              // display buffer. This is a time consuming process. Without this 
....................                              // delay, it is possible to cause an overrun error. 
....................                               
....................          } else if (opr1 == DISPLAY_CMD_SEND_TEXT) { // send a 4-letter text (7-segment) 
4256:  BRA    4310
4258:  MOVF   xB4,W
425A:  SUBLW  03
425C:  BNZ   42AA
425E:  MOVF   xB5,F
4260:  BNZ   42AA
....................             displayText(stkPop(),stkPop(),stkPop(),stkPop());          
4262:  MOVLB  0
4264:  CALL   3434
4268:  MOVFF  02,2E1
426C:  MOVFF  01,2E0
4270:  CALL   3434
4274:  MOVFF  02,2E3
4278:  MOVFF  01,2E2
427C:  CALL   3434
4280:  MOVFF  02,2E5
4284:  MOVFF  01,2E4
4288:  CALL   3434
428C:  MOVFF  02,2E7
4290:  MOVFF  01,2E6
4294:  MOVFF  2E0,2E8
4298:  MOVFF  2E2,2E9
429C:  MOVFF  2E4,2EA
42A0:  MOVFF  01,2EB
42A4:  BRA    3C2A
....................          } else if (opr1 == DISPLAY_CMD_SEND_LONG_TEXT) { // send a long text (LCD display) 
42A6:  BRA    4310
42A8:  MOVLB  2
42AA:  MOVF   xB4,W
42AC:  SUBLW  05
42AE:  BNZ   4310
42B0:  MOVF   xB5,F
42B2:  BNZ   4310
....................             strLen = stkPop();   // get the text length 
42B4:  MOVLB  0
42B6:  CALL   3434
42BA:  MOVFF  01,2BE
....................              
....................             for (i=0;i<strLen;i++) { 
42BE:  MOVLB  2
42C0:  CLRF   xB3
42C2:  MOVF   xBE,W
42C4:  SUBWF  xB3,W
42C6:  BC    42F4
....................                displayModuleBuffer[i] = stkPop(); 
42C8:  CLRF   03
42CA:  MOVF   xB3,W
42CC:  ADDLW  BF
42CE:  MOVWF  01
42D0:  MOVLW  02
42D2:  ADDWFC 03,F
42D4:  MOVFF  01,2E0
42D8:  MOVFF  03,2E1
42DC:  MOVLB  0
42DE:  CALL   3434
42E2:  MOVFF  2E1,FEA
42E6:  MOVFF  2E0,FE9
42EA:  MOVFF  01,FEF
....................             } 
42EE:  MOVLB  2
42F0:  INCF   xB3,F
42F2:  BRA    42C2
....................             displayModuleBuffer[i] = 0;  // null terminating character 
42F4:  CLRF   03
42F6:  MOVF   xB3,W
42F8:  ADDLW  BF
42FA:  MOVWF  FE9
42FC:  MOVLW  02
42FE:  ADDWFC 03,W
4300:  MOVWF  FEA
4302:  CLRF   FEF
....................             displayLongText(displayModuleBuffer); // send the string to the display 
4304:  MOVLW  02
4306:  MOVWF  xE1
4308:  MOVLW  BF
430A:  MOVWF  xE0
430C:  MOVLB  0
430E:  BRA    3C90
....................          } 
....................           
....................          break; 
4310:  MOVLB  0
4312:  BRA    4376
....................   
....................       case DISPLAY_CLS: 
....................          clearDisplay(); 
4314:  BRA    3D00
....................          break; 
4316:  BRA    4376
....................   
....................       case DISPLAY_GETPOS: 
....................          stkPush(getDisplayPos()); 
4318:  BRA    3D24
431A:  MOVFF  01,2E0
431E:  MOVLB  2
4320:  CLRF   xE3
4322:  MOVFF  01,2E2
4326:  MOVLB  0
4328:  CALL   34F4
....................          break; 
432C:  BRA    4376
....................  
....................       case DISPLAY_SETPOS: 
....................          setDisplayPos(stkPop()); 
432E:  CALL   3434
4332:  MOVFF  02,2E1
4336:  MOVFF  01,2E0
433A:  MOVFF  01,2E2
433E:  BRA    3D58
....................          break; 
4340:  BRA    4376
....................  
....................       case TALK_TO_7SEG_1: 
....................          gblAutoDetectDisplays=0; 
4342:  MOVLB  2
4344:  BCF    x0A.6
....................          gblDisplayAddress=DISPLAY_7SEG_ADDR_1; 
4346:  MOVLW  B0
4348:  MOVWF  x46
....................          break; 
434A:  MOVLB  0
434C:  BRA    4376
....................  
....................       case TALK_TO_7SEG_2: 
....................          gblAutoDetectDisplays=0; 
434E:  MOVLB  2
4350:  BCF    x0A.6
....................          gblDisplayAddress=DISPLAY_7SEG_ADDR_2; 
4352:  MOVLW  B2
4354:  MOVWF  x46
....................        
....................          break; 
4356:  MOVLB  0
4358:  BRA    4376
....................  
....................       case TALK_TO_LCD_1: 
....................          gblAutoDetectDisplays=0; 
435A:  MOVLB  2
435C:  BCF    x0A.6
....................          gblDisplayAddress=DISPLAY_LCD_ADDR_1; 
435E:  MOVLW  B4
4360:  MOVWF  x46
....................        
....................          break; 
4362:  MOVLB  0
4364:  BRA    4376
....................  
....................       case TALK_TO_LCD_2: 
....................          gblAutoDetectDisplays=0; 
4366:  MOVLB  2
4368:  BCF    x0A.6
....................          gblDisplayAddress=DISPLAY_LCD_ADDR_2; 
436A:  MOVLW  B6
436C:  MOVWF  x46
....................        
....................          break; 
436E:  MOVLB  0
4370:  BRA    4376
....................  
....................   
....................   
....................      default: 
....................       Halt(); 
4372:  CALL   3674
....................  
....................  
.................... }; 
....................  
.................... } 
4376:  GOTO   4E52 (RETURN)
....................  
.................... #include <stack.c>         // Push/Pop functions for Op-code execution 
.................... // 
.................... // stack.c - Provides stack objects for the Logo Virtual Machine 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
....................  
....................  
....................  
....................  
.................... ///////////////////////////////////////////// 
.................... //  Main Data Stack 
....................  
....................  
.................... void stkPush(unsigned int16 stackItem) 
.................... { 
....................    if (gblStkPtr<STACK_SIZE) { 
34F4:  MOVF   x82,W
34F6:  SUBLW  3F
34F8:  BNC   351E
.................... //      printf(ser_char, "data stack = %d\r\n", gblStkPtr); 
....................       gblStack[gblStkPtr++] = stackItem; 
34FA:  MOVF   x82,W
34FC:  INCF   x82,F
34FE:  MOVWF  00
3500:  BCF    FD8.0
3502:  RLCF   00,F
3504:  MOVF   00,W
3506:  CLRF   03
3508:  ADDLW  84
350A:  MOVWF  FE9
350C:  MOVLW  00
350E:  ADDWFC 03,W
3510:  MOVWF  FEA
3512:  MOVFF  2E3,FEC
3516:  MOVF   FED,F
3518:  MOVFF  2E2,FEF
....................    } else { 
351C:  BRA    354C
.................... //      printf(ser_char,"Error: Stack overflow\r\n"); 
....................  
....................    ///////////////////// 
....................    //  Halt the board if stak overflows 
....................    while (1) { 
....................       output_low(RUN_LED); delay_ms(100); 
351E:  BCF    F8B.1
3520:  MOVLW  64
3522:  MOVLB  9
3524:  MOVWF  x2B
3526:  MOVLB  0
3528:  CALL   18F4
....................       output_high(RUN_LED); delay_ms(1000); 
352C:  BSF    F8B.1
352E:  MOVLW  04
3530:  MOVLB  2
3532:  MOVWF  xE4
3534:  MOVLW  FA
3536:  MOVLB  9
3538:  MOVWF  x2B
353A:  MOVLB  0
353C:  CALL   18F4
3540:  MOVLB  2
3542:  DECFSZ xE4,F
3544:  BRA    3534
....................    } 
3546:  MOVLB  0
3548:  BRA    351E
....................  
....................       gblErrFlag |= 0b00000001;  // set err bit 1 "stack overflow" 
354A:  BSF    x83.0
....................    } 
.................... } 
354C:  RETURN 0
....................  
.................... unsigned int16 stkPop(void) 
.................... { 
....................    if (gblStkPtr>0) { 
3434:  MOVF   x82,F
3436:  BZ    345A
....................       return(gblStack[--gblStkPtr]); 
3438:  DECF   x82,F
343A:  BCF    FD8.0
343C:  RLCF   x82,W
343E:  CLRF   03
3440:  ADDLW  84
3442:  MOVWF  FE9
3444:  MOVLW  00
3446:  ADDWFC 03,W
3448:  MOVWF  FEA
344A:  MOVFF  FEF,01
344E:  INCF   FE9,F
3450:  MOVF   FEF,W
3452:  DECF   FE9,F
3454:  MOVWF  02
3456:  BRA    3486
....................    } else { 
3458:  BRA    3486
....................       gblErrFlag |= 0b00000010;  // set error bit 2 "stack empty" 
345A:  BSF    x83.1
....................       ///////////////////// 
....................       //  Halt the board if stak overflows 
....................       while (1) { 
....................          output_low(RUN_LED); delay_ms(1000); 
345C:  BCF    F8B.1
345E:  MOVLW  04
3460:  MOVLB  2
3462:  MOVWF  xE6
3464:  MOVLW  FA
3466:  MOVLB  9
3468:  MOVWF  x2B
346A:  MOVLB  0
346C:  CALL   18F4
3470:  MOVLB  2
3472:  DECFSZ xE6,F
3474:  BRA    3464
....................          output_high(RUN_LED); delay_ms(100); 
3476:  BSF    F8B.1
3478:  MOVLW  64
347A:  MOVLB  9
347C:  MOVWF  x2B
347E:  MOVLB  0
3480:  CALL   18F4
....................       } 
3484:  BRA    345C
....................     
....................        
....................    } 
.................... } 
3486:  RETURN 0
....................  
....................  
.................... ///////////////////////////////////////////// 
.................... //  Procedure Input Stack 
....................  
....................  
.................... void inputPush(unsigned int16 stackItem) 
.................... { 
....................    if (gblInputStkPtr<INPUT_STACK_SIZE) { 
3488:  MOVLB  1
348A:  MOVF   x04,W
348C:  SUBLW  3F
348E:  BNC   34B4
....................       //printf(ser_char, "input stack push = %lu\r\n", stackItem); 
....................       gblInputStack[gblInputStkPtr++] = stackItem; 
3490:  MOVF   x04,W
3492:  INCF   x04,F
3494:  MOVWF  00
3496:  BCF    FD8.0
3498:  RLCF   00,F
349A:  MOVF   00,W
349C:  CLRF   03
349E:  ADDLW  05
34A0:  MOVWF  FE9
34A2:  MOVLW  01
34A4:  ADDWFC 03,W
34A6:  MOVWF  FEA
34A8:  MOVFF  2B5,FEC
34AC:  MOVF   FED,F
34AE:  MOVFF  2B4,FEF
....................    } else { 
34B2:  BRA    34F0
....................      //printf(ser_char,"Error: Stack overflow\r\n"); 
....................  
....................    ///////////////////// 
....................    //  Halt the board if stak overflows 
....................    while (1) { 
....................       output_low(RUN_LED); delay_ms(500); 
34B4:  BCF    F8B.1
34B6:  MOVLW  02
34B8:  MOVLB  2
34BA:  MOVWF  xB6
34BC:  MOVLW  FA
34BE:  MOVLB  9
34C0:  MOVWF  x2B
34C2:  MOVLB  0
34C4:  CALL   18F4
34C8:  MOVLB  2
34CA:  DECFSZ xB6,F
34CC:  BRA    34BC
....................       output_high(RUN_LED); delay_ms(500); 
34CE:  BSF    F8B.1
34D0:  MOVLW  02
34D2:  MOVWF  xB6
34D4:  MOVLW  FA
34D6:  MOVLB  9
34D8:  MOVWF  x2B
34DA:  MOVLB  0
34DC:  CALL   18F4
34E0:  MOVLB  2
34E2:  DECFSZ xB6,F
34E4:  BRA    34D4
....................    } 
34E6:  MOVLB  1
34E8:  BRA    34B4
....................  
....................  
....................  
....................       gblErrFlag |= 0b00000100;  // set err bit 3 "stack overflow" 
34EA:  MOVLB  0
34EC:  BSF    x83.2
34EE:  MOVLB  1
....................    } 
.................... } 
34F0:  MOVLB  0
34F2:  RETURN 0
....................  
.................... unsigned int16 inputPop(void) 
.................... { 
....................    if (gblInputStkPtr>0) { 
33CC:  MOVLB  1
33CE:  MOVF   x04,F
33D0:  BZ    33F4
....................       //printf(ser_char, "input stack pop = %lu\r\n", gblInputStack[gblInputStkPtr-1]); 
....................  
....................       return(gblInputStack[--gblInputStkPtr]); 
33D2:  DECF   x04,F
33D4:  BCF    FD8.0
33D6:  RLCF   x04,W
33D8:  CLRF   03
33DA:  ADDLW  05
33DC:  MOVWF  FE9
33DE:  MOVLW  01
33E0:  ADDWFC 03,W
33E2:  MOVWF  FEA
33E4:  MOVFF  FEF,01
33E8:  INCF   FE9,F
33EA:  MOVF   FEF,W
33EC:  DECF   FE9,F
33EE:  MOVWF  02
33F0:  BRA    3430
....................    } else { 
33F2:  BRA    3430
....................       gblErrFlag |= 0b00001000;  // set error bit 4 "stack empty" 
33F4:  MOVLB  0
33F6:  BSF    x83.3
....................       //printf(ser_char,"Input stack empty!!!\r\n"); 
....................       ///////////////////// 
....................       //  Halt the board if stak overflows 
....................       while (1) { 
....................          output_low(RUN_LED); delay_ms(500); 
33F8:  BCF    F8B.1
33FA:  MOVLW  02
33FC:  MOVLB  2
33FE:  MOVWF  xB2
3400:  MOVLW  FA
3402:  MOVLB  9
3404:  MOVWF  x2B
3406:  MOVLB  0
3408:  CALL   18F4
340C:  MOVLB  2
340E:  DECFSZ xB2,F
3410:  BRA    3400
....................          output_high(RUN_LED); delay_ms(500); 
3412:  BSF    F8B.1
3414:  MOVLW  02
3416:  MOVWF  xB2
3418:  MOVLW  FA
341A:  MOVLB  9
341C:  MOVWF  x2B
341E:  MOVLB  0
3420:  CALL   18F4
3424:  MOVLB  2
3426:  DECFSZ xB2,F
3428:  BRA    3418
....................       } 
342A:  MOVLB  0
342C:  BRA    33F8
342E:  MOVLB  1
....................  
....................    } 
.................... } 
3430:  MOVLB  0
3432:  RETURN 0
....................  
....................  
....................  
.................... void clearStack() { 
....................    gblStkPtr=gblInputStkPtr=0; 
1248:  MOVLB  1
124A:  CLRF   x04
124C:  MOVFF  104,82
.................... } 
1250:  MOVLB  0
1252:  RETURN 0
....................  
....................  
....................  
.................... /* 
.................... void main() 
.................... { 
....................    unsigned char i,inByte; 
....................  
....................     byte InByte, buff_status; 
....................  
....................  
....................    set_tris_c(PIC_TRIS_C); 
....................    set_tris_d(PIC_TRIS_D); 
....................  
....................    for (i=0;i<2;i++) { 
....................       output_high(PIN_D0); 
....................       delay_ms(200); 
....................       output_low(PIN_D0); 
....................       delay_ms(200); 
....................    } 
....................  
....................    // init the serial port 
....................    ser_init(); 
....................    enable_interrupts(GLOBAL); 
....................    enable_interrupts(INT_RDA); 
....................  
....................    gblStkPtr = 0; 
....................  
....................  
....................    stkPush(0x0000); 
....................    stkPush(0xffff); 
....................    stkPush(0x00ff); 
....................    stkPush(0xff00); 
....................    stkPush(0x0f0f); 
....................    stkPush(0xf0f0); 
....................    stkPush(0x1111); 
....................    stkPush(0x2222); 
....................    stkPush(0x3333); 
....................    stkPush(0x4444); 
....................    stkPush(0x5555); 
....................    stkPush(0x6666); 
....................    stkPush(0x7777); 
....................    stkPush(0x8888); 
....................    stkPush(0x9999); 
....................    stkPush(0xaaaa); 
....................    stkPush(0xbbbb); 
....................    stkPush(0xcccc); 
....................    stkPush(0xdddd); 
....................    stkPush(0xeeee); 
....................  
....................  
....................    printf(ser_char,"poping stack data: \r\n"); 
....................    for (i=0;i<20;i++) { 
....................       printf(ser_char, "%LX\r\n", stkPop()); 
....................    } 
....................    printf(ser_char, "End of stack.\r\n"); 
....................  
.................... } 
....................  
....................  
.................... */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void sendBytes(unsigned int16 memPtr, unsigned int16 count) 
.................... { 
....................    while (count-- > 0) { 
21B0:  MOVLB  2
21B2:  MOVFF  2AD,03
21B6:  MOVF   xAC,W
21B8:  BTFSC  FD8.2
21BA:  DECF   xAD,F
21BC:  DECF   xAC,F
21BE:  MOVWF  xAE
21C0:  MOVFF  03,2AF
21C4:  MOVF   xAE,F
21C6:  BNZ   21CC
21C8:  MOVF   xAF,F
21CA:  BZ    221C
....................  
....................    #if defined(__PCM__) 
....................       printf(active_comm_putc, "%c",read_program_eeprom(FLASH_USER_PROGRAM_BASE_ADDRESS + memPtr++)); 
....................    #elif defined(__PCH__) 
....................       printf(active_comm_putc, "%c",read_program_eeprom( FLASH_USER_PROGRAM_BASE_ADDRESS + (memPtr++<<1))); 
21CC:  MOVFF  2AB,03
21D0:  MOVF   xAA,W
21D2:  INCF   xAA,F
21D4:  BTFSC  FD8.2
21D6:  INCF   xAB,F
21D8:  MOVWF  xAE
21DA:  MOVFF  03,2AF
21DE:  BCF    FD8.0
21E0:  RLCF   xAE,W
21E2:  MOVWF  02
21E4:  RLCF   03,W
21E6:  MOVWF  03
21E8:  MOVLW  E8
21EA:  ADDWF  03,W
21EC:  MOVWF  xAF
21EE:  MOVFF  FF2,2B0
21F2:  BCF    FF2.7
21F4:  CLRF   FF8
21F6:  MOVWF  FF7
21F8:  MOVFF  02,FF6
21FC:  TBLRD*+
21FE:  MOVF   FF5,W
2200:  TBLRD*
2202:  MOVFF  FF5,03
2206:  CLRF   FF8
2208:  BTFSC  xB0.7
220A:  BSF    FF2.7
220C:  MOVWF  xAE
220E:  MOVFF  03,2AF
2212:  MOVWF  xE2
2214:  MOVLB  0
2216:  RCALL  1D06
....................    #endif    
....................  
....................    } 
2218:  BRA    21B0
221A:  MOVLB  2
.................... } 
221C:  MOVLB  0
221E:  GOTO   2798 (RETURN)
....................  
....................  
.................... unsigned char fetchNextOpcode() 
.................... { 
....................     
....................    unsigned int16 opcode; 
....................     
....................    // if an ONFOR command was launched we must turn motor off before 
....................    // continuing. When gblONFORNeedsToFinish is falged, we simulate 
....................    // a motor off command. 
....................    if (gblONFORNeedsToFinish) { 
336E:  BTFSS  x7F.1
3370:  BRA    337C
....................       gblONFORNeedsToFinish = 0; 
3372:  BCF    x7F.1
....................       return(M_OFF); 
3374:  MOVLW  33
3376:  MOVWF  01
3378:  BRA    33CA
....................    } else { 
337A:  BRA    33CA
....................     
....................    #if defined(__PCM__) 
....................       opcode = read_program_eeprom(FLASH_USER_PROGRAM_BASE_ADDRESS + gblMemPtr++); 
....................    #elif defined(__PCH__) 
....................    
....................       opcode = read_program_eeprom(FLASH_USER_PROGRAM_BASE_ADDRESS + ((gblMemPtr++)<<1)); 
337C:  MOVLB  1
337E:  MOVFF  1AC,03
3382:  MOVF   xAB,W
3384:  INCF   xAB,F
3386:  BTFSC  FD8.2
3388:  INCF   xAC,F
338A:  MOVLB  2
338C:  MOVWF  xB6
338E:  MOVFF  03,2B7
3392:  BCF    FD8.0
3394:  RLCF   xB6,W
3396:  MOVWF  02
3398:  RLCF   03,W
339A:  MOVWF  03
339C:  MOVLW  E8
339E:  ADDWF  03,W
33A0:  MOVFF  FF2,2B8
33A4:  BCF    FF2.7
33A6:  CLRF   FF8
33A8:  MOVWF  FF7
33AA:  MOVFF  02,FF6
33AE:  TBLRD*+
33B0:  MOVF   FF5,W
33B2:  TBLRD*
33B4:  MOVFF  FF5,03
33B8:  CLRF   FF8
33BA:  BTFSC  xB8.7
33BC:  BSF    FF2.7
33BE:  MOVWF  xB4
33C0:  MOVFF  03,2B5
.................... ///      printf(usb_cdc_putc,"op addr = %Lx, op = %Lx\r\n", FLASH_USER_PROGRAM_BASE_ADDRESS + ((gblMemPtr-1)<<1), opcode); 
....................    #endif    
....................     
....................    return opcode; 
33C4:  MOVFF  2B4,01
33C8:  MOVLB  0
....................  
....................  
....................    } 
.................... } 
33CA:  RETURN 0
....................  
.................... #include <i2cDisplay.c> 
.................... // 
.................... // evalopcode.c - Display module plug-in routines 
.................... // 
.................... // Copyright (C) 2001-2007 Massachusetts Institute of Technology 
.................... // Contact   Arnan (Roger) Sipiatkiat [arnans@gmail.com] 
.................... // 
.................... // This program is free software; you can redistribute it and/or 
.................... // modify it under the terms of the GNU General Public License 
.................... // as published by the Free Software Foundation version 2. 
.................... // 
.................... // This program is distributed in the hope that it will be useful, 
.................... // but WITHOUT ANY WARRANTY; without even the implied warranty of 
.................... // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
.................... // GNU General Public License for more details. 
.................... // 
.................... // You should have received a copy of the GNU General Public License 
.................... // along with this program; if not, write to the Free Software 
.................... // Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. 
.................... // 
....................  
....................  
....................  
.................... int displayPing() { 
3086:  MOVLB  2
3088:  CLRF   xA7
308A:  CLRF   xA8
308C:  CLRF   xAB
....................    int inbyte=0; 
....................    int found=0; 
....................    int i; 
....................    int currentAddress; 
....................    int displayAddress=0; 
....................  
....................     
....................    // probe for any connected displays 
....................    for (i=0;i<4;i++) { 
308E:  CLRF   xA9
3090:  MOVF   xA9,W
3092:  SUBLW  03
3094:  BNC   30F6
....................       // fetch a display address to probe 
....................       currentAddress = gblDisplayAddressList[i]; 
3096:  CLRF   03
3098:  MOVF   xA9,W
309A:  ADDLW  47
309C:  MOVWF  FE9
309E:  MOVLW  02
30A0:  ADDWFC 03,W
30A2:  MOVWF  FEA
30A4:  MOVFF  FEF,2AA
....................       ///disable_interrupts(GLOBAL); 
....................       i2c_start(); 
30A8:  BSF    FC5.0
30AA:  BTFSC  FC5.0
30AC:  BRA    30AA
....................       // We write to the Display address and check the return value 
....................       // if i2c_write returns 0 -> it means we got an ACK back 
....................       // so it means the display module is present. 
....................       found = i2c_write(currentAddress); 
30AE:  MOVFF  2AA,2EC
30B2:  MOVLB  0
30B4:  RCALL  2CB8
30B6:  MOVFF  01,2A8
....................       found = !found; 
30BA:  MOVLB  2
30BC:  MOVF   xA8,F
30BE:  BZ    30C4
30C0:  MOVLW  00
30C2:  BRA    30C6
30C4:  MOVLW  01
30C6:  MOVWF  xA8
....................    
....................       if (found) { 
30C8:  MOVF   xA8,F
30CA:  BZ    30E2
....................          displayAddress = currentAddress; 
30CC:  MOVFF  2AA,2AB
....................          i2c_write(DISPLAY_CMD_PING);  // tell the slave we are just pinging. 
30D0:  MOVLW  01
30D2:  MOVWF  xEC
30D4:  MOVLB  0
30D6:  RCALL  2CB8
....................          i2c_stop(); 
30D8:  BSF    FC5.2
30DA:  BTFSC  FC5.2
30DC:  BRA    30DA
....................          ///enable_interrupts(GLOBAL); 
....................          break; 
30DE:  MOVLB  2
30E0:  BRA    30F6
....................       } 
....................       i2c_stop(); 
30E2:  BSF    FC5.2
30E4:  BTFSC  FC5.2
30E6:  BRA    30E4
....................       ///enable_interrupts(GLOBAL); 
....................        
....................       delay_us(10); // delay to give time to other interrupts to 
30E8:  MOVLW  27
30EA:  MOVWF  00
30EC:  DECFSZ 00,F
30EE:  BRA    30EC
30F0:  BRA    30F2
....................                     // do their work. 
....................    } 
30F2:  INCF   xA9,F
30F4:  BRA    3090
....................  
....................  
....................    return(displayAddress); 
30F6:  MOVFF  2AB,01
....................     
.................... } 
30FA:  MOVLB  0
30FC:  GOTO   31B4 (RETURN)
....................  
.................... void displayValue(int16 val) { 
....................  
....................    int temp; 
....................  
....................    // show on external 7-segment  
....................    if (gblUseOnBoard7Segment == 0) { 
39D4:  BTFSC  x7F.2
39D6:  BRA    3A26
....................     
....................       i2c_start(); 
39D8:  BSF    FC5.0
39DA:  BTFSC  FC5.0
39DC:  BRA    39DA
....................     
....................       // We write to the Display address and check the return value 
....................       // if i2c_write returns 0 -> it means we got an ACK back 
....................       // so it means the display module is present. 
....................       if (i2c_write(gblDisplayAddress)) { 
39DE:  MOVFF  246,2EC
39E2:  CALL   2CB8
39E6:  MOVF   01,W
39E8:  BZ    39EC
....................          ///enable_interrupts(GLOBAL); 
....................          return; 
39EA:  BRA    3BFA
....................       }  
....................        
....................       i2c_write(DISPLAY_CMD_SEND_VALUE); 
39EC:  MOVLW  02
39EE:  MOVLB  2
39F0:  MOVWF  xEC
39F2:  MOVLB  0
39F4:  CALL   2CB8
....................       i2c_write((int)(val>>8));  // high byte 
39F8:  MOVLB  2
39FA:  MOVF   xE3,W
39FC:  CLRF   03
39FE:  MOVWF  xE5
3A00:  MOVWF  xEC
3A02:  MOVLB  0
3A04:  CALL   2CB8
....................       i2c_write((int)(val & 0xFF));  // low byte 
3A08:  MOVLB  2
3A0A:  MOVFF  2E2,00
3A0E:  CLRF   03
3A10:  MOVFF  2E2,2E5
3A14:  MOVFF  2E2,2EC
3A18:  MOVLB  0
3A1A:  CALL   2CB8
....................       i2c_stop(); 
3A1E:  BSF    FC5.2
3A20:  BTFSC  FC5.2
3A22:  BRA    3A20
....................    }  
....................     
....................    // show on built-in 7-segment display 
....................    else if (gblUseOnBoard7Segment == 1) { 
3A24:  BRA    3BFA
3A26:  BTFSS  x7F.2
3A28:  BRA    3BFA
....................  
....................         cls_internal7Seg(); // make the screen blank 
3A2A:  CALL   1254
....................  
....................          // first digit  
....................          temp = val - (val/10)*10; 
3A2E:  MOVFF  2E3,2E6
3A32:  MOVFF  2E2,2E5
3A36:  MOVLB  2
3A38:  CLRF   xE8
3A3A:  MOVLW  0A
3A3C:  MOVWF  xE7
3A3E:  MOVLB  0
3A40:  RCALL  35AC
3A42:  MOVFF  02,2E6
3A46:  MOVFF  01,2E5
3A4A:  CLRF   19
3A4C:  BTFSC  FF2.7
3A4E:  BSF    19.7
3A50:  BCF    FF2.7
3A52:  MOVFF  02,A5D
3A56:  MOVFF  01,A5C
3A5A:  MOVLB  A
3A5C:  CLRF   x5F
3A5E:  MOVLW  0A
3A60:  MOVWF  x5E
3A62:  MOVLB  0
3A64:  CALL   030A
3A68:  BTFSC  19.7
3A6A:  BSF    FF2.7
3A6C:  MOVF   01,W
3A6E:  MOVLB  2
3A70:  SUBWF  xE2,W
3A72:  MOVWF  xE4
....................          gblCharCodeToShow1 = Char2Segments(temp); 
3A74:  MOVFF  2E4,2F0
3A78:  MOVLB  0
3A7A:  RCALL  3744
3A7C:  MOVFF  01,1B6
....................  
....................          if (val<10) {return;} 
3A80:  MOVLB  2
3A82:  MOVF   xE3,F
3A84:  BNZ   3A92
3A86:  MOVF   xE2,W
3A88:  SUBLW  09
3A8A:  BNC   3A92
3A8C:  MOVLB  0
3A8E:  BRA    3BFA
3A90:  MOVLB  2
....................          // second digit 
....................          val /= 10; 
3A92:  MOVFF  2E3,2E6
3A96:  MOVFF  2E2,2E5
3A9A:  CLRF   xE8
3A9C:  MOVLW  0A
3A9E:  MOVWF  xE7
3AA0:  MOVLB  0
3AA2:  RCALL  35AC
3AA4:  MOVFF  02,2E3
3AA8:  MOVFF  01,2E2
....................          temp = val - (val/10)*10; 
3AAC:  MOVFF  2E3,2E6
3AB0:  MOVFF  2E2,2E5
3AB4:  MOVLB  2
3AB6:  CLRF   xE8
3AB8:  MOVLW  0A
3ABA:  MOVWF  xE7
3ABC:  MOVLB  0
3ABE:  RCALL  35AC
3AC0:  MOVFF  02,2E6
3AC4:  MOVFF  01,2E5
3AC8:  CLRF   19
3ACA:  BTFSC  FF2.7
3ACC:  BSF    19.7
3ACE:  BCF    FF2.7
3AD0:  MOVFF  02,A5D
3AD4:  MOVFF  01,A5C
3AD8:  MOVLB  A
3ADA:  CLRF   x5F
3ADC:  MOVLW  0A
3ADE:  MOVWF  x5E
3AE0:  MOVLB  0
3AE2:  CALL   030A
3AE6:  BTFSC  19.7
3AE8:  BSF    FF2.7
3AEA:  MOVF   01,W
3AEC:  MOVLB  2
3AEE:  SUBWF  xE2,W
3AF0:  MOVWF  xE4
....................          gblCharCodeToShow2 = Char2Segments(temp); 
3AF2:  MOVFF  2E4,2F0
3AF6:  MOVLB  0
3AF8:  RCALL  3744
3AFA:  MOVFF  01,1B7
....................        
....................          if (val<10) {return;} 
3AFE:  MOVLB  2
3B00:  MOVF   xE3,F
3B02:  BNZ   3B10
3B04:  MOVF   xE2,W
3B06:  SUBLW  09
3B08:  BNC   3B10
3B0A:  MOVLB  0
3B0C:  BRA    3BFA
3B0E:  MOVLB  2
....................          // third digit 
....................          val /= 10; 
3B10:  MOVFF  2E3,2E6
3B14:  MOVFF  2E2,2E5
3B18:  CLRF   xE8
3B1A:  MOVLW  0A
3B1C:  MOVWF  xE7
3B1E:  MOVLB  0
3B20:  RCALL  35AC
3B22:  MOVFF  02,2E3
3B26:  MOVFF  01,2E2
....................          temp = val - (val/10)*10; 
3B2A:  MOVFF  2E3,2E6
3B2E:  MOVFF  2E2,2E5
3B32:  MOVLB  2
3B34:  CLRF   xE8
3B36:  MOVLW  0A
3B38:  MOVWF  xE7
3B3A:  MOVLB  0
3B3C:  RCALL  35AC
3B3E:  MOVFF  02,2E6
3B42:  MOVFF  01,2E5
3B46:  CLRF   19
3B48:  BTFSC  FF2.7
3B4A:  BSF    19.7
3B4C:  BCF    FF2.7
3B4E:  MOVFF  02,A5D
3B52:  MOVFF  01,A5C
3B56:  MOVLB  A
3B58:  CLRF   x5F
3B5A:  MOVLW  0A
3B5C:  MOVWF  x5E
3B5E:  MOVLB  0
3B60:  CALL   030A
3B64:  BTFSC  19.7
3B66:  BSF    FF2.7
3B68:  MOVF   01,W
3B6A:  MOVLB  2
3B6C:  SUBWF  xE2,W
3B6E:  MOVWF  xE4
....................          gblCharCodeToShow3 = Char2Segments(temp); 
3B70:  MOVFF  2E4,2F0
3B74:  MOVLB  0
3B76:  RCALL  3744
3B78:  MOVFF  01,1B8
....................  
....................          if (val<10) {return;} 
3B7C:  MOVLB  2
3B7E:  MOVF   xE3,F
3B80:  BNZ   3B8E
3B82:  MOVF   xE2,W
3B84:  SUBLW  09
3B86:  BNC   3B8E
3B88:  MOVLB  0
3B8A:  BRA    3BFA
3B8C:  MOVLB  2
....................          // fourth digit 
....................          val /= 10; 
3B8E:  MOVFF  2E3,2E6
3B92:  MOVFF  2E2,2E5
3B96:  CLRF   xE8
3B98:  MOVLW  0A
3B9A:  MOVWF  xE7
3B9C:  MOVLB  0
3B9E:  RCALL  35AC
3BA0:  MOVFF  02,2E3
3BA4:  MOVFF  01,2E2
....................          temp = val - (val/10)*10; 
3BA8:  MOVFF  2E3,2E6
3BAC:  MOVFF  2E2,2E5
3BB0:  MOVLB  2
3BB2:  CLRF   xE8
3BB4:  MOVLW  0A
3BB6:  MOVWF  xE7
3BB8:  MOVLB  0
3BBA:  RCALL  35AC
3BBC:  MOVFF  02,2E6
3BC0:  MOVFF  01,2E5
3BC4:  CLRF   19
3BC6:  BTFSC  FF2.7
3BC8:  BSF    19.7
3BCA:  BCF    FF2.7
3BCC:  MOVFF  02,A5D
3BD0:  MOVFF  01,A5C
3BD4:  MOVLB  A
3BD6:  CLRF   x5F
3BD8:  MOVLW  0A
3BDA:  MOVWF  x5E
3BDC:  MOVLB  0
3BDE:  CALL   030A
3BE2:  BTFSC  19.7
3BE4:  BSF    FF2.7
3BE6:  MOVF   01,W
3BE8:  MOVLB  2
3BEA:  SUBWF  xE2,W
3BEC:  MOVWF  xE4
....................          gblCharCodeToShow4 = Char2Segments(temp); 
3BEE:  MOVFF  2E4,2F0
3BF2:  MOVLB  0
3BF4:  RCALL  3744
3BF6:  MOVFF  01,1B9
....................     
....................    } 
.................... } 
3BFA:  GOTO   4240 (RETURN)
....................  
....................  
.................... void displayText(char ch1, char ch2, char ch3, char ch4) { 
....................  
....................    // show on external 7-segment  
....................    if (gblUseOnBoard7Segment == 0) { 
3C2A:  BTFSC  x7F.2
3C2C:  BRA    3C76
....................     
....................       i2c_start(); 
3C2E:  BSF    FC5.0
3C30:  BTFSC  FC5.0
3C32:  BRA    3C30
....................     
....................       // We write to the Display address and check the return value 
....................       // if i2c_write returns 0 -> it means we got an ACK back 
....................       // so it means the display module is present. 
....................       if (i2c_write(gblDisplayAddress)) { 
3C34:  MOVFF  246,2EC
3C38:  CALL   2CB8
3C3C:  MOVF   01,W
3C3E:  BZ    3C42
....................          ///enable_interrupts(GLOBAL); 
....................          return; 
3C40:  BRA    3C8C
....................       }  
....................        
....................       i2c_write(DISPLAY_CMD_SEND_TEXT); 
3C42:  MOVLW  03
3C44:  MOVLB  2
3C46:  MOVWF  xEC
3C48:  MOVLB  0
3C4A:  CALL   2CB8
....................       i2c_write(ch4);   
3C4E:  MOVFF  2EB,2EC
3C52:  CALL   2CB8
....................       i2c_write(ch3);   
3C56:  MOVFF  2EA,2EC
3C5A:  CALL   2CB8
....................       i2c_write(ch2);   
3C5E:  MOVFF  2E9,2EC
3C62:  CALL   2CB8
....................       i2c_write(ch1);   
3C66:  MOVFF  2E8,2EC
3C6A:  CALL   2CB8
....................       i2c_stop(); 
3C6E:  BSF    FC5.2
3C70:  BTFSC  FC5.2
3C72:  BRA    3C70
....................     
....................    } 
....................    // show on built-in 7-segment display 
....................    else if (gblUseOnBoard7Segment == 1) { 
3C74:  BRA    3C8C
3C76:  BTFSS  x7F.2
3C78:  BRA    3C8C
....................       showOnBuiltIn7Segment(ch1,ch2,ch3,ch4); 
3C7A:  MOVFF  2E8,2EC
3C7E:  MOVFF  2E9,2ED
3C82:  MOVFF  2EA,2EE
3C86:  MOVFF  2EB,2EF
3C8A:  BRA    3BFE
....................    } 
.................... } 
3C8C:  GOTO   42A6 (RETURN)
....................  
.................... void displayLongText(char *text) { 
3C90:  MOVLB  2
3C92:  CLRF   xE2
....................  
....................    signed int i=0; 
....................  
....................    ///disable_interrupts(GLOBAL);  
....................  
....................    i2c_start(); 
3C94:  BSF    FC5.0
3C96:  BTFSC  FC5.0
3C98:  BRA    3C96
....................  
....................    // We write to the Display address and check the return value 
....................    // if i2c_write returns 0 -> it means we got an ACK back 
....................    // so it means the display module is present. 
....................    if (i2c_write(gblDisplayAddress)) { 
3C9A:  MOVFF  246,2EC
3C9E:  MOVLB  0
3CA0:  CALL   2CB8
3CA4:  MOVF   01,W
3CA6:  BZ    3CAA
....................       ///enable_interrupts(GLOBAL); 
....................       return; 
3CA8:  BRA    3CFC
....................    }  
....................     
....................    i2c_write(DISPLAY_CMD_SEND_LONG_TEXT); 
3CAA:  MOVLW  05
3CAC:  MOVLB  2
3CAE:  MOVWF  xEC
3CB0:  MOVLB  0
3CB2:  CALL   2CB8
....................     
....................    // write the display string (in reverse order) 
....................    for(i=0;text[i] != '\0';i++) 
3CB6:  MOVLB  2
3CB8:  CLRF   xE2
3CBA:  CLRF   03
3CBC:  MOVF   xE2,W
3CBE:  ADDWF  xE0,W
3CC0:  MOVWF  FE9
3CC2:  MOVF   xE1,W
3CC4:  ADDWFC 03,W
3CC6:  MOVWF  FEA
3CC8:  MOVF   FEF,F
3CCA:  BZ    3CEE
....................    { 
....................       i2c_write(text[i]);      
3CCC:  CLRF   03
3CCE:  MOVF   xE2,W
3CD0:  ADDWF  xE0,W
3CD2:  MOVWF  FE9
3CD4:  MOVF   xE1,W
3CD6:  ADDWFC 03,W
3CD8:  MOVWF  FEA
3CDA:  MOVFF  FEF,2E3
3CDE:  MOVFF  2E3,2EC
3CE2:  MOVLB  0
3CE4:  CALL   2CB8
....................    } 
3CE8:  MOVLB  2
3CEA:  INCF   xE2,F
3CEC:  BRA    3CBA
....................    i2c_write('\0'); 
3CEE:  CLRF   xEC
3CF0:  MOVLB  0
3CF2:  CALL   2CB8
....................    i2c_stop(); 
3CF6:  BSF    FC5.2
3CF8:  BTFSC  FC5.2
3CFA:  BRA    3CF8
....................    ///enable_interrupts(GLOBAL); 
.................... } 
3CFC:  GOTO   4310 (RETURN)
....................  
....................  
....................  
....................  
.................... int gblDisplaySensorCounter=0;  // tracks which sensor we have to send next 
....................  
.................... void displaySendSensors(void) { 
....................  
....................    int16 curVal; 
....................    int temp; 
....................  
....................  
....................    ///disable_interrupts(GLOBAL);  
....................  
....................    curVal = readSensor(gblSensorPortMap[gblDisplaySensorCounter]); 
3100:  CLRF   03
3102:  MOVLB  2
3104:  MOVF   x9D,W
3106:  ADDLW  F1
3108:  MOVWF  FE9
310A:  MOVLW  01
310C:  ADDWFC 03,W
310E:  MOVWF  FEA
3110:  MOVFF  FEF,2AA
3114:  MOVFF  2AA,2E1
3118:  MOVLB  0
311A:  CALL   28A2
311E:  MOVFF  02,2A8
3122:  MOVFF  01,2A7
....................     
....................    // send sensor values only if it is less than 1020. This is  
....................    // to minimize the i2c traffic. We assume a value >= 1020  
....................    // means there is no sensor attached to the port. 
....................    // But always send at least sensor1's value. 
....................    if ( (curVal < 1020) || (gblDisplaySensorCounter == 0)) { 
3126:  MOVLB  2
3128:  MOVF   xA8,W
312A:  SUBLW  03
312C:  BNC   3136
312E:  BNZ   313A
3130:  MOVF   xA7,W
3132:  SUBLW  FB
3134:  BC    313A
3136:  MOVF   x9D,F
3138:  BNZ   318C
....................  
....................       // send command 
....................       i2c_start();  
313A:  BSF    FC5.0
313C:  BTFSC  FC5.0
313E:  BRA    313C
....................       i2c_write(gblDisplayAddress);  
3140:  MOVFF  246,2EC
3144:  MOVLB  0
3146:  RCALL  2CB8
....................       i2c_write(DISPLAY_CMD_UPDATE_SENSORS);     
3148:  MOVLW  04
314A:  MOVLB  2
314C:  MOVWF  xEC
314E:  MOVLB  0
3150:  RCALL  2CB8
....................  
....................       // send high byte  
....................       temp =  (int)(curVal >> 8) | (gblDisplaySensorCounter<<5); 
3152:  MOVLB  2
3154:  MOVF   xA8,W
3156:  MOVWF  xAA
3158:  SWAPF  x9D,W
315A:  MOVWF  00
315C:  RLCF   00,F
315E:  MOVLW  E0
3160:  ANDWF  00,F
3162:  MOVF   00,W
3164:  IORWF  xAA,W
3166:  MOVWF  xA9
....................       i2c_write (temp); 
3168:  MOVFF  2A9,2EC
316C:  MOVLB  0
316E:  RCALL  2CB8
....................       // low byte 
....................       i2c_write( (int)(curVal & 0xff) ); 
3170:  MOVLB  2
3172:  MOVFF  2A7,00
3176:  CLRF   03
3178:  MOVFF  2A7,2AA
317C:  MOVFF  2A7,2EC
3180:  MOVLB  0
3182:  RCALL  2CB8
....................       i2c_stop();        
3184:  BSF    FC5.2
3186:  BTFSC  FC5.2
3188:  BRA    3186
318A:  MOVLB  2
.................... //      delay_us(400);  // must wait here 
....................        
....................    } 
....................    gblDisplaySensorCounter++; 
318C:  INCF   x9D,F
....................    gblDisplaySensorCounter %= 8; 
318E:  MOVLW  07
3190:  ANDWF  x9D,F
....................  
....................    ///enable_interrupts(GLOBAL);  
....................     
.................... } 
3192:  MOVLB  0
3194:  GOTO   31DE (RETURN)
....................  
....................  
.................... // =================================================================== 
.................... // LCD Specific commands 
....................  
.................... void clearDisplay(){ 
....................    ///disable_interrupts(GLOBAL); 
....................    i2c_start(); 
3D00:  BSF    FC5.0
3D02:  BTFSC  FC5.0
3D04:  BRA    3D02
....................    i2c_write(gblDisplayAddress); 
3D06:  MOVFF  246,2EC
3D0A:  CALL   2CB8
....................    i2c_write(DISPLAY_CMD_CLS); 
3D0E:  MOVLW  06
3D10:  MOVLB  2
3D12:  MOVWF  xEC
3D14:  MOVLB  0
3D16:  CALL   2CB8
....................    i2c_stop(); 
3D1A:  BSF    FC5.2
3D1C:  BTFSC  FC5.2
3D1E:  BRA    3D1C
....................    ///enable_interrupts(GLOBAL); 
.................... } 
3D20:  GOTO   4376 (RETURN)
....................  
.................... int getDisplayPos(){ 
3D24:  MOVLB  2
3D26:  CLRF   xE0
....................    int pos=0; 
....................    ///disable_interrupts(GLOBAL); 
....................    i2c_start(); 
3D28:  BSF    FC5.0
3D2A:  BTFSC  FC5.0
3D2C:  BRA    3D2A
....................    i2c_write(gblDisplayAddress|0x01);    
3D2E:  MOVF   x46,W
3D30:  IORLW  01
3D32:  MOVWF  xE1
3D34:  MOVWF  xEC
3D36:  MOVLB  0
3D38:  CALL   2CB8
....................    pos=i2c_read(0); 
3D3C:  CLRF   00
3D3E:  CALL   2CD4
3D42:  MOVFF  01,2E0
....................    i2c_stop(); 
3D46:  BSF    FC5.2
3D48:  BTFSC  FC5.2
3D4A:  BRA    3D48
....................    ///enable_interrupts(GLOBAL); 
....................   
....................    return pos; 
3D4C:  MOVLB  2
3D4E:  MOVFF  2E0,01
.................... } 
3D52:  MOVLB  0
3D54:  GOTO   431A (RETURN)
....................  
....................  
.................... void setDisplayPos(int pos){ 
....................    ///disable_interrupts(GLOBAL); 
....................    i2c_start(); 
3D58:  BSF    FC5.0
3D5A:  BTFSC  FC5.0
3D5C:  BRA    3D5A
....................    i2c_write(gblDisplayAddress); 
3D5E:  MOVFF  246,2EC
3D62:  CALL   2CB8
....................    i2c_write(DISPLAY_CMD_SETPOS); 
3D66:  MOVLW  08
3D68:  MOVLB  2
3D6A:  MOVWF  xEC
3D6C:  MOVLB  0
3D6E:  CALL   2CB8
....................    i2c_write(pos);   
3D72:  MOVFF  2E2,2EC
3D76:  CALL   2CB8
....................    i2c_stop(); 
3D7A:  BSF    FC5.2
3D7C:  BTFSC  FC5.2
3D7E:  BRA    3D7C
....................    ///enable_interrupts(GLOBAL); 
.................... } 
3D80:  GOTO   4376 (RETURN)
....................  
....................  
....................  
....................  
.................... #include <bootload.c> 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //       ================================================= 
.................... // 
.................... //       This code is released under the GPL license. Read  
.................... //       the attached license for full information but here's  
.................... //       the basic idea: 
.................... //        - Use it freely 
.................... //        - Let others use your new/modified code freely too 
.................... //        - So, please release the source 
.................... // 
.................... //       ================================================= 
.................... // 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
....................  
.................... //#define writeBufferSize getenv("FLASH_ERASE_SIZE") >> 1  // = 16 on PCM (16F887) 
....................  
....................  
.................... // a slim version of atoi(). 
.................... // converts ascii text to integer 
.................... // i.e. '1' = 1, 'A' = 10 
.................... unsigned int a2i(unsigned char asciiByte) { 
....................  
....................       if (asciiByte >= 'A' && asciiByte <= 'F') 
19E0:  MOVLB  2
19E2:  MOVF   xE6,W
19E4:  SUBLW  40
19E6:  BC    19FA
19E8:  MOVF   xE6,W
19EA:  SUBLW  46
19EC:  BNC   19FA
....................          return((asciiByte) - 'A' + 10); 
19EE:  MOVLW  41
19F0:  SUBWF  xE6,W
19F2:  ADDLW  0A
19F4:  MOVWF  01
19F6:  BRA    1A0C
....................       else if (asciiByte >= '0' && asciiByte <= '9') 
19F8:  BRA    1A0C
19FA:  MOVF   xE6,W
19FC:  SUBLW  2F
19FE:  BC    1A0C
1A00:  MOVF   xE6,W
1A02:  SUBLW  39
1A04:  BNC   1A0C
....................          return( asciiByte - '0'); 
1A06:  MOVLW  30
1A08:  SUBWF  xE6,W
1A0A:  MOVWF  01
.................... } 
1A0C:  MOVLB  0
1A0E:  RETURN 0
....................  
....................  
.................... // convert two ascii text to a 8 bit integer 
.................... unsigned int read8() { 
....................      return( (a2i(usb_cdc_getc()) << 4) + (a2i(usb_cdc_getc())) ); 
1A10:  RCALL  19A6
1A12:  MOVFF  01,2E4
1A16:  MOVFF  01,2E6
1A1A:  RCALL  19E0
1A1C:  SWAPF  01,W
1A1E:  MOVLB  2
1A20:  MOVWF  xE4
1A22:  MOVLW  F0
1A24:  ANDWF  xE4,F
1A26:  MOVLB  0
1A28:  RCALL  19A6
1A2A:  MOVFF  01,2E5
1A2E:  MOVFF  01,2E6
1A32:  RCALL  19E0
1A34:  MOVF   01,W
1A36:  MOVLB  2
1A38:  ADDWF  xE4,W
1A3A:  MOVWF  01
.................... } 
1A3C:  MOVLB  0
1A3E:  RETURN 0
....................  
....................  
.................... // Writes data to flash memory using block mode 
.................... // On PIC16F887, Write Size = 8 Words (16 Bytes), Erase size = 16 Words (32 Bytes) 
.................... // On PIC18F458, Write Size = 8 Bytes, Erase size = 64 Bytes 
.................... // - Whenever we write to the beginning of an erase block, the entire block (16 words) will be 
.................... //   automatically erased (set to 0x3FFF).  
.................... // - So, whenever we want to write some bytes to the flash memory, we need to read the entire 
.................... //   erase block into a buffer, modify that buffer, then write it back to the flash memory. 
....................  
....................  
....................  
.................... void writeFlash(int16 memoryBlockAddress, int16 positionInMemoryBlock, int16 len, int *Buffer) { 
1AD2:  MOVLB  2
1AD4:  BSF    xF1.0
....................  
....................    int writeBuffer[getenv("FLASH_ERASE_SIZE")]; 
....................    int16 i, counter; 
....................    int16 writeLenInThisBlock; 
....................    int1 notDone = 1; 
....................     
....................     
....................     
....................    
....................     
....................    do { 
....................     
....................       // read the entire erase block to memory 
....................       read_program_memory(memoryBlockAddress, writeBuffer, getenv("FLASH_ERASE_SIZE")); 
1AD6:  CLRF   FF8
1AD8:  MOVFF  2E4,FF7
1ADC:  MOVFF  2E3,FF6
1AE0:  MOVLW  05
1AE2:  MOVWF  FEA
1AE4:  MOVLW  23
1AE6:  MOVWF  FE9
1AE8:  MOVLW  04
1AEA:  MOVLB  9
1AEC:  MOVWF  x2B
1AEE:  CLRF   x2A
1AF0:  MOVLB  0
1AF2:  RCALL  1A40
....................        
....................       // if write len is longer than the current memory block -> trim it 
....................       if ( len > (getenv("FLASH_ERASE_SIZE") - positionInMemoryBlock)) { 
1AF4:  MOVLW  00
1AF6:  BSF    FD8.0
1AF8:  MOVLB  2
1AFA:  SUBFWB xE5,W
1AFC:  MOVWF  00
1AFE:  MOVLW  04
1B00:  SUBFWB xE6,W
1B02:  MOVWF  03
1B04:  MOVFF  00,01
1B08:  MOVF   03,W
1B0A:  SUBWF  xE8,W
1B0C:  BNC   1B26
1B0E:  BNZ   1B16
1B10:  MOVF   xE7,W
1B12:  SUBWF  01,W
1B14:  BC    1B26
....................          writeLenInThisBlock = getenv("FLASH_ERASE_SIZE") - positionInMemoryBlock; 
1B16:  MOVLW  00
1B18:  BSF    FD8.0
1B1A:  SUBFWB xE5,W
1B1C:  MOVWF  xEF
1B1E:  MOVLW  04
1B20:  SUBFWB xE6,W
1B22:  MOVWF  xF0
....................       } else { 
1B24:  BRA    1B2E
....................          writeLenInThisBlock = len; 
1B26:  MOVFF  2E8,2F0
1B2A:  MOVFF  2E7,2EF
....................       } 
....................        
....................       // modify parts of the block with the new data 
....................       for (i=positionInMemoryBlock, counter=0; counter<writeLenInThisBlock; i++, counter++) { 
1B2E:  MOVFF  2E6,2EC
1B32:  MOVFF  2E5,2EB
1B36:  CLRF   xEE
1B38:  CLRF   xED
1B3A:  MOVF   xEE,W
1B3C:  SUBWF  xF0,W
1B3E:  BNC   1B8C
1B40:  BNZ   1B48
1B42:  MOVF   xEF,W
1B44:  SUBWF  xED,W
1B46:  BC    1B8C
....................          writeBuffer[i] = *(Buffer+counter); 
1B48:  MOVLW  23
1B4A:  ADDWF  xEB,W
1B4C:  MOVWF  01
1B4E:  MOVLW  05
1B50:  ADDWFC xEC,W
1B52:  MOVFF  01,2F2
1B56:  MOVWF  xF3
1B58:  MOVF   xED,W
1B5A:  ADDWF  xE9,W
1B5C:  MOVWF  01
1B5E:  MOVF   xEE,W
1B60:  ADDWFC xEA,W
1B62:  MOVFF  01,FE9
1B66:  MOVWF  FEA
1B68:  MOVFF  FEF,2F4
1B6C:  MOVFF  2F3,FEA
1B70:  MOVFF  2F2,FE9
1B74:  MOVFF  2F4,FEF
....................       } 
1B78:  MOVFF  2EC,03
1B7C:  MOVF   xEB,W
1B7E:  INCF   xEB,F
1B80:  BTFSC  FD8.2
1B82:  INCF   xEC,F
1B84:  INCF   xED,F
1B86:  BTFSC  FD8.2
1B88:  INCF   xEE,F
1B8A:  BRA    1B3A
....................  
....................       // write the block back to the flash memory.  
....................       for (i=0 ; i< (getenv("FLASH_ERASE_SIZE") / getenv("FLASH_WRITE_SIZE")); i++) { 
1B8C:  CLRF   xEC
1B8E:  CLRF   xEB
1B90:  MOVF   xEC,F
1B92:  BNZ   1C22
1B94:  MOVF   xEB,W
1B96:  SUBLW  0F
1B98:  BNC   1C22
....................          disable_interrupts(GLOBAL); 
1B9A:  BCF    FF2.6
1B9C:  BCF    FF2.7
1B9E:  BTFSC  FF2.7
1BA0:  BRA    1B9C
....................          write_program_memory( memoryBlockAddress + (i * getenv("FLASH_WRITE_SIZE")) , 
....................                                writeBuffer + (i * getenv("FLASH_WRITE_SIZE")),  
....................                                getenv("FLASH_WRITE_SIZE")); 
1BA2:  RLCF   xEB,W
1BA4:  MOVWF  02
1BA6:  RLCF   xEC,W
1BA8:  MOVWF  03
1BAA:  RLCF   02,F
1BAC:  RLCF   03,F
1BAE:  RLCF   02,F
1BB0:  RLCF   03,F
1BB2:  RLCF   02,F
1BB4:  RLCF   03,F
1BB6:  RLCF   02,F
1BB8:  RLCF   03,F
1BBA:  RLCF   02,F
1BBC:  RLCF   03,F
1BBE:  MOVLW  C0
1BC0:  ANDWF  02,F
1BC2:  MOVF   02,W
1BC4:  ADDWF  xE3,W
1BC6:  MOVWF  xF2
1BC8:  MOVF   03,W
1BCA:  ADDWFC xE4,W
1BCC:  MOVWF  xF3
1BCE:  RLCF   xEB,W
1BD0:  MOVWF  02
1BD2:  RLCF   xEC,W
1BD4:  MOVWF  03
1BD6:  RLCF   02,F
1BD8:  RLCF   03,F
1BDA:  RLCF   02,F
1BDC:  RLCF   03,F
1BDE:  RLCF   02,F
1BE0:  RLCF   03,F
1BE2:  RLCF   02,F
1BE4:  RLCF   03,F
1BE6:  RLCF   02,F
1BE8:  RLCF   03,F
1BEA:  MOVLW  C0
1BEC:  ANDWF  02,F
1BEE:  MOVF   02,W
1BF0:  ADDLW  23
1BF2:  MOVWF  xF4
1BF4:  MOVLW  05
1BF6:  ADDWFC 03,W
1BF8:  MOVWF  xF5
1BFA:  CLRF   FF8
1BFC:  MOVFF  2F3,FF7
1C00:  MOVFF  2F2,FF6
1C04:  MOVWF  FEA
1C06:  MOVFF  2F4,FE9
1C0A:  MOVLW  40
1C0C:  MOVLB  9
1C0E:  MOVWF  x2E
1C10:  MOVLB  0
1C12:  RCALL  1A7C
....................          enable_interrupts(GLOBAL); 
1C14:  MOVLW  C0
1C16:  IORWF  FF2,F
....................       } 
1C18:  MOVLB  2
1C1A:  INCF   xEB,F
1C1C:  BTFSC  FD8.2
1C1E:  INCF   xEC,F
1C20:  BRA    1B90
....................        
....................       // if write-data overlaps between memory blocks -> update variables and 
....................       // loop to write the next block 
....................       if ((positionInMemoryBlock + len) > getenv("FLASH_ERASE_SIZE")) { 
1C22:  MOVF   xE7,W
1C24:  ADDWF  xE5,W
1C26:  MOVWF  xF2
1C28:  MOVF   xE8,W
1C2A:  ADDWFC xE6,W
1C2C:  MOVWF  xF3
1C2E:  SUBLW  03
1C30:  BC    1C72
1C32:  XORLW  FF
1C34:  BNZ   1C3C
1C36:  MOVF   xF2,W
1C38:  SUBLW  00
1C3A:  BC    1C72
....................          memoryBlockAddress += getenv("FLASH_ERASE_SIZE"); 
1C3C:  MOVLW  04
1C3E:  ADDWF  xE4,F
....................          len -= getenv("FLASH_ERASE_SIZE") - positionInMemoryBlock; 
1C40:  MOVLW  00
1C42:  BSF    FD8.0
1C44:  SUBFWB xE5,W
1C46:  MOVWF  00
1C48:  MOVLW  04
1C4A:  SUBFWB xE6,W
1C4C:  MOVWF  03
1C4E:  MOVF   00,W
1C50:  SUBWF  xE7,F
1C52:  MOVF   03,W
1C54:  SUBWFB xE8,F
....................          Buffer += getenv("FLASH_ERASE_SIZE") - positionInMemoryBlock; 
1C56:  MOVLW  00
1C58:  BSF    FD8.0
1C5A:  SUBFWB xE5,W
1C5C:  MOVWF  00
1C5E:  MOVLW  04
1C60:  SUBFWB xE6,W
1C62:  MOVWF  03
1C64:  MOVF   00,W
1C66:  ADDWF  xE9,F
1C68:  MOVF   03,W
1C6A:  ADDWFC xEA,F
....................          positionInMemoryBlock = 0; 
1C6C:  CLRF   xE6
1C6E:  CLRF   xE5
....................  
....................       } else { 
1C70:  BRA    1C74
....................          notDone = 0; 
1C72:  BCF    xF1.0
....................       } 
....................    } while (notDone); 
1C74:  BTFSC  xF1.0
1C76:  BRA    1AD6
....................  
....................  
.................... } 
1C78:  MOVLB  0
1C7A:  RETURN 0
....................  
.................... int waitFor(char targetByte) { 
....................    int tollerance=100;  // how many bytes to ignore before giving up 
....................     
....................    while (tollerance > 0) { 
....................       while (!usb_cdc_kbhit()) { 
....................           delay_ms(1); 
....................  
.................... //         usb_task();   // not really neccessary if usb_init() is used instead of usb_init_cs() 
.................... //         delay_ms(1); 
....................       } 
....................        
....................       if (usb_cdc_getc() == targetByte) { 
....................          return(1); 
....................       } 
....................        
....................       tollerance--; 
....................    } 
....................    return(0); 
....................  
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... //  Download a bootloader firmware to the PIC. It will overwrite parts of the  
.................... //  gogo firmware used to store data. The bootloader should be downloaded only 
.................... //  when we want to upgrade the gogo's firmware. Once downloaded, it can then 
.................... //  receive and program the new gogo firmware to the flash memory. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... void downloadBootloader() 
.................... { 
1D2A:  MOVLB  2
1D2C:  BSF    xB7.0
1D2E:  CLRF   xBC
1D30:  BCF    xB7.1
1D32:  CLRF   xC5
....................    int Buffer[SerBufferSize];    // serial input buffer    
....................  
....................    int1 notDone = 1; 
....................  
....................    unsigned int recLen;   // HEX file record length 
....................    unsigned int16 writeAddr;  // HEX file write address 
....................    unsigned char recType;  // HEX file record type 
....................  
....................    unsigned char i=0,j;   // general counters 
.................... ///   unsigned int16 UserBootVectorAddr; // holds the address of our new boot vector 
....................    unsigned int positionInMemoryBlock; 
....................    unsigned int16 memoryBlockAddress; 
....................    unsigned int bufferIndex; 
....................    unsigned int writeLen; 
....................     
....................    int16 BankAddress; 
....................    int1 skipWriting=0; 
....................     
....................    int relocateCount=0; 
....................    #define REC_SIZE  0x10 
....................    int relocateRecordLen[6]; 
....................    int relocateOriginalAddress[6]; 
....................  
.................... //   int flashReadBuffer[getenv("FLASH_ERASE_SIZE")];  // buffer for the relocated first mem block 
....................    int flashReadBuffer[REC_SIZE];  // buffer for the relocated first mem block 
....................  
....................       usb_init(); 
1D34:  MOVLB  0
1D36:  BRA    1998
....................       while(!usb_cdc_connected()); 
1D38:  BTFSS  x7F.0
1D3A:  BRA    1D38
....................  
....................       while (notDone) { 
1D3C:  MOVLB  2
1D3E:  BTFSS  xB7.0
1D40:  BRA    1E72
....................  
....................  
....................          ////////////////////////////////////////// 
....................          /// Wait for ':' 
....................  
....................          do { 
....................             while (!usb_cdc_kbhit()); 
1D42:  MOVLB  0
1D44:  BTFSS  x7C.0
1D46:  BRA    1D44
....................          } while (usb_cdc_getc() != ':'); 
1D48:  RCALL  19A6
1D4A:  MOVF   01,W
1D4C:  SUBLW  3A
1D4E:  BNZ   1D44
....................  
....................  
....................  
....................          ///////////////////////////////////////// 
....................          //  Record length 
....................  
....................          recLen = read8(); 
1D50:  RCALL  1A10
1D52:  MOVFF  01,2B8
....................  
....................          ///////////////////////////////////////// 
....................          //  Write Address 
....................  
....................          writeAddr  = ((int16)read8() << 8) + read8(); 
1D56:  RCALL  1A10
1D58:  MOVLB  2
1D5A:  CLRF   xE3
1D5C:  MOVFF  01,2E2
1D60:  MOVFF  01,2E3
1D64:  CLRF   xE2
1D66:  MOVLB  0
1D68:  RCALL  1A10
1D6A:  MOVF   01,W
1D6C:  MOVLB  2
1D6E:  ADDWF  xE2,W
1D70:  MOVWF  xB9
1D72:  MOVLW  00
1D74:  ADDWFC xE3,W
1D76:  MOVWF  xBA
....................  
....................          ///////////////////////////////////////// 
....................          //  Rec Type 
....................  
....................          usb_cdc_getc();  // ignore the first digit, it is always '0' 
1D78:  MOVLB  0
1D7A:  RCALL  19A6
....................          recType = usb_cdc_getc(); 
1D7C:  RCALL  19A6
1D7E:  MOVFF  01,2BB
....................  
....................          if (recType == '1') { // End of file record 
1D82:  MOVLB  2
1D84:  MOVF   xBB,W
1D86:  SUBLW  31
1D88:  BNZ   1D8E
....................             notDone = 0; 
1D8A:  BCF    xB7.0
....................  
....................          } else if (recType == '4') {  // bank select record 
1D8C:  BRA    1E62
1D8E:  MOVF   xBB,W
1D90:  SUBLW  34
1D92:  BNZ   1DBA
....................  
....................             BankAddress = (read8()<<8) + read8(); 
1D94:  MOVLB  0
1D96:  RCALL  1A10
1D98:  MOVLB  2
1D9A:  CLRF   xE2
1D9C:  MOVLB  0
1D9E:  RCALL  1A10
1DA0:  MOVF   01,W
1DA2:  MOVLB  2
1DA4:  ADDWF  xE2,W
1DA6:  MOVWF  xC3
1DA8:  CLRF   xC4
....................             if (BankAddress != 0) 
1DAA:  MOVF   xC3,F
1DAC:  BNZ   1DB2
1DAE:  MOVF   xC4,F
1DB0:  BZ    1DB6
....................                skipWriting = 1; 
1DB2:  BSF    xB7.1
....................             else 
1DB4:  BRA    1DB8
....................                skipWriting = 0; 
1DB6:  BCF    xB7.1
....................              
....................          } else if ((recType == '0') && !(skipWriting)) { // data record 
1DB8:  BRA    1E62
1DBA:  MOVF   xBB,W
1DBC:  SUBLW  30
1DBE:  BNZ   1E62
1DC0:  BTFSC  xB7.1
1DC2:  BRA    1E62
....................              
....................  
....................             /// get the data 
....................             for (i=0; i < recLen ; i++) { 
1DC4:  CLRF   xBC
1DC6:  MOVF   xB8,W
1DC8:  SUBWF  xBC,W
1DCA:  BC    1DF6
....................                 Buffer[i] = read8(); 
1DCC:  CLRF   03
1DCE:  MOVF   xBC,W
1DD0:  ADDLW  A7
1DD2:  MOVWF  01
1DD4:  MOVLW  02
1DD6:  ADDWFC 03,F
1DD8:  MOVFF  01,2E2
1DDC:  MOVFF  03,2E3
1DE0:  MOVLB  0
1DE2:  RCALL  1A10
1DE4:  MOVFF  2E3,FEA
1DE8:  MOVFF  2E2,FE9
1DEC:  MOVFF  01,FEF
....................                  
....................             } 
1DF0:  MOVLB  2
1DF2:  INCF   xBC,F
1DF4:  BRA    1DC6
....................   
.................... /*            // if data is in the EEPROM area -> do nothing 
....................             if ((writeAddr >= 0x2100) && (writeAddr <= 0x21FF)) { 
....................                // we don't support EEPROM records yet 
....................             } 
.................... */ 
....................  
....................  
....................             // if writing to the first memory block -> we need to temporarily  
....................             // relocate it elsewhere. Since this area contains the boot and  
....................             // interrupt vectors -> it should be written as the very last memory  
....................             // block. 
....................              
....................             if (writeAddr & (0xFFFF ^ (getenv("FLASH_ERASE_SIZE")-1)) == 0) { 
1DF6:  ANDLW  00
1DF8:  MOVWF  00
1DFA:  CLRF   03
1DFC:  MOVF   00,W
1DFE:  IORWF  03,W
1E00:  BZ    1E34
....................                relocateOriginalAddress[relocateCount] = writeAddr; // remmber the orginal location 
1E02:  CLRF   03
1E04:  MOVF   xC5,W
1E06:  ADDLW  CC
1E08:  MOVWF  FE9
1E0A:  MOVLW  02
1E0C:  ADDWFC 03,W
1E0E:  MOVWF  FEA
1E10:  MOVFF  2B9,FEF
....................                relocateRecordLen[relocateCount] = recLen; // remember each record's len 
1E14:  CLRF   03
1E16:  MOVF   xC5,W
1E18:  ADDLW  C6
1E1A:  MOVWF  FE9
1E1C:  MOVLW  02
1E1E:  ADDWFC 03,W
1E20:  MOVWF  FEA
1E22:  MOVFF  2B8,FEF
....................  
....................                writeAddr = RESERVED_MEMORY_START + (relocateCount * REC_SIZE); 
1E26:  MOVF   xC5,W
1E28:  MULLW  10
1E2A:  MOVFF  FF3,2B9
1E2E:  MOVLW  58
1E30:  MOVWF  xBA
....................                relocateCount++; 
1E32:  INCF   xC5,F
....................             }  
....................              
....................             positionInMemoryBlock = writeAddr & (getenv("FLASH_ERASE_SIZE")-1); 
1E34:  MOVFF  2B9,2BE
....................             memoryBlockAddress = writeAddr & (0xFFFF ^ (getenv("FLASH_ERASE_SIZE")-1)); 
1E38:  CLRF   xBF
1E3A:  MOVF   xBA,W
1E3C:  ANDLW  FC
1E3E:  MOVWF  xC0
....................             writeFlash(memoryBlockAddress, positionInMemoryBlock, recLen, Buffer); 
1E40:  MOVFF  2C0,2E4
1E44:  MOVFF  2BF,2E3
1E48:  CLRF   xE6
1E4A:  MOVFF  2BE,2E5
1E4E:  CLRF   xE8
1E50:  MOVFF  2B8,2E7
1E54:  MOVLW  02
1E56:  MOVWF  xEA
1E58:  MOVLW  A7
1E5A:  MOVWF  xE9
1E5C:  MOVLB  0
1E5E:  RCALL  1AD2
1E60:  MOVLB  2
....................  
....................          } 
....................           
....................          if (notDone) 
1E62:  BTFSS  xB7.0
1E64:  BRA    1E70
....................             // Tells the PC to send the next line 
....................             printf(active_comm_putc, "%c",READY_FOR_NEXT); 
1E66:  MOVLW  11
1E68:  MOVWF  xE2
1E6A:  MOVLB  0
1E6C:  RCALL  1D06
1E6E:  MOVLB  2
....................  
....................       } 
1E70:  BRA    1D3E
....................   
....................        // Tells the PC that we are finished 
....................       printf(active_comm_putc,"%c", FINISH_FLAG); 
1E72:  MOVLW  55
1E74:  MOVWF  xE2
1E76:  MOVLB  0
1E78:  RCALL  1D06
....................   
....................       delay_ms(100); 
1E7A:  MOVLW  64
1E7C:  MOVLB  9
1E7E:  MOVWF  x2B
1E80:  MOVLB  0
1E82:  RCALL  18F4
....................        
....................       ///////////////////////////////////////////////////////////////////////// 
....................       // 
....................       //  Now we move the relocated first block to its original place  
....................       // 
....................  
....................       // read the entire flash block to memory 
....................  
....................       disable_interrupts(GLOBAL); 
1E84:  BCF    FF2.6
1E86:  BCF    FF2.7
1E88:  BTFSC  FF2.7
1E8A:  BRA    1E86
....................  
....................       for (i=0;i<relocateCount;i++) { 
1E8C:  MOVLB  2
1E8E:  CLRF   xBC
1E90:  MOVF   xC5,W
1E92:  SUBWF  xBC,W
1E94:  BC    1F0A
....................  
....................          read_program_memory(RESERVED_MEMORY_START + (i*REC_SIZE), flashReadBuffer, REC_SIZE); 
1E96:  MOVF   xBC,W
1E98:  MULLW  10
1E9A:  MOVFF  FF3,2E2
1E9E:  MOVLW  58
1EA0:  MOVWF  xE3
1EA2:  CLRF   FF8
1EA4:  MOVWF  FF7
1EA6:  MOVFF  2E2,FF6
1EAA:  MOVLW  02
1EAC:  MOVWF  FEA
1EAE:  MOVLW  D2
1EB0:  MOVWF  FE9
1EB2:  MOVLB  9
1EB4:  CLRF   x2B
1EB6:  MOVLW  10
1EB8:  MOVWF  x2A
1EBA:  MOVLB  0
1EBC:  RCALL  1A40
....................  
....................          writeAddr = relocateOriginalAddress[i]; 
1EBE:  CLRF   03
1EC0:  MOVLB  2
1EC2:  MOVF   xBC,W
1EC4:  ADDLW  CC
1EC6:  MOVWF  FE9
1EC8:  MOVLW  02
1ECA:  ADDWFC 03,W
1ECC:  MOVWF  FEA
1ECE:  CLRF   xBA
1ED0:  MOVFF  FEF,2B9
....................          writeFlash(0x0, writeAddr, relocateRecordLen[i], flashReadBuffer ); 
1ED4:  CLRF   03
1ED6:  MOVF   xBC,W
1ED8:  ADDLW  C6
1EDA:  MOVWF  FE9
1EDC:  MOVLW  02
1EDE:  ADDWFC 03,W
1EE0:  MOVWF  FEA
1EE2:  MOVFF  FEF,2E2
1EE6:  CLRF   xE4
1EE8:  CLRF   xE3
1EEA:  MOVFF  2BA,2E6
1EEE:  MOVFF  2B9,2E5
1EF2:  CLRF   xE8
1EF4:  MOVFF  2E2,2E7
1EF8:  MOVLW  02
1EFA:  MOVWF  xEA
1EFC:  MOVLW  D2
1EFE:  MOVWF  xE9
1F00:  MOVLB  0
1F02:  RCALL  1AD2
....................       } 
1F04:  MOVLB  2
1F06:  INCF   xBC,F
1F08:  BRA    1E90
....................  
....................       output_low(USER_LED); 
1F0A:  BCF    F8B.0
....................       delay_ms(100); 
1F0C:  MOVLW  64
1F0E:  MOVLB  9
1F10:  MOVWF  x2B
1F12:  MOVLB  0
1F14:  RCALL  18F4
....................  
....................       reset_cpu(); 
1F16:  RESET
....................  
....................  
.................... } 
1F18:  GOTO   5078 (RETURN)
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include <i2c.c> 
....................  
.................... // Registers used to check and clear I2C errors 
.................... #bit SSPEN = 0x14.5 
.................... #bit SSPOV = 0x14.6 
.................... #bit WCOL  = 0x14.7 
....................  
.................... #define SUCCESS      1 
.................... #define NOT_SUCCESS  0 
....................  
....................  
.................... void resetI2C() { 
....................  
....................    // clear the error flag registers and re-enable the i2c bus 
....................    SSPEN = 0;   // disable i2c 
2E2E:  BCF    14.5
....................    SSPOV = 0;   // clear the receive overflow flag 
2E30:  BCF    14.6
....................    WCOL = 0;    // clear the write collision flag 
2E32:  BCF    14.7
....................  
....................    SSPEN = 1;   // re-enable i2c    
2E34:  BSF    14.5
....................  
.................... } 
2E36:  RETURN 0
....................  
....................  
.................... /* 
.................... ///////////////////////////////////////////////////////////////////// 
.................... //  Set register pointer will send one byte to the slave 
.................... ///////////////////////////////////////////////////////////////////// 
....................  
.................... int i2cSetRegisterPointer(int slaveID, int registerAddress) { 
....................  
....................    disable_interrupts(GLOBAL); 
....................  
....................    i2c_start(); 
....................  
....................    // if i2c_write does not return 0 -> it means we did not get an ACK back 
....................    // from the slave. It means the slave is not present or is not working. 
....................  
....................    if ( i2c_write(slaveID | 0) != 0) { 
....................       resetI2C();  // reset the bus (this is optional) 
....................       enable_interrupts(GLOBAL); 
....................  
....................       return(NOT_SUCCESS); 
....................    } 
....................  
....................    // set the register pointer  
....................    i2c_write(registerAddress); 
....................  
....................    i2c_stop(); 
....................    enable_interrupts(GLOBAL); 
....................  
....................    return(SUCCESS); 
....................     
.................... } 
.................... */ 
....................  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Write one byte to the given register address 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... int i2cWrite(int slaveAddress, int registerAddress, int registerValue) { 
....................   ///disable_interrupts(GLOBAL); 
....................  
....................    i2c_start(); 
2EEC:  BSF    FC5.0
2EEE:  BTFSC  FC5.0
2EF0:  BRA    2EEE
....................  
....................    // if i2c_write does not return 0 -> it means we did not get an ACK back 
....................    // from the slave. It means the slave is not present or is not working. 
....................  
....................  
....................     
....................    if (i2c_write(slaveAddress | 0) !=0) { 
2EF2:  MOVFF  2E1,2E4
2EF6:  MOVFF  2E1,2EC
2EFA:  MOVLB  0
2EFC:  RCALL  2CB8
2EFE:  MOVF   01,F
2F00:  BZ    2F0A
....................       resetI2C();  // reset the bus (this is optional) 
2F02:  RCALL  2E2E
....................       ///enable_interrupts(GLOBAL); 
....................       return(NOT_SUCCESS); 
2F04:  MOVLW  00
2F06:  MOVWF  01
2F08:  BRA    2F20
....................        
....................    } 
....................  
....................    
....................    // set the register pointer  
....................    i2c_write(registerAddress); 
2F0A:  MOVFF  2E2,2EC
2F0E:  RCALL  2CB8
....................    // write a value to that location 
....................    i2c_write(registerValue); 
2F10:  MOVFF  2E3,2EC
2F14:  RCALL  2CB8
....................    i2c_stop(); 
2F16:  BSF    FC5.2
2F18:  BTFSC  FC5.2
2F1A:  BRA    2F18
....................    ///enable_interrupts(GLOBAL);  
....................  
....................    return(SUCCESS); 
2F1C:  MOVLW  01
2F1E:  MOVWF  01
....................     
....................  
....................  
.................... } 
2F20:  RETURN 0
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////// 
.................... //  Read a register value at a given address from slave 
.................... // 
.................... //  Note: It is important that we use a second i2c_start() when 
.................... //        we want to switch the data flow from master->slave to  
.................... //        master<-slave. This i2c_start() will actually generate 
.................... //        a "re-start" condition on the bus. DO NOT use i2c_stop() 
.................... //        before this command. The program will not work. 
.................... ///////////////////////////////////////////////////////////////////// 
....................  
.................... int i2cRead(int slaveAddress, int registerAddress, int *registerValue) { 
....................  
....................    ///disable_interrupts(GLOBAL); 
....................  
....................    i2c_start(); 
2E38:  BSF    FC5.0
2E3A:  BTFSC  FC5.0
2E3C:  BRA    2E3A
....................  
....................    // if i2c_write does not return 0 -> it means we did not get an ACK back 
....................    // from the slave. It means the slave is not present or is not working. 
....................  
....................  
....................     
....................    if (i2c_write(slaveAddress | 0) !=0) { 
2E3E:  MOVFF  2E4,2E8
2E42:  MOVFF  2E4,2EC
2E46:  MOVLB  0
2E48:  RCALL  2CB8
2E4A:  MOVF   01,F
2E4C:  BZ    2E56
....................       resetI2C();  // reset the bus (this is optional) 
2E4E:  RCALL  2E2E
....................       ///enable_interrupts(GLOBAL); 
....................       return(NOT_SUCCESS); 
2E50:  MOVLW  00
2E52:  MOVWF  01
2E54:  BRA    2E92
....................        
....................    } 
....................  
....................    
....................    // set the register pointer on the slave device 
....................    i2c_write(registerAddress); 
2E56:  MOVFF  2E5,2EC
2E5A:  RCALL  2CB8
....................     
....................    i2c_start(); 
2E5C:  BSF    FC5.1
2E5E:  BTFSC  FC5.1
2E60:  BRA    2E5E
....................     
....................    // tell the slave we want to read from it by setting bit 0 of the slave 
....................    // address to 1. 
....................    i2c_write(slaveAddress | 1); 
2E62:  MOVLB  2
2E64:  MOVF   xE4,W
2E66:  IORLW  01
2E68:  MOVWF  xE8
2E6A:  MOVWF  xEC
2E6C:  MOVLB  0
2E6E:  RCALL  2CB8
....................     
....................    *registerValue = i2c_read(0); // read from the slave. Parameter 0 tells i2c_read()  
2E70:  MOVFF  2E7,03
2E74:  MOVLB  2
2E76:  MOVFF  2E6,FE9
2E7A:  MOVFF  2E7,FEA
2E7E:  CLRF   00
2E80:  MOVLB  0
2E82:  RCALL  2CD4
2E84:  MOVFF  01,FEF
....................                            // to do a "not acknowledge" or NACK read which tells the  
....................                            // slave to end a read transaction.  
....................                            // Note. Without the NACK, you can continually read 
....................                            // from the slave, getting the sequence of register 
....................                            // values. 
....................    i2c_stop(); 
2E88:  BSF    FC5.2
2E8A:  BTFSC  FC5.2
2E8C:  BRA    2E8A
....................  
....................    ///enable_interrupts(GLOBAL); 
....................  
....................    return(SUCCESS); 
2E8E:  MOVLW  01
2E90:  MOVWF  01
....................     
.................... } 
2E92:  RETURN 0
....................  
....................  
....................  
.................... #include <ds1307.c> 
.................... #define DS1307_ADDRESS  0xD0    // DS1307 I2C Address (Not changable) 
....................  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
2FB2:  MOVFF  2AA,2AB
....................   retval = 0;  
2FB6:  MOVLB  2
2FB8:  CLRF   xAC
....................  
....................   while(1)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
2FBA:  MOVF   xAB,W
2FBC:  SUBLW  09
2FBE:  BC    2FCA
....................     {  
....................       temp -= 10;  
2FC0:  MOVLW  0A
2FC2:  SUBWF  xAB,F
....................       retval += 0x10;  
2FC4:  MOVLW  10
2FC6:  ADDWF  xAC,F
....................     }  
....................     else // Get the ones digit by adding the remainder.  
2FC8:  BRA    2FD0
....................     {  
....................       retval += temp;  
2FCA:  MOVF   xAB,W
2FCC:  ADDWF  xAC,F
....................       break;  
2FCE:  BRA    2FD2
....................     }  
....................   }  
2FD0:  BRA    2FBA
....................  
....................   return(retval);  
2FD2:  MOVFF  2AC,01
.................... }  
2FD6:  MOVLB  0
2FD8:  GOTO   2FE2 (RETURN)
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
2E94:  MOVFF  2E4,2E5
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
2E98:  BCF    FD8.0
2E9A:  MOVLB  2
2E9C:  RRCF   xE5,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
2E9E:  MOVLW  78
2EA0:  ANDWF  xE5,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
2EA2:  RRCF   xE5,W
2EA4:  MOVWF  00
2EA6:  RRCF   00,F
2EA8:  MOVLW  3F
2EAA:  ANDWF  00,F
2EAC:  MOVF   00,W
2EAE:  ADDWF  xE5,W
2EB0:  MOVWF  xE6
2EB2:  MOVF   xE4,W
2EB4:  ANDLW  0F
2EB6:  ADDWF  xE6,W
2EB8:  MOVWF  01
.................... }  
2EBA:  MOVLB  0
2EBC:  GOTO   2EE8 (RETURN)
....................  
....................  
.................... // Initialize the RTC 
.................... // 
.................... // The CH bit is bit 7 at register address 0. 
.................... // The bit is set by default when the DS1307 looses power 
.................... // We need to clear this bit to enable the chip (making the clock tick). 
.................... // 
.................... // We also disabl the squarewave output by clearing bit 4 of register 7 
....................  
.................... void rtcInit() { 
....................  
....................    int temp; 
....................  
....................    // Clear the CH bit 
....................    // ============================== 
....................    // read the current seconds value 
....................    i2cRead(DS1307_ADDRESS, 0, *temp); 
2F22:  CLRF   03
2F24:  MOVLB  2
2F26:  MOVFF  2E0,FE9
2F2A:  MOVFF  03,FEA
2F2E:  MOVFF  FEF,2E1
2F32:  MOVLW  D0
2F34:  MOVWF  xE4
2F36:  CLRF   xE5
2F38:  CLRF   xE7
2F3A:  MOVFF  2E1,2E6
2F3E:  MOVLB  0
2F40:  RCALL  2E38
....................    // clear bit 7 
....................    temp &= 0x7F; 
2F42:  MOVLB  2
2F44:  BCF    xE0.7
....................    delay_us(5);  
2F46:  MOVLW  13
2F48:  MOVWF  00
2F4A:  DECFSZ 00,F
2F4C:  BRA    2F4A
2F4E:  BRA    2F50
....................    // write back the secnds value 
....................    i2cWrite(DS1307_ADDRESS,0,temp); 
2F50:  MOVLW  D0
2F52:  MOVWF  xE1
2F54:  CLRF   xE2
2F56:  MOVFF  2E0,2E3
2F5A:  MOVLB  0
2F5C:  RCALL  2EEC
....................  
....................  
....................    // Set hours to a 24 hr format 
....................    // ============================= 
....................    // read the current hours value 
....................    i2cRead(DS1307_ADDRESS, 2, *temp); 
2F5E:  CLRF   03
2F60:  MOVLB  2
2F62:  MOVFF  2E0,FE9
2F66:  MOVFF  03,FEA
2F6A:  MOVFF  FEF,2E1
2F6E:  MOVLW  D0
2F70:  MOVWF  xE4
2F72:  MOVLW  02
2F74:  MOVWF  xE5
2F76:  CLRF   xE7
2F78:  MOVFF  2E1,2E6
2F7C:  MOVLB  0
2F7E:  RCALL  2E38
....................    // clear bit 6 to set 24hr mode 
....................    bit_clear(temp,6); 
2F80:  MOVLB  2
2F82:  BCF    xE0.6
....................    delay_us(5); 
2F84:  MOVLW  13
2F86:  MOVWF  00
2F88:  DECFSZ 00,F
2F8A:  BRA    2F88
2F8C:  BRA    2F8E
....................    i2cWrite(DS1307_ADDRESS,2,temp); 
2F8E:  MOVLW  D0
2F90:  MOVWF  xE1
2F92:  MOVLW  02
2F94:  MOVWF  xE2
2F96:  MOVFF  2E0,2E3
2F9A:  MOVLB  0
2F9C:  RCALL  2EEC
....................  
....................  
....................    //set the squarewave output freq to 1 Hz 
....................    // - set SQWE bit to 1 
....................    // - set RS1, RS0 to 0 0 for 1 Hz output 
....................    i2cWrite(DS1307_ADDRESS,7,0x10); 
2F9E:  MOVLW  D0
2FA0:  MOVLB  2
2FA2:  MOVWF  xE1
2FA4:  MOVLW  07
2FA6:  MOVWF  xE2
2FA8:  MOVLW  10
2FAA:  MOVWF  xE3
2FAC:  MOVLB  0
2FAE:  RCALL  2EEC
....................    
....................  
.................... } 
2FB0:  RETURN 0
....................  
.................... // Read one byte from the RTC register. Here's the layout 
.................... // 
.................... // Address     Description 
.................... // ==================================== 
.................... // 0           seconds 
.................... // 1           minutes 
.................... // 2           hours (24 hr format) 
.................... // 3           Day of Week (DOW) 
.................... // 4           Date 
.................... // 5           Month 
.................... // 6           Year (0 = the year 2000) 
....................  
.................... int rtcGetItem(int itemNumber) { 
....................  
....................    int temp; 
....................  
....................    if (i2cRead(DS1307_ADDRESS,itemNumber,&temp) != SUCCESS) { 
2EC0:  MOVLW  D0
2EC2:  MOVLB  2
2EC4:  MOVWF  xE4
2EC6:  MOVFF  2E2,2E5
2ECA:  MOVLW  02
2ECC:  MOVWF  xE7
2ECE:  MOVLW  E3
2ED0:  MOVWF  xE6
2ED2:  MOVLB  0
2ED4:  RCALL  2E38
2ED6:  DECFSZ 01,W
2ED8:  BRA    2EDC
2EDA:  BRA    2EE2
....................       return(100);   // 100 is the error code since nothing can be that high 
2EDC:  MOVLW  64
2EDE:  MOVWF  01
2EE0:  BRA    2EEA
....................    } 
....................    return(bcd2bin(temp)); 
2EE2:  MOVFF  2E3,2E4
2EE6:  BRA    2E94
2EE8:  MOVF   01,W
....................  
.................... } 
2EEA:  RETURN 0
....................  
.................... void rtcSetItem(int itemNumber, itemValue) { 
....................    i2cWrite(DS1307_ADDRESS, itemNumber, bin2bcd(itemValue)); 
2FDC:  MOVFF  2A9,2AA
2FE0:  BRA    2FB2
2FE2:  MOVFF  01,2AA
2FE6:  MOVLW  D0
2FE8:  MOVLB  2
2FEA:  MOVWF  xE1
2FEC:  MOVFF  2A8,2E2
2FF0:  MOVFF  01,2E3
2FF4:  MOVLB  0
2FF6:  RCALL  2EEC
.................... } 
2FF8:  GOTO   53B8 (RETURN)
....................  
....................  
.................... /* 
.................... void rtcGetSeconds(int *sec) { 
....................    i2cRead(DS1307_ADDRESS,0,sec); 
....................    *sec = bcd2bin(*sec); 
.................... } 
....................  
.................... void rtcGetMinutes(int *min) { 
....................    i2cRead(DS1307_ADDRESS, 1, min); 
....................    *min = bcd2bin(*min); 
.................... } 
....................  
.................... void rtcGetHours(int *hr) { 
....................    i2cRead(DS1307_ADDRESS, 2, hr); 
....................    *hr = bcd2bin(*hr & 0x3F)); 
.................... } 
....................  
.................... void rtcGetDow(int *dow) { 
....................    i2cRead(DS1307_ADDRESS, 3, dow); 
.................... } 
....................  
.................... void rtcGetDay(int *day) { 
....................    i2cRead(DS1307_ADDRESS, 4, day); 
....................    *day = bcd2bin(*day); 
.................... } 
....................  
.................... void rtcGetMonth(int *mo) { 
....................    i2cRead(DS1307_ADDRESS, 5, mo); 
....................    *mo = bcd2bin(*mo); 
.................... } 
....................  
.................... void rtcGetYear(int *year) { 
....................    i2cRead(DS1307_ADDRESS, 6, year); 
....................    *year = bcd2bin(*year); 
.................... } 
....................  
....................  
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
....................   hr &= 0x3F;  
....................  
....................   i2c_start();  
....................   i2c_write(0xD0);            // I2C write address  
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
....................   i2c_write(bin2bcd(sec));      // REG 0  
....................   i2c_write(bin2bcd(min));      // REG 1  
....................   i2c_write(bin2bcd(hr));      // REG 2  
....................   i2c_write(bin2bcd(dow));      // REG 3  
....................   i2c_write(bin2bcd(day));      // REG 4  
....................   i2c_write(bin2bcd(mth));      // REG 5  
....................   i2c_write(bin2bcd(year));      // REG 6  
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
....................   i2c_stop();  
.................... }  
....................  
.................... void ds1307_get_date(BYTE *day, BYTE *mth, BYTE *year, BYTE *dow)  
.................... {  
....................   i2c_start();  
....................   i2c_write(0xD0);  
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
....................   i2c_start();  
....................   i2c_write(0xD1);  
....................   *dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
....................   *day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
....................   *mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
....................   *year = bcd2bin(i2c_read(0));            // REG 6  
....................   i2c_stop();  
.................... }  
....................  
.................... void ds1307_get_time(BYTE *hr, BYTE *min, BYTE *sec)  
.................... {  
....................   i2c_start();  
....................   i2c_write(0xD0);  
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
....................   i2c_start();  
....................   i2c_write(0xD1);  
....................   *sec = bcd2bin(i2c_read() & 0x7f);  
....................   *min = bcd2bin(i2c_read() & 0x7f);  
....................   *hr  = bcd2bin(i2c_read(0) & 0x3f);  
....................   i2c_stop();  
....................  
.................... }  
....................  
.................... ///////////////////////////////////////////////////////////////////// 
.................... //  Read a register value from the DS1307 
.................... // 
.................... //  Note: It is important that we use a second i2c_start() when 
.................... //        we want to switch the data flow from master->slave to  
.................... //        master<-slave. This i2c_start() will actually generate 
.................... //        a "re-start" condition on the bus. DO NOT use i2c_stop() 
.................... //        before this command. The program will not work. 
.................... ///////////////////////////////////////////////////////////////////// 
....................  
.................... int readRTC(int registerAddress, int *registerValue) { 
....................  
....................    disable_interrupts(GLOBAL); 
....................  
....................    i2c_start(); 
....................  
....................    // if i2c_write does not return 0 -> it means we did not get an ACK back 
....................    // from the slave. It means the slave is not present or is not working. 
....................  
....................  
....................     
....................    if (i2c_write(TARGET_ADDRESS | 0) !=0) { 
....................       resetI2C();  // reset the bus (this is optional) 
....................       enable_interrupts(GLOBAL); 
....................       return(NOT_SUCCESS); 
....................        
....................    } 
....................  
....................    
....................    // set the register pointer on the DS1307 
....................    i2c_write(registerAddress); 
....................     
....................    i2c_start(); 
....................     
....................    // tell the slave we want to read from it by setting bit 0 of the slave 
....................    // address to 1. 
....................    i2c_write(TARGET_ADDRESS | 1); 
....................     
....................    *registerValue = i2c_read(0); // read from the DS1307. Parameter 0 tells i2c_read()  
....................                            // to do a "not acknowledge" or NACK read which tells the  
....................                            // DS1307 to end a read transaction.  
....................                            // Note. Without the NACK, you can continually read 
....................                            // from the DS1307, getting the sequence of register 
....................                            // values. 
....................    i2c_stop(); 
....................  
....................    enable_interrupts(GLOBAL); 
....................  
....................    return(SUCCESS); 
....................     
.................... } 
....................  
.................... */ 
....................  
.................... #include <7segment.c> 
....................  
.................... int Char2Segments(char inChar) { 
....................  
....................    switch(inChar) { 
3744:  MOVLB  2
3746:  MOVF   xF0,W
3748:  XORLW  00
374A:  MOVLB  0
374C:  BTFSC  FD8.2
374E:  BRA    38CC
3750:  XORLW  30
3752:  BTFSC  FD8.2
3754:  BRA    38CC
3756:  XORLW  31
3758:  BTFSC  FD8.2
375A:  BRA    38D4
375C:  XORLW  30
375E:  BTFSC  FD8.2
3760:  BRA    38D4
3762:  XORLW  33
3764:  BTFSC  FD8.2
3766:  BRA    38DC
3768:  XORLW  30
376A:  BTFSC  FD8.2
376C:  BRA    38DC
376E:  XORLW  31
3770:  BTFSC  FD8.2
3772:  BRA    38E4
3774:  XORLW  30
3776:  BTFSC  FD8.2
3778:  BRA    38E4
377A:  XORLW  37
377C:  BTFSC  FD8.2
377E:  BRA    38EC
3780:  XORLW  30
3782:  BTFSC  FD8.2
3784:  BRA    38EC
3786:  XORLW  31
3788:  BTFSC  FD8.2
378A:  BRA    38F4
378C:  XORLW  30
378E:  BTFSC  FD8.2
3790:  BRA    38F4
3792:  XORLW  33
3794:  BTFSC  FD8.2
3796:  BRA    38FC
3798:  XORLW  30
379A:  BTFSC  FD8.2
379C:  BRA    38FC
379E:  XORLW  31
37A0:  BTFSC  FD8.2
37A2:  BRA    3904
37A4:  XORLW  30
37A6:  BTFSC  FD8.2
37A8:  BRA    3904
37AA:  XORLW  3F
37AC:  BTFSC  FD8.2
37AE:  BRA    390C
37B0:  XORLW  30
37B2:  BTFSC  FD8.2
37B4:  BRA    390C
37B6:  XORLW  31
37B8:  BTFSC  FD8.2
37BA:  BRA    3914
37BC:  XORLW  30
37BE:  BTFSC  FD8.2
37C0:  BRA    3914
37C2:  XORLW  33
37C4:  BTFSC  FD8.2
37C6:  BRA    391C
37C8:  XORLW  4B
37CA:  BTFSC  FD8.2
37CC:  BRA    3924
37CE:  XORLW  20
37D0:  BTFSC  FD8.2
37D2:  BRA    3924
37D4:  XORLW  23
37D6:  BTFSC  FD8.2
37D8:  BRA    392C
37DA:  XORLW  20
37DC:  BTFSC  FD8.2
37DE:  BRA    392C
37E0:  XORLW  21
37E2:  BTFSC  FD8.2
37E4:  BRA    3934
37E6:  XORLW  20
37E8:  BTFSC  FD8.2
37EA:  BRA    3934
37EC:  XORLW  27
37EE:  BTFSC  FD8.2
37F0:  BRA    393C
37F2:  XORLW  20
37F4:  BTFSC  FD8.2
37F6:  BRA    393C
37F8:  XORLW  21
37FA:  BTFSC  FD8.2
37FC:  BRA    3944
37FE:  XORLW  20
3800:  BTFSC  FD8.2
3802:  BRA    3944
3804:  XORLW  23
3806:  BTFSC  FD8.2
3808:  BRA    394C
380A:  XORLW  20
380C:  BTFSC  FD8.2
380E:  BRA    394C
3810:  XORLW  21
3812:  BTFSC  FD8.2
3814:  BRA    3954
3816:  XORLW  20
3818:  BTFSC  FD8.2
381A:  BRA    3954
381C:  XORLW  2F
381E:  BTFSC  FD8.2
3820:  BRA    395C
3822:  XORLW  20
3824:  BTFSC  FD8.2
3826:  BRA    395C
3828:  XORLW  21
382A:  BTFSC  FD8.2
382C:  BRA    3964
382E:  XORLW  20
3830:  BTFSC  FD8.2
3832:  BRA    3964
3834:  XORLW  23
3836:  BTFSC  FD8.2
3838:  BRA    396C
383A:  XORLW  20
383C:  BTFSC  FD8.2
383E:  BRA    396C
3840:  XORLW  26
3842:  BTFSC  FD8.2
3844:  BRA    3974
3846:  XORLW  20
3848:  BTFSC  FD8.2
384A:  BRA    3974
384C:  XORLW  22
384E:  BTFSC  FD8.2
3850:  BRA    397C
3852:  XORLW  20
3854:  BTFSC  FD8.2
3856:  BRA    397C
3858:  XORLW  21
385A:  BTFSC  FD8.2
385C:  BRA    3984
385E:  XORLW  20
3860:  BTFSC  FD8.2
3862:  BRA    3984
3864:  XORLW  3F
3866:  BTFSC  FD8.2
3868:  BRA    398C
386A:  XORLW  20
386C:  BTFSC  FD8.2
386E:  BRA    398C
3870:  XORLW  21
3872:  BTFSC  FD8.2
3874:  BRA    3994
3876:  XORLW  20
3878:  BTFSC  FD8.2
387A:  BRA    3994
387C:  XORLW  23
387E:  BTFSC  FD8.2
3880:  BRA    399C
3882:  XORLW  20
3884:  BTFSC  FD8.2
3886:  BRA    399C
3888:  XORLW  21
388A:  BTFSC  FD8.2
388C:  BRA    39A4
388E:  XORLW  20
3890:  BTFSC  FD8.2
3892:  BRA    39A4
3894:  XORLW  27
3896:  BTFSC  FD8.2
3898:  BRA    39AC
389A:  XORLW  20
389C:  BTFSC  FD8.2
389E:  BRA    39AC
38A0:  XORLW  21
38A2:  BTFSC  FD8.2
38A4:  BRA    39B4
38A6:  XORLW  20
38A8:  BTFSC  FD8.2
38AA:  BRA    39B4
38AC:  XORLW  2C
38AE:  BTFSC  FD8.2
38B0:  BRA    39BC
38B2:  XORLW  20
38B4:  BTFSC  FD8.2
38B6:  BRA    39BC
38B8:  XORLW  05
38BA:  BTFSC  FD8.2
38BC:  BRA    39C4
38BE:  XORLW  5C
38C0:  BTFSC  FD8.2
38C2:  BRA    39CC
38C4:  XORLW  37
38C6:  BTFSC  FD8.2
38C8:  BRA    39CC
38CA:  BRA    39CC
....................       case 0:   //0       (used when displaying numbers through number routine) 
....................       case 48:  //ascii 0 (used when displaying numbers through text routine) 
....................          return(0b00111111);  //all segments turned on except for middle segment and decimal point 
38CC:  MOVLW  3F
38CE:  MOVWF  01
38D0:  BRA    39D2
....................          break; 
38D2:  BRA    39D2
....................       case 1:   //1 
....................       case 49:  //ascii 1... etc. 
....................          return(0b00000110); 
38D4:  MOVLW  06
38D6:  MOVWF  01
38D8:  BRA    39D2
....................          break; 
38DA:  BRA    39D2
....................       case 2: 
....................       case 50: 
....................          return(0b01011011); 
38DC:  MOVLW  5B
38DE:  MOVWF  01
38E0:  BRA    39D2
....................          break; 
38E2:  BRA    39D2
....................       case 3: 
....................       case 51: 
....................          return(0b01001111); 
38E4:  MOVLW  4F
38E6:  MOVWF  01
38E8:  BRA    39D2
....................          break; 
38EA:  BRA    39D2
....................       case 4: 
....................       case 52: 
....................          return(0b01100110); 
38EC:  MOVLW  66
38EE:  MOVWF  01
38F0:  BRA    39D2
....................          break; 
38F2:  BRA    39D2
....................       case 5: 
....................       case 53: 
....................          return(0b01101101); 
38F4:  MOVLW  6D
38F6:  MOVWF  01
38F8:  BRA    39D2
....................          break; 
38FA:  BRA    39D2
....................       case 6: 
....................       case 54: 
....................          return(0b01111101); 
38FC:  MOVLW  7D
38FE:  MOVWF  01
3900:  BRA    39D2
....................          break; 
3902:  BRA    39D2
....................       case 7: 
....................       case 55: 
....................          return(0b00000111); 
3904:  MOVLW  07
3906:  MOVWF  01
3908:  BRA    39D2
....................          break; 
390A:  BRA    39D2
....................       case 8: 
....................       case 56: 
....................          return(0b01111111); 
390C:  MOVLW  7F
390E:  MOVWF  01
3910:  BRA    39D2
....................          break; 
3912:  BRA    39D2
....................       case 9: 
....................       case 57: 
....................          return(0b01101111); 
3914:  MOVLW  6F
3916:  MOVWF  01
3918:  BRA    39D2
....................          break; 
391A:  BRA    39D2
....................       case 10: 
....................          return(0b00000000);  //nothing displayed (for non-ones digits), i.e. 0097 displays as 97 
391C:  MOVLW  00
391E:  MOVWF  01
3920:  BRA    39D2
....................          break; 
3922:  BRA    39D2
....................       case 65:   //A 
....................       case 97:   //a 
....................          return(0b01110111); //(A) 
3924:  MOVLW  77
3926:  MOVWF  01
3928:  BRA    39D2
....................          break; 
392A:  BRA    39D2
....................       case 66:   //B 
....................       case 98:   //b 
....................          return(0b01111100); //(b) 
392C:  MOVLW  7C
392E:  MOVWF  01
3930:  BRA    39D2
....................          break; 
3932:  BRA    39D2
....................       case 67:   //C 
....................       case 99:   //c 
....................          return(0b00111001); //(c) 
3934:  MOVLW  39
3936:  MOVWF  01
3938:  BRA    39D2
....................          break; 
393A:  BRA    39D2
....................       case 68:   //D 
....................       case 100:  //d 
....................          return(0b01011110); //(d) 
393C:  MOVLW  5E
393E:  MOVWF  01
3940:  BRA    39D2
....................          break; 
3942:  BRA    39D2
....................       case 69:   //E 
....................       case 101:  //e 
....................          return(0b01111001); //(E) 
3944:  MOVLW  79
3946:  MOVWF  01
3948:  BRA    39D2
....................          break; 
394A:  BRA    39D2
....................       case 70:   //F 
....................       case 102:  //f 
....................          return(0b01110001); //(F) 
394C:  MOVLW  71
394E:  MOVWF  01
3950:  BRA    39D2
....................          break; 
3952:  BRA    39D2
....................       case 71:   //G 
....................       case 103:  //g 
....................          return(0b00111101); //(G) 
3954:  MOVLW  3D
3956:  MOVWF  01
3958:  BRA    39D2
....................          break; 
395A:  BRA    39D2
....................       case 72:   //H 
....................       case 104:  //h 
....................          return(0b01110110); //(h) 
395C:  MOVLW  76
395E:  MOVWF  01
3960:  BRA    39D2
....................          break; 
3962:  BRA    39D2
....................       case 73:   //I 
....................       case 105:  //i 
....................          return(0b00000100); 
3964:  MOVLW  04
3966:  MOVWF  01
3968:  BRA    39D2
....................          break; 
396A:  BRA    39D2
....................       case 74:   //J 
....................       case 106:  //j 
....................          return(0b00001110); 
396C:  MOVLW  0E
396E:  MOVWF  01
3970:  BRA    39D2
....................          break; 
3972:  BRA    39D2
....................       case 76:   //L 
....................       case 108:  //l 
....................          return(0b00111000); 
3974:  MOVLW  38
3976:  MOVWF  01
3978:  BRA    39D2
....................          break; 
397A:  BRA    39D2
....................       case 78:   //N 
....................       case 110:  //n 
....................          return(0b01010100); //(n) 
397C:  MOVLW  54
397E:  MOVWF  01
3980:  BRA    39D2
....................          break; 
3982:  BRA    39D2
....................       case 79:   //O 
....................       case 111:  //o 
....................          return(0b01011100); // (o); 
3984:  MOVLW  5C
3986:  MOVWF  01
3988:  BRA    39D2
....................          break; 
398A:  BRA    39D2
....................       case 80:   //P 
....................       case 112:  //p 
....................          return(0b01110011); //(P) 
398C:  MOVLW  73
398E:  MOVWF  01
3990:  BRA    39D2
....................          break; 
3992:  BRA    39D2
....................       case 81:   //Q 
....................       case 113:  //q 
....................          return(0b01100111); //(q) 
3994:  MOVLW  67
3996:  MOVWF  01
3998:  BRA    39D2
....................          break; 
399A:  BRA    39D2
....................       case 82:   //R 
....................       case 114:  //r 
....................          return(0b01010000); //(r) 
399C:  MOVLW  50
399E:  MOVWF  01
39A0:  BRA    39D2
....................          break; 
39A2:  BRA    39D2
....................       case 83:   //S 
....................       case 115:  //s 
....................          return(0b01101101); //(S) 
39A4:  MOVLW  6D
39A6:  MOVWF  01
39A8:  BRA    39D2
....................          break; 
39AA:  BRA    39D2
....................       case 84:   //T 
....................       case 116:  //t 
....................          return(0b01111000); //(t) 
39AC:  MOVLW  78
39AE:  MOVWF  01
39B0:  BRA    39D2
....................          break; 
39B2:  BRA    39D2
....................       case 85:   //U 
....................       case 117:  //u 
....................          return(0b00111110); //(u) 
39B4:  MOVLW  3E
39B6:  MOVWF  01
39B8:  BRA    39D2
....................          break; 
39BA:  BRA    39D2
....................       case 89:   //Y 
....................       case 121:  //y 
....................          return(0b01101110); //(y) 
39BC:  MOVLW  6E
39BE:  MOVWF  01
39C0:  BRA    39D2
....................          break; 
39C2:  BRA    39D2
....................           
....................       // special characters 
....................       case '|':   // | vertical bar -> shows as double vertical bar 
....................          return(0b00110110); 
39C4:  MOVLW  36
39C6:  MOVWF  01
39C8:  BRA    39D2
....................          break; 
39CA:  BRA    39D2
....................           
....................       case 32:   //space*/ 
....................       case 23:   //i.e. no letter (blank) 
....................       default:   //any characters not coded for will also be blank 
....................          return(0b00000000); 
39CC:  MOVLW  00
39CE:  MOVWF  01
39D0:  BRA    39D2
....................          break; 
....................       } 
....................  
.................... } 
39D2:  RETURN 0
....................  
.................... void cls_internal7Seg() { 
....................    gblCharCodeToShow1=0; 
1254:  MOVLB  1
1256:  CLRF   xB6
....................    gblCharCodeToShow2=0; 
1258:  CLRF   xB7
....................    gblCharCodeToShow3=0; 
125A:  CLRF   xB8
....................    gblCharCodeToShow4=0; 
125C:  CLRF   xB9
....................  
.................... } 
125E:  MOVLB  0
1260:  RETURN 0
....................  
.................... void turnOffAllSegments() { 
....................    output_low(SEG_A); 
1714:  BCF    F8D.1
....................    output_low(SEG_B); 
1716:  BCF    F8D.2
....................    output_low(SEG_C); 
1718:  BCF    F8F.3
....................    output_low(SEG_D); 
171A:  BCF    F8F.1
....................    output_low(SEG_E); 
171C:  BCF    F8F.0
....................    output_low(SEG_F); 
171E:  BCF    F8D.5
....................    output_low(SEG_G); 
1720:  BCF    F8F.4
....................    output_low(SEG_DP);    
1722:  BCF    F8F.2
.................... } 
1724:  GOTO   172A (RETURN)
....................  
.................... // show characters on the screen 
.................... void showOnBuiltIn7Segment(char ch1, char ch2, char ch3, char ch4) { 
....................       gblCharCodeToShow1 = Char2Segments(ch1); 
3BFE:  MOVFF  2EC,2F0
3C02:  RCALL  3744
3C04:  MOVFF  01,1B6
....................       gblCharCodeToShow2 = Char2Segments(ch2); 
3C08:  MOVFF  2ED,2F0
3C0C:  RCALL  3744
3C0E:  MOVFF  01,1B7
....................       gblCharCodeToShow3 = Char2Segments(ch3); 
3C12:  MOVFF  2EE,2F0
3C16:  RCALL  3744
3C18:  MOVFF  01,1B8
....................       gblCharCodeToShow4 = Char2Segments(ch4); 
3C1C:  MOVFF  2EF,2F0
3C20:  RCALL  3744
3C22:  MOVFF  01,1B9
.................... } 
3C26:  GOTO   3C8C (RETURN)
....................  
.................... /// Shows the next digit on th 7-segment display 
.................... /// The code avoids using arrays so most of it is hard coded. 
.................... /// This is done in preference of execution speed over code compactness. 
....................  
.................... void showNextDigit() { 
....................    char charToShow; 
....................    int displayBits; 
....................    int i; 
....................     
....................     
....................    turnOffAllSegments(); 
1728:  BRA    1714
....................  
....................    // enable the current digit 
....................    (gblDisplayDigit == 0) ? output_low(EN_DIGIT1) : output_high(EN_DIGIT1); 
172A:  MOVLB  1
172C:  MOVF   xB5,F
172E:  BNZ   1734
1730:  BCF    F8E.7
1732:  BRA    1736
1734:  BSF    F8E.7
....................    (gblDisplayDigit == 1) ? output_low(EN_DIGIT2) : output_high(EN_DIGIT2); 
1736:  DECFSZ xB5,W
1738:  BRA    173E
173A:  BCF    F8D.3
173C:  BRA    1740
173E:  BSF    F8D.3
....................    (gblDisplayDigit == 2) ? output_low(EN_DIGIT3) : output_high(EN_DIGIT3); 
1740:  MOVF   xB5,W
1742:  SUBLW  02
1744:  BNZ   174A
1746:  BCF    F8D.4
1748:  BRA    174C
174A:  BSF    F8D.4
....................    (gblDisplayDigit == 3) ? output_low(EN_DIGIT4) : output_high(EN_DIGIT4); 
174C:  MOVF   xB5,W
174E:  SUBLW  03
1750:  BNZ   1756
1752:  BCF    F8D.0
1754:  BRA    1758
1756:  BSF    F8D.0
....................     
....................    // fetch the display char code 
....................    if (gblDisplayDigit == 0) displayBits = gblCharCodeToShow1; 
1758:  MOVF   xB5,F
175A:  BNZ   1760
175C:  MOVFF  1B6,A4B
....................    if (gblDisplayDigit == 1) displayBits = gblCharCodeToShow2; 
1760:  DECFSZ xB5,W
1762:  BRA    1768
1764:  MOVFF  1B7,A4B
....................    if (gblDisplayDigit == 2) displayBits = gblCharCodeToShow3; 
1768:  MOVF   xB5,W
176A:  SUBLW  02
176C:  BNZ   1772
176E:  MOVFF  1B8,A4B
....................    if (gblDisplayDigit == 3) displayBits = gblCharCodeToShow4; 
1772:  MOVF   xB5,W
1774:  SUBLW  03
1776:  BNZ   177C
1778:  MOVFF  1B9,A4B
....................  
....................    // show the char code on the 7-segment display 
....................    if (bit_test(displayBits,0)) output_high(SEG_A); 
177C:  MOVLB  A
177E:  BTFSC  x4B.0
1780:  BSF    F8D.1
....................    if (bit_test(displayBits,1)) output_high(SEG_B); 
1782:  BTFSC  x4B.1
1784:  BSF    F8D.2
....................    if (bit_test(displayBits,2)) output_high(SEG_C); 
1786:  BTFSC  x4B.2
1788:  BSF    F8F.3
....................    if (bit_test(displayBits,3)) output_high(SEG_D); 
178A:  BTFSC  x4B.3
178C:  BSF    F8F.1
....................    if (bit_test(displayBits,4)) output_high(SEG_E); 
178E:  BTFSC  x4B.4
1790:  BSF    F8F.0
....................    if (bit_test(displayBits,5)) output_high(SEG_F); 
1792:  BTFSC  x4B.5
1794:  BSF    F8D.5
....................    if (bit_test(displayBits,6)) output_high(SEG_G); 
1796:  BTFSC  x4B.6
1798:  BSF    F8F.4
....................    if (bit_test(displayBits,7)) output_high(SEG_DP); 
179A:  BTFSC  x4B.7
179C:  BSF    F8F.2
....................  
....................    // next digit 
....................    gblDisplayDigit = (gblDisplayDigit+1) % 4; 
179E:  MOVLW  01
17A0:  MOVLB  1
17A2:  ADDWF  xB5,W
17A4:  ANDLW  03
17A6:  MOVWF  xB5
....................     
....................  
.................... } 
17A8:  MOVLB  0
17AA:  GOTO   17B8 (RETURN)
....................  
.................... // This is the original un-optimized code. 
.................... // It is short but consumes more computing cycles 
....................  
.................... //!void showNextDigit() { 
.................... //!   char charToShow; 
.................... //!   int displayBits; 
.................... //!   int i; 
.................... //!    
.................... //!    
.................... //!   // turn off all segments 
.................... //!   for (i=0;i<8;i++) { 
.................... //!      output_low(gblPINMap[i]); 
.................... //!   } 
.................... //!    
.................... //!   // enable the current digit to be displayed 
.................... //!   for (i=0;i<4;i++) { 
.................... //!      if (i!=gblDisplayDigit) { 
.................... //!         output_high(gblDigitEn[i]); 
.................... //!      } else { 
.................... //!         output_low(gblDigitEn[i]); 
.................... //!      } 
.................... //!   } 
.................... //! 
.................... //!   // get the digit -> transform it to the 7-segment code 
.................... //!   charToShow = gblDisplayBuffer[gblDisplayDigit]; 
.................... //!   displayBits = Char2Segments(charToShow); 
.................... //!    
.................... //!   // show the segments 
.................... //!   for (i=0;i<8;i++) { 
.................... //!      output_bit(gblPINMap[i], bit_test(displayBits,i)); 
.................... //!      //output_high(gblPINMap[i]); 
.................... //!   } 
.................... //!   gblDisplayDigit = (gblDisplayDigit+1) % 4; 
.................... //!    
.................... //! 
.................... //!} 
.................... //! 
....................  
....................  
....................  

Configuration Fuses:
   Word  1: F7A6   NOWDT PLL5 STVREN NOXINST NODEBUG NOCPUDIV NOPROTECT
   Word  2: F745   HSPLL FCMEN NOIESO WDT128
   Word  3: FBF8   CCP2C1 MSSPMSK7
